<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>eSolid - Real-Time Kernel: Implementation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="eSolid-logo_small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">eSolid - Real-Time Kernel
   &#160;<span id="projectnumber">1.0BetaR02</span>
   </div>
   <div id="projectbrief">Event Based System</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__kern__impl.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Implementation<div class="ingroups"><a class="el" href="group__kern.html">Kernel</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Kernel port independent code implementation.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Implementation:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__kern__impl.png" border="0" alt="" usemap="#group____kern____impl"/>
<map name="group____kern____impl" id="group____kern____impl">
<area shape="rect" id="node2" href="group__kern.html" title="Kernel overview. " alt="" coords="5,5,64,32"/></map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsysTmr.html">sysTmr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main System Timer structure.  <a href="structsysTmr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga8558d079ebfe8a9af11fc796d46d9ab5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#ga8558d079ebfe8a9af11fc796d46d9ab5">DEF_SCHED_STATE_INTSRV_MSK</a>&#160;&#160;&#160;(0x01u &lt;&lt; 0)</td></tr>
<tr class="memdesc:ga8558d079ebfe8a9af11fc796d46d9ab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel state variable bit position which defines if the kernel is in interrupt servicing state.  <a href="#ga8558d079ebfe8a9af11fc796d46d9ab5">More...</a><br/></td></tr>
<tr class="separator:ga8558d079ebfe8a9af11fc796d46d9ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf8217f5d1bfca8caecc2206fa74abc7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#gaaf8217f5d1bfca8caecc2206fa74abc7">DEF_SCHED_STATE_LOCK_MSK</a>&#160;&#160;&#160;(0x01u &lt;&lt; 1)</td></tr>
<tr class="memdesc:gaaf8217f5d1bfca8caecc2206fa74abc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel state variable bit position which defines if the kernel is locked or not.  <a href="#gaaf8217f5d1bfca8caecc2206fa74abc7">More...</a><br/></td></tr>
<tr class="separator:gaaf8217f5d1bfca8caecc2206fa74abc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19da32f7a4f44e5a4bddb5a588d73677"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#ga19da32f7a4f44e5a4bddb5a588d73677">DEF_THD_CONTRACT_SIGNATURE</a>&#160;&#160;&#160;((portReg_T)0xfeedbeeful)</td></tr>
<tr class="memdesc:ga19da32f7a4f44e5a4bddb5a588d73677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread structure signature.  <a href="#ga19da32f7a4f44e5a4bddb5a588d73677">More...</a><br/></td></tr>
<tr class="separator:ga19da32f7a4f44e5a4bddb5a588d73677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f087a59efb2fe7078a7479aa674b7b4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#ga7f087a59efb2fe7078a7479aa674b7b4">DEF_THDQ_CONTRACT_SIGNATURE</a>&#160;&#160;&#160;((portReg_T)0xfeedbef0ul)</td></tr>
<tr class="memdesc:ga7f087a59efb2fe7078a7479aa674b7b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread Queue structure signature.  <a href="#ga7f087a59efb2fe7078a7479aa674b7b4">More...</a><br/></td></tr>
<tr class="separator:ga7f087a59efb2fe7078a7479aa674b7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed6b30b1e098b37a398f58e2a5b73b8b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#gaed6b30b1e098b37a398f58e2a5b73b8b">DEF_VTMR_CONTRACT_SIGNATURE</a>&#160;&#160;&#160;((portReg_T)0xfeedbef1ul)</td></tr>
<tr class="memdesc:gaed6b30b1e098b37a398f58e2a5b73b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timer structure signature.  <a href="#gaed6b30b1e098b37a398f58e2a5b73b8b">More...</a><br/></td></tr>
<tr class="separator:gaed6b30b1e098b37a398f58e2a5b73b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga177fc11d78c08db1f70168bf971e0059"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#ga177fc11d78c08db1f70168bf971e0059">DLIST_IS_ENTRY_FIRST</a>(list, entry)&#160;&#160;&#160;((entry) == (entry)-&gt;list.next)</td></tr>
<tr class="memdesc:ga177fc11d78c08db1f70168bf971e0059"><td class="mdescLeft">&#160;</td><td class="mdescRight">DList macro: is the thread the first one in the list.  <a href="#ga177fc11d78c08db1f70168bf971e0059">More...</a><br/></td></tr>
<tr class="separator:ga177fc11d78c08db1f70168bf971e0059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad48325fff9eb7b4c41788e190a28cf2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#gaad48325fff9eb7b4c41788e190a28cf2">DLIST_IS_ENTRY_LAST</a>(list, entry)&#160;&#160;&#160;<a class="el" href="group__kern__impl.html#ga177fc11d78c08db1f70168bf971e0059">DLIST_IS_ENTRY_FIRST</a>(list, entry)</td></tr>
<tr class="memdesc:gaad48325fff9eb7b4c41788e190a28cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">DList macro: is the thread the last one in the list.  <a href="#gaad48325fff9eb7b4c41788e190a28cf2">More...</a><br/></td></tr>
<tr class="separator:gaad48325fff9eb7b4c41788e190a28cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77e64b5c52cb61e2bb7f6a4c6b0c9acc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#ga77e64b5c52cb61e2bb7f6a4c6b0c9acc">DLIST_IS_ENTRY_SINGLE</a>(list, entry)&#160;&#160;&#160;<a class="el" href="group__kern__impl.html#ga177fc11d78c08db1f70168bf971e0059">DLIST_IS_ENTRY_FIRST</a>(list, entry)</td></tr>
<tr class="memdesc:ga77e64b5c52cb61e2bb7f6a4c6b0c9acc"><td class="mdescLeft">&#160;</td><td class="mdescRight">DList macro: is the thread single in the list.  <a href="#ga77e64b5c52cb61e2bb7f6a4c6b0c9acc">More...</a><br/></td></tr>
<tr class="separator:ga77e64b5c52cb61e2bb7f6a4c6b0c9acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4b1b58e436cff32fc080493dfa35619"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#gab4b1b58e436cff32fc080493dfa35619">DLIST_ENTRY_NEXT</a>(list, entry)&#160;&#160;&#160;(entry)-&gt;list.next</td></tr>
<tr class="memdesc:gab4b1b58e436cff32fc080493dfa35619"><td class="mdescLeft">&#160;</td><td class="mdescRight">DList macro: get the next entry.  <a href="#gab4b1b58e436cff32fc080493dfa35619">More...</a><br/></td></tr>
<tr class="separator:gab4b1b58e436cff32fc080493dfa35619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23a7667839eb576ddc4f55f2fcf77d65"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#ga23a7667839eb576ddc4f55f2fcf77d65">DLIST_ENTRY_INIT</a>(list, entry)</td></tr>
<tr class="memdesc:ga23a7667839eb576ddc4f55f2fcf77d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">DList macro: initialize entry.  <a href="#ga23a7667839eb576ddc4f55f2fcf77d65">More...</a><br/></td></tr>
<tr class="separator:ga23a7667839eb576ddc4f55f2fcf77d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff514b213c2cd3ad388fd5479275834f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#gaff514b213c2cd3ad388fd5479275834f">DLIST_ENTRY_ADD_AFTER</a>(list, current, entry)</td></tr>
<tr class="memdesc:gaff514b213c2cd3ad388fd5479275834f"><td class="mdescLeft">&#160;</td><td class="mdescRight">DList macro: add new <code>entry</code> after <code>current</code> entry.  <a href="#gaff514b213c2cd3ad388fd5479275834f">More...</a><br/></td></tr>
<tr class="separator:gaff514b213c2cd3ad388fd5479275834f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a663d16206e95f1084af0a44e8518a0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#ga4a663d16206e95f1084af0a44e8518a0">DLIST_ENTRY_RM</a>(list, entry)</td></tr>
<tr class="memdesc:ga4a663d16206e95f1084af0a44e8518a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">DList macro: remove the <code>entry</code> from a list.  <a href="#ga4a663d16206e95f1084af0a44e8518a0">More...</a><br/></td></tr>
<tr class="separator:ga4a663d16206e95f1084af0a44e8518a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga52b5266d709bc1ce3ca9b1838f389023"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#ga52b5266d709bc1ce3ca9b1838f389023">DECL_MODULE_INFO</a> (&quot;Kernel&quot;, ES_KERN_ID,&quot;Nenad Radulovic&quot;)</td></tr>
<tr class="memdesc:ga52b5266d709bc1ce3ca9b1838f389023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Module identification info.  <a href="#ga52b5266d709bc1ce3ca9b1838f389023">More...</a><br/></td></tr>
<tr class="separator:ga52b5266d709bc1ce3ca9b1838f389023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e9ff699d62d6035cd51121bb3140704"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#ga9e9ff699d62d6035cd51121bb3140704">esKernInit</a> (void)</td></tr>
<tr class="memdesc:ga9e9ff699d62d6035cd51121bb3140704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize kernel internal data structures.  <a href="#ga9e9ff699d62d6035cd51121bb3140704">More...</a><br/></td></tr>
<tr class="separator:ga9e9ff699d62d6035cd51121bb3140704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e7a0a6b9c02df58de0f98de0229a09d"><td class="memItemLeft" align="right" valign="top">PORT_C_NORETURN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#ga0e7a0a6b9c02df58de0f98de0229a09d">esKernStart</a> (void)</td></tr>
<tr class="memdesc:ga0e7a0a6b9c02df58de0f98de0229a09d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the multi-threading.  <a href="#ga0e7a0a6b9c02df58de0f98de0229a09d">More...</a><br/></td></tr>
<tr class="separator:ga0e7a0a6b9c02df58de0f98de0229a09d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3182e4c1a47897109d0a429b10a2483e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#ga3182e4c1a47897109d0a429b10a2483e">esKernSysTmr</a> (void)</td></tr>
<tr class="memdesc:ga3182e4c1a47897109d0a429b10a2483e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process the system timer event.  <a href="#ga3182e4c1a47897109d0a429b10a2483e">More...</a><br/></td></tr>
<tr class="separator:ga3182e4c1a47897109d0a429b10a2483e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0d578bcd4a10b2c8e5fc90f0b86ccec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#gac0d578bcd4a10b2c8e5fc90f0b86ccec">esKernIsrEnterI</a> (void)</td></tr>
<tr class="memdesc:gac0d578bcd4a10b2c8e5fc90f0b86ccec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enter Interrupt Service Routine.  <a href="#gac0d578bcd4a10b2c8e5fc90f0b86ccec">More...</a><br/></td></tr>
<tr class="separator:gac0d578bcd4a10b2c8e5fc90f0b86ccec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6347925fff1684b5425dd2857c27129"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#gaa6347925fff1684b5425dd2857c27129">esKernIsrExitI</a> (void)</td></tr>
<tr class="memdesc:gaa6347925fff1684b5425dd2857c27129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit Interrupt Service Routine.  <a href="#gaa6347925fff1684b5425dd2857c27129">More...</a><br/></td></tr>
<tr class="separator:gaa6347925fff1684b5425dd2857c27129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3ca4a02fafcfb840442506f42175a13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#gaa3ca4a02fafcfb840442506f42175a13">esKernLockIntEnter</a> (<a class="el" href="group__kern__lock.html#gad8b2b8257c3bf42c064adb66c0d45e2e">esLockCtx_T</a> *lockCtx)</td></tr>
<tr class="memdesc:gaa3ca4a02fafcfb840442506f42175a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enter a critical code lock.  <a href="#gaa3ca4a02fafcfb840442506f42175a13">More...</a><br/></td></tr>
<tr class="separator:gaa3ca4a02fafcfb840442506f42175a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8cb192a48802804cc12162edd18668d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#gad8cb192a48802804cc12162edd18668d">esKernLockIntExit</a> (<a class="el" href="group__kern__lock.html#gad8b2b8257c3bf42c064adb66c0d45e2e">esLockCtx_T</a> lockCtx)</td></tr>
<tr class="memdesc:gad8cb192a48802804cc12162edd18668d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit a critical code lock.  <a href="#gad8cb192a48802804cc12162edd18668d">More...</a><br/></td></tr>
<tr class="separator:gad8cb192a48802804cc12162edd18668d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dd45355c20a10f7272bd39670353428"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#ga6dd45355c20a10f7272bd39670353428">esKernLockEnterI</a> (void)</td></tr>
<tr class="memdesc:ga6dd45355c20a10f7272bd39670353428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the scheduler.  <a href="#ga6dd45355c20a10f7272bd39670353428">More...</a><br/></td></tr>
<tr class="separator:ga6dd45355c20a10f7272bd39670353428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3287aefb2c7dd24672c716d86a008ad3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#ga3287aefb2c7dd24672c716d86a008ad3">esKernLockExitI</a> (void)</td></tr>
<tr class="memdesc:ga3287aefb2c7dd24672c716d86a008ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the scheduler.  <a href="#ga3287aefb2c7dd24672c716d86a008ad3">More...</a><br/></td></tr>
<tr class="separator:ga3287aefb2c7dd24672c716d86a008ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86ec4f4cbaa889b0f23c7e2ebdcbbb97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#ga86ec4f4cbaa889b0f23c7e2ebdcbbb97">esKernLockEnter</a> (void)</td></tr>
<tr class="memdesc:ga86ec4f4cbaa889b0f23c7e2ebdcbbb97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the scheduler.  <a href="#ga86ec4f4cbaa889b0f23c7e2ebdcbbb97">More...</a><br/></td></tr>
<tr class="separator:ga86ec4f4cbaa889b0f23c7e2ebdcbbb97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1eec663f7cc5c414b113901382ccd82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#gaf1eec663f7cc5c414b113901382ccd82">esKernLockExit</a> (void)</td></tr>
<tr class="memdesc:gaf1eec663f7cc5c414b113901382ccd82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the scheduler.  <a href="#gaf1eec663f7cc5c414b113901382ccd82">More...</a><br/></td></tr>
<tr class="separator:gaf1eec663f7cc5c414b113901382ccd82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac91734f3ee867b519f59bf81cc7fde88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#gac91734f3ee867b519f59bf81cc7fde88">esThdInit</a> (<a class="el" href="group__kern__thd.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *thd, void(*fn)(void *), void *arg, <a class="el" href="group__template__cpu__intf.html#ga13cc91970e3e05fe4210440c068d3f4a">portStck_T</a> *stck, size_t stckSize, uint8_t prio)</td></tr>
<tr class="memdesc:gac91734f3ee867b519f59bf81cc7fde88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the specified thread.  <a href="#gac91734f3ee867b519f59bf81cc7fde88">More...</a><br/></td></tr>
<tr class="separator:gac91734f3ee867b519f59bf81cc7fde88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9d1eac76f26096614e8196bcfd8b905"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#gac9d1eac76f26096614e8196bcfd8b905">esThdTerm</a> (<a class="el" href="group__kern__thd.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *thd)</td></tr>
<tr class="memdesc:gac9d1eac76f26096614e8196bcfd8b905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminate the specified thread.  <a href="#gac9d1eac76f26096614e8196bcfd8b905">More...</a><br/></td></tr>
<tr class="separator:gac9d1eac76f26096614e8196bcfd8b905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8eaa731d0026a8a1667d4422d5031df6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#ga8eaa731d0026a8a1667d4422d5031df6">esThdSetPrioI</a> (<a class="el" href="group__kern__thd.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *thd, uint8_t prio)</td></tr>
<tr class="memdesc:ga8eaa731d0026a8a1667d4422d5031df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the priority of a thread.  <a href="#ga8eaa731d0026a8a1667d4422d5031df6">More...</a><br/></td></tr>
<tr class="separator:ga8eaa731d0026a8a1667d4422d5031df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddd5fe0557c91559b9452beb0fc236fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#gaddd5fe0557c91559b9452beb0fc236fd">esThdQInit</a> (<a class="el" href="group__kern__thdq.html#ga7a1a060699e83a01512ebb5540019556">esThdQ_T</a> *thdQ)</td></tr>
<tr class="memdesc:gaddd5fe0557c91559b9452beb0fc236fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize Thread Queue.  <a href="#gaddd5fe0557c91559b9452beb0fc236fd">More...</a><br/></td></tr>
<tr class="separator:gaddd5fe0557c91559b9452beb0fc236fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5f19b32a7f0c42616b5270dcbd73a3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#gaa5f19b32a7f0c42616b5270dcbd73a3e">esThdQTerm</a> (<a class="el" href="group__kern__thdq.html#ga7a1a060699e83a01512ebb5540019556">esThdQ_T</a> *thdQ)</td></tr>
<tr class="memdesc:gaa5f19b32a7f0c42616b5270dcbd73a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminate Thread Queue.  <a href="#gaa5f19b32a7f0c42616b5270dcbd73a3e">More...</a><br/></td></tr>
<tr class="separator:gaa5f19b32a7f0c42616b5270dcbd73a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9da1e71c137d8adb8c9bdead7052b5fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#ga9da1e71c137d8adb8c9bdead7052b5fa">esThdQAddI</a> (<a class="el" href="group__kern__thdq.html#ga7a1a060699e83a01512ebb5540019556">esThdQ_T</a> *thdQ, <a class="el" href="group__kern__thd.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *thd)</td></tr>
<tr class="memdesc:ga9da1e71c137d8adb8c9bdead7052b5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a thread to the Thread Queue.  <a href="#ga9da1e71c137d8adb8c9bdead7052b5fa">More...</a><br/></td></tr>
<tr class="separator:ga9da1e71c137d8adb8c9bdead7052b5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa18afa95e34035da03c5cb7ea3a96320"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#gaa18afa95e34035da03c5cb7ea3a96320">esThdQRmI</a> (<a class="el" href="group__kern__thdq.html#ga7a1a060699e83a01512ebb5540019556">esThdQ_T</a> *thdQ, <a class="el" href="group__kern__thd.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *thd)</td></tr>
<tr class="memdesc:gaa18afa95e34035da03c5cb7ea3a96320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the thread from the Thread Queue.  <a href="#gaa18afa95e34035da03c5cb7ea3a96320">More...</a><br/></td></tr>
<tr class="separator:gaa18afa95e34035da03c5cb7ea3a96320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1670c123f31c346b24ec9d2b7ae35f88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__kern__thd.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#ga1670c123f31c346b24ec9d2b7ae35f88">esThdQFetchI</a> (const <a class="el" href="group__kern__thdq.html#ga7a1a060699e83a01512ebb5540019556">esThdQ_T</a> *thdQ)</td></tr>
<tr class="memdesc:ga1670c123f31c346b24ec9d2b7ae35f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the first high priority thread from the Thread Queue.  <a href="#ga1670c123f31c346b24ec9d2b7ae35f88">More...</a><br/></td></tr>
<tr class="separator:ga1670c123f31c346b24ec9d2b7ae35f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae365b14292f1496a90d876baec84fb4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__kern__thd.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#gae365b14292f1496a90d876baec84fb4e">esThdQFetchRotateI</a> (<a class="el" href="group__kern__thdq.html#ga7a1a060699e83a01512ebb5540019556">esThdQ_T</a> *thdQ, uint_fast8_t prio)</td></tr>
<tr class="memdesc:gae365b14292f1496a90d876baec84fb4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the next thread and rotate thread linked list.  <a href="#gae365b14292f1496a90d876baec84fb4e">More...</a><br/></td></tr>
<tr class="separator:gae365b14292f1496a90d876baec84fb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf2687b82ce64e2154d97fd3b69a4ab5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__template__compiler.html#ga74fbee312f9185efb602f89d21b53404">bool_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#gacf2687b82ce64e2154d97fd3b69a4ab5">esThdQIsEmpty</a> (const <a class="el" href="group__kern__thdq.html#ga7a1a060699e83a01512ebb5540019556">esThdQ_T</a> *thdQ)</td></tr>
<tr class="memdesc:gacf2687b82ce64e2154d97fd3b69a4ab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is thread queue empty.  <a href="#gacf2687b82ce64e2154d97fd3b69a4ab5">More...</a><br/></td></tr>
<tr class="separator:gacf2687b82ce64e2154d97fd3b69a4ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73e14b1860ce824c822adc407aee0977"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#ga73e14b1860ce824c822adc407aee0977">esSchedRdyAddI</a> (<a class="el" href="group__kern__thd.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *thd)</td></tr>
<tr class="memdesc:ga73e14b1860ce824c822adc407aee0977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add thread <code>thd</code> to the ready thread list and notify the scheduler.  <a href="#ga73e14b1860ce824c822adc407aee0977">More...</a><br/></td></tr>
<tr class="separator:ga73e14b1860ce824c822adc407aee0977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b8263c5024ebb59cd9b95cc9253b44d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#ga0b8263c5024ebb59cd9b95cc9253b44d">esSchedRdyRmI</a> (<a class="el" href="group__kern__thd.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *thd)</td></tr>
<tr class="memdesc:ga0b8263c5024ebb59cd9b95cc9253b44d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove thread <code>thd</code> from the ready thread list and notify the scheduler.  <a href="#ga0b8263c5024ebb59cd9b95cc9253b44d">More...</a><br/></td></tr>
<tr class="separator:ga0b8263c5024ebb59cd9b95cc9253b44d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf90e487bfce974dafaeed5009e189810"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#gaf90e487bfce974dafaeed5009e189810">esSchedYieldI</a> (void)</td></tr>
<tr class="memdesc:gaf90e487bfce974dafaeed5009e189810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force the scheduler invocation which will evaluate all ready threads and switch to ready thread with the highest priority.  <a href="#gaf90e487bfce974dafaeed5009e189810">More...</a><br/></td></tr>
<tr class="separator:gaf90e487bfce974dafaeed5009e189810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbea29b376b29f11bbfc48a0f5144e9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#gafbea29b376b29f11bbfc48a0f5144e9a">esSchedYieldIsrI</a> (void)</td></tr>
<tr class="memdesc:gafbea29b376b29f11bbfc48a0f5144e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force the scheduler invocation which will evaluate all ready threads and switch to ready thread with the highest priority.  <a href="#gafbea29b376b29f11bbfc48a0f5144e9a">More...</a><br/></td></tr>
<tr class="separator:gafbea29b376b29f11bbfc48a0f5144e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45fe650eac73e7fe203cc81565401555"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#ga45fe650eac73e7fe203cc81565401555">esVTmrInitI</a> (<a class="el" href="group__kern__vtmr.html#ga3c020f0ca54ff412bc1d1505502d2afc">esVTmr_T</a> *vTmr, <a class="el" href="group__kern__vtmr.html#ga844873888c186ee81eb66620dadb0451">esTick_T</a> tick, void(*fn)(void *), void *arg)</td></tr>
<tr class="memdesc:ga45fe650eac73e7fe203cc81565401555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add and start a new virtual timer.  <a href="#ga45fe650eac73e7fe203cc81565401555">More...</a><br/></td></tr>
<tr class="separator:ga45fe650eac73e7fe203cc81565401555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad932cf00aec4ba03a0df02ccc493c4c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#gad932cf00aec4ba03a0df02ccc493c4c2">esVTmrInit</a> (<a class="el" href="group__kern__vtmr.html#ga3c020f0ca54ff412bc1d1505502d2afc">esVTmr_T</a> *vTmr, <a class="el" href="group__kern__vtmr.html#ga844873888c186ee81eb66620dadb0451">esTick_T</a> tick, void(*fn)(void *), void *arg)</td></tr>
<tr class="memdesc:gad932cf00aec4ba03a0df02ccc493c4c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add and start a new virtual timer.  <a href="#gad932cf00aec4ba03a0df02ccc493c4c2">More...</a><br/></td></tr>
<tr class="separator:gad932cf00aec4ba03a0df02ccc493c4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96bb2c81f649c0305dfd08d1c79b2e37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#ga96bb2c81f649c0305dfd08d1c79b2e37">esVTmrTermI</a> (<a class="el" href="group__kern__vtmr.html#ga3c020f0ca54ff412bc1d1505502d2afc">esVTmr_T</a> *vTmr)</td></tr>
<tr class="memdesc:ga96bb2c81f649c0305dfd08d1c79b2e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel and remove a virtual timer.  <a href="#ga96bb2c81f649c0305dfd08d1c79b2e37">More...</a><br/></td></tr>
<tr class="separator:ga96bb2c81f649c0305dfd08d1c79b2e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6ec93a68e3526f18ed926cd441878cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#gad6ec93a68e3526f18ed926cd441878cd">esVTmrTerm</a> (<a class="el" href="group__kern__vtmr.html#ga3c020f0ca54ff412bc1d1505502d2afc">esVTmr_T</a> *vTmr)</td></tr>
<tr class="memdesc:gad6ec93a68e3526f18ed926cd441878cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel and remove a virtual timer.  <a href="#gad6ec93a68e3526f18ed926cd441878cd">More...</a><br/></td></tr>
<tr class="separator:gad6ec93a68e3526f18ed926cd441878cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26d10c6aaa0cd1d04261d2c9911e890d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#ga26d10c6aaa0cd1d04261d2c9911e890d">esVTmrDelay</a> (<a class="el" href="group__kern__vtmr.html#ga844873888c186ee81eb66620dadb0451">esTick_T</a> tick)</td></tr>
<tr class="memdesc:ga26d10c6aaa0cd1d04261d2c9911e890d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delay for specified amount of ticks.  <a href="#ga26d10c6aaa0cd1d04261d2c9911e890d">More...</a><br/></td></tr>
<tr class="separator:ga26d10c6aaa0cd1d04261d2c9911e890d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb0d88d6a7e467dc37a6a9a85945aaa6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__kern__vtmr.html#ga844873888c186ee81eb66620dadb0451">esTick_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#gacb0d88d6a7e467dc37a6a9a85945aaa6">esSysTmrTickGet</a> (void)</td></tr>
<tr class="memdesc:gacb0d88d6a7e467dc37a6a9a85945aaa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current tick value.  <a href="#gacb0d88d6a7e467dc37a6a9a85945aaa6">More...</a><br/></td></tr>
<tr class="separator:gacb0d88d6a7e467dc37a6a9a85945aaa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gad8535f99414ea3e0e37a91fd6600246e"><td class="memItemLeft" align="right" valign="top">static uint_fast8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#gad8535f99414ea3e0e37a91fd6600246e">KernLockCnt</a></td></tr>
<tr class="memdesc:gad8535f99414ea3e0e37a91fd6600246e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel Lock Counter.  <a href="#gad8535f99414ea3e0e37a91fd6600246e">More...</a><br/></td></tr>
<tr class="separator:gad8535f99414ea3e0e37a91fd6600246e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93a7ee7768ffd94201bf1795a543194b"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structkernCtrl__.html">kernCtrl_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#ga93a7ee7768ffd94201bf1795a543194b">KernCtrl</a></td></tr>
<tr class="memdesc:ga93a7ee7768ffd94201bf1795a543194b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel control initialization.  <a href="#ga93a7ee7768ffd94201bf1795a543194b">More...</a><br/></td></tr>
<tr class="separator:ga93a7ee7768ffd94201bf1795a543194b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
System timer</h2></td></tr>
<tr class="memitem:gaf4fd8bfc453bbab3d94186c863a180c0"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structsysTmr.html">sysTmr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#gaf4fd8bfc453bbab3d94186c863a180c0">SysTmr</a></td></tr>
<tr class="memdesc:gaf4fd8bfc453bbab3d94186c863a180c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main System Timer structure.  <a href="#gaf4fd8bfc453bbab3d94186c863a180c0">More...</a><br/></td></tr>
<tr class="separator:gaf4fd8bfc453bbab3d94186c863a180c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49813e0a9a014d99d076943e96b2408c"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structesVTmr.html">esVTmr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#ga49813e0a9a014d99d076943e96b2408c">VTmrArmed</a></td></tr>
<tr class="memdesc:ga49813e0a9a014d99d076943e96b2408c"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of virtual armed timers waiting to expire.  <a href="#ga49813e0a9a014d99d076943e96b2408c">More...</a><br/></td></tr>
<tr class="separator:ga49813e0a9a014d99d076943e96b2408c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac27c4e18276b392295b973fc00f31765"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structesVTmr.html">esVTmr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#gac27c4e18276b392295b973fc00f31765">VTmrPend</a></td></tr>
<tr class="memdesc:gac27c4e18276b392295b973fc00f31765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual timers pending to be inserted into waiting list.  <a href="#gac27c4e18276b392295b973fc00f31765">More...</a><br/></td></tr>
<tr class="separator:gac27c4e18276b392295b973fc00f31765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab82048477ffd940e6eff13d4280eb72"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structesThd.html">esThd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#gaab82048477ffd940e6eff13d4280eb72">KVTmr</a></td></tr>
<tr class="memdesc:gaab82048477ffd940e6eff13d4280eb72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual timer thread ID.  <a href="#gaab82048477ffd940e6eff13d4280eb72">More...</a><br/></td></tr>
<tr class="separator:gaab82048477ffd940e6eff13d4280eb72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa284b6ec458b79a49c54eedc738259fb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__template__compiler.html#ga87952d6e574c7f437503926e833ba345">PORT_C_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#gaa284b6ec458b79a49c54eedc738259fb">sysTmrInit</a> (void)</td></tr>
<tr class="memdesc:gaa284b6ec458b79a49c54eedc738259fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize system timer hardware.  <a href="#gaa284b6ec458b79a49c54eedc738259fb">More...</a><br/></td></tr>
<tr class="separator:gaa284b6ec458b79a49c54eedc738259fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac3698a7627e9d0b7b1f0d5f741d2816"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__template__compiler.html#ga87952d6e574c7f437503926e833ba345">PORT_C_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#gaac3698a7627e9d0b7b1f0d5f741d2816">sysTmrActivate</a> (void)</td></tr>
<tr class="memdesc:gaac3698a7627e9d0b7b1f0d5f741d2816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to activate system timer.  <a href="#gaac3698a7627e9d0b7b1f0d5f741d2816">More...</a><br/></td></tr>
<tr class="separator:gaac3698a7627e9d0b7b1f0d5f741d2816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab564a700462dce0be7ba31f2d3022f7b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__template__compiler.html#ga87952d6e574c7f437503926e833ba345">PORT_C_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#gab564a700462dce0be7ba31f2d3022f7b">sysTmrDeactivateI</a> (void)</td></tr>
<tr class="memdesc:gab564a700462dce0be7ba31f2d3022f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to deactivate system timer.  <a href="#gab564a700462dce0be7ba31f2d3022f7b">More...</a><br/></td></tr>
<tr class="separator:gab564a700462dce0be7ba31f2d3022f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Priority Bit Map</h2></td></tr>
<tr class="memitem:gaccc724ae39d88a6fcf21891c390ea845"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__template__compiler.html#ga87952d6e574c7f437503926e833ba345">PORT_C_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#gaccc724ae39d88a6fcf21891c390ea845">pbmInit</a> (struct pbm_ *pbm)</td></tr>
<tr class="memdesc:gaccc724ae39d88a6fcf21891c390ea845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize bitmap.  <a href="#gaccc724ae39d88a6fcf21891c390ea845">More...</a><br/></td></tr>
<tr class="separator:gaccc724ae39d88a6fcf21891c390ea845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd45c91981a68e1b23c765e8eb59b07b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__template__compiler.html#ga87952d6e574c7f437503926e833ba345">PORT_C_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#gabd45c91981a68e1b23c765e8eb59b07b">pbmSet</a> (struct pbm_ *pbm, uint_fast8_t prio)</td></tr>
<tr class="memdesc:gabd45c91981a68e1b23c765e8eb59b07b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the bit corresponding to the prio argument.  <a href="#gabd45c91981a68e1b23c765e8eb59b07b">More...</a><br/></td></tr>
<tr class="separator:gabd45c91981a68e1b23c765e8eb59b07b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53b46c788cfe6e4cc27ee6a3b6c1dfea"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__template__compiler.html#ga87952d6e574c7f437503926e833ba345">PORT_C_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#ga53b46c788cfe6e4cc27ee6a3b6c1dfea">pbmClear</a> (struct pbm_ *pbm, uint_fast8_t prio)</td></tr>
<tr class="memdesc:ga53b46c788cfe6e4cc27ee6a3b6c1dfea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the bit corresponding to the prio argument.  <a href="#ga53b46c788cfe6e4cc27ee6a3b6c1dfea">More...</a><br/></td></tr>
<tr class="separator:ga53b46c788cfe6e4cc27ee6a3b6c1dfea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga126e2a40ac85cba9f8ce32b803cb8906"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__template__compiler.html#ga87952d6e574c7f437503926e833ba345">PORT_C_INLINE</a> uint_fast8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#ga126e2a40ac85cba9f8ce32b803cb8906">pbmGetHighest</a> (const struct pbm_ *pbm)</td></tr>
<tr class="memdesc:ga126e2a40ac85cba9f8ce32b803cb8906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the highest priority set.  <a href="#ga126e2a40ac85cba9f8ce32b803cb8906">More...</a><br/></td></tr>
<tr class="separator:ga126e2a40ac85cba9f8ce32b803cb8906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae681fb07746d91e97533dfcd9d7b9a9c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__template__compiler.html#ga87952d6e574c7f437503926e833ba345">PORT_C_INLINE</a> <a class="el" href="group__template__compiler.html#ga74fbee312f9185efb602f89d21b53404">bool_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#gae681fb07746d91e97533dfcd9d7b9a9c">pbmIsEmpty</a> (const struct pbm_ *pbm)</td></tr>
<tr class="memdesc:gae681fb07746d91e97533dfcd9d7b9a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is bit map empty?  <a href="#gae681fb07746d91e97533dfcd9d7b9a9c">More...</a><br/></td></tr>
<tr class="separator:gae681fb07746d91e97533dfcd9d7b9a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Scheduler</h2></td></tr>
<tr class="memitem:gafa3f26429f0f60e0d50eb119de1c8f49"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structesThdQ.html">esThdQ</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#gafa3f26429f0f60e0d50eb119de1c8f49">RdyQueue</a></td></tr>
<tr class="memdesc:gafa3f26429f0f60e0d50eb119de1c8f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ready Thread queue.  <a href="#gafa3f26429f0f60e0d50eb119de1c8f49">More...</a><br/></td></tr>
<tr class="separator:gafa3f26429f0f60e0d50eb119de1c8f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a8d1dd61629856ac10022cd044591a3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__template__compiler.html#ga87952d6e574c7f437503926e833ba345">PORT_C_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#ga3a8d1dd61629856ac10022cd044591a3">schedInit</a> (void)</td></tr>
<tr class="memdesc:ga3a8d1dd61629856ac10022cd044591a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize Ready Thread Queue structure <a class="el" href="group__kern__impl.html#gafa3f26429f0f60e0d50eb119de1c8f49">RdyQueue</a> and Kernel control structure <a class="el" href="structkernCtrl__.html">kernCtrl_</a>.  <a href="#ga3a8d1dd61629856ac10022cd044591a3">More...</a><br/></td></tr>
<tr class="separator:ga3a8d1dd61629856ac10022cd044591a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2fd7336d999c956fa8b74a2405cffc7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__template__compiler.html#ga87952d6e574c7f437503926e833ba345">PORT_C_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#gaa2fd7336d999c956fa8b74a2405cffc7">schedStart</a> (void)</td></tr>
<tr class="memdesc:gaa2fd7336d999c956fa8b74a2405cffc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the scheduler data structures for multi-threading.  <a href="#gaa2fd7336d999c956fa8b74a2405cffc7">More...</a><br/></td></tr>
<tr class="separator:gaa2fd7336d999c956fa8b74a2405cffc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaab2c30affeef2604f69bea4d19f32e4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__template__compiler.html#ga87952d6e574c7f437503926e833ba345">PORT_C_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#gaaab2c30affeef2604f69bea4d19f32e4">schedSleep</a> (void)</td></tr>
<tr class="memdesc:gaaab2c30affeef2604f69bea4d19f32e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the scheduler to sleep.  <a href="#gaaab2c30affeef2604f69bea4d19f32e4">More...</a><br/></td></tr>
<tr class="separator:gaaab2c30affeef2604f69bea4d19f32e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ac09697c7f2168695a853598caac057"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__template__compiler.html#ga87952d6e574c7f437503926e833ba345">PORT_C_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#ga0ac09697c7f2168695a853598caac057">schedWakeUpI</a> (void)</td></tr>
<tr class="memdesc:ga0ac09697c7f2168695a853598caac057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wake up the scheduler.  <a href="#ga0ac09697c7f2168695a853598caac057">More...</a><br/></td></tr>
<tr class="separator:ga0ac09697c7f2168695a853598caac057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1317c12a1355ee8db4f104338f1df88d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__template__compiler.html#ga87952d6e574c7f437503926e833ba345">PORT_C_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#ga1317c12a1355ee8db4f104338f1df88d">schedRdyAddInitI</a> (<a class="el" href="group__kern__thd.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *thd)</td></tr>
<tr class="memdesc:ga1317c12a1355ee8db4f104338f1df88d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize scheduler ready structure during the thread add operation.  <a href="#ga1317c12a1355ee8db4f104338f1df88d">More...</a><br/></td></tr>
<tr class="separator:ga1317c12a1355ee8db4f104338f1df88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56290a8f51b1d3babec91602292c8d61"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__template__compiler.html#ga87952d6e574c7f437503926e833ba345">PORT_C_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#ga56290a8f51b1d3babec91602292c8d61">schedQmNextI</a> (void)</td></tr>
<tr class="memdesc:ga56290a8f51b1d3babec91602292c8d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch and try to schedule the next thread of the same priority as the current thread.  <a href="#ga56290a8f51b1d3babec91602292c8d61">More...</a><br/></td></tr>
<tr class="separator:ga56290a8f51b1d3babec91602292c8d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf57b17dda8d71ce9e7ef57ea0e7ef534"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__template__compiler.html#ga87952d6e574c7f437503926e833ba345">PORT_C_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#gaf57b17dda8d71ce9e7ef57ea0e7ef534">schedQmI</a> (void)</td></tr>
<tr class="memdesc:gaf57b17dda8d71ce9e7ef57ea0e7ef534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do the Quantum (Round-Robin) scheduling.  <a href="#gaf57b17dda8d71ce9e7ef57ea0e7ef534">More...</a><br/></td></tr>
<tr class="separator:gaf57b17dda8d71ce9e7ef57ea0e7ef534"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Virtual Timer and Virtual Timer kernel thread</h2></td></tr>
<tr class="memitem:ga6ebc5795dbcc15e76f768133ba99ab17"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__template__compiler.html#ga87952d6e574c7f437503926e833ba345">PORT_C_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#ga6ebc5795dbcc15e76f768133ba99ab17">vTmrSleep</a> (<a class="el" href="group__kern__vtmr.html#ga844873888c186ee81eb66620dadb0451">esTick_T</a> ticks)</td></tr>
<tr class="memdesc:ga6ebc5795dbcc15e76f768133ba99ab17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up system timer for different tick period during sleeping.  <a href="#ga6ebc5795dbcc15e76f768133ba99ab17">More...</a><br/></td></tr>
<tr class="separator:ga6ebc5795dbcc15e76f768133ba99ab17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4f2cc4d4d36c36efb272306595a4474"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__template__compiler.html#ga87952d6e574c7f437503926e833ba345">PORT_C_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#gab4f2cc4d4d36c36efb272306595a4474">vTmrEvaluateI</a> (void)</td></tr>
<tr class="memdesc:gab4f2cc4d4d36c36efb272306595a4474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate armed virtual timers.  <a href="#gab4f2cc4d4d36c36efb272306595a4474">More...</a><br/></td></tr>
<tr class="separator:gab4f2cc4d4d36c36efb272306595a4474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga653b749536e91933ea9b651dbb8d5962"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#ga653b749536e91933ea9b651dbb8d5962">vTmrAddArmedS</a> (<a class="el" href="group__kern__vtmr.html#ga3c020f0ca54ff412bc1d1505502d2afc">esVTmr_T</a> *vTmr)</td></tr>
<tr class="memdesc:ga653b749536e91933ea9b651dbb8d5962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a virtual timer into sorted list.  <a href="#ga653b749536e91933ea9b651dbb8d5962">More...</a><br/></td></tr>
<tr class="separator:ga653b749536e91933ea9b651dbb8d5962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ac5061b01fd5124dc99cba3a10b6025"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__template__compiler.html#ga87952d6e574c7f437503926e833ba345">PORT_C_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#ga0ac5061b01fd5124dc99cba3a10b6025">vTmrImportPendSleepI</a> (void)</td></tr>
<tr class="memdesc:ga0ac5061b01fd5124dc99cba3a10b6025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import timers from pending list to armed list.  <a href="#ga0ac5061b01fd5124dc99cba3a10b6025">More...</a><br/></td></tr>
<tr class="separator:ga0ac5061b01fd5124dc99cba3a10b6025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ae79f667b0f7420b31e8a609c3150a0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#ga9ae79f667b0f7420b31e8a609c3150a0">vTmrImportPend</a> (void)</td></tr>
<tr class="memdesc:ga9ae79f667b0f7420b31e8a609c3150a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import timers from pending list to armed list.  <a href="#ga9ae79f667b0f7420b31e8a609c3150a0">More...</a><br/></td></tr>
<tr class="separator:ga9ae79f667b0f7420b31e8a609c3150a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa03a91aeb99719724bc64c292f1a5959"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#gaa03a91aeb99719724bc64c292f1a5959">kVTmrInit</a> (void)</td></tr>
<tr class="memdesc:gaa03a91aeb99719724bc64c292f1a5959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization of Virtual Timer kernel thread.  <a href="#gaa03a91aeb99719724bc64c292f1a5959">More...</a><br/></td></tr>
<tr class="separator:gaa03a91aeb99719724bc64c292f1a5959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadef1fcf2218955344b2e1d5027f80bee"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#gadef1fcf2218955344b2e1d5027f80bee">kVTmr</a> (void *arg)</td></tr>
<tr class="memdesc:gadef1fcf2218955344b2e1d5027f80bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual Timer thread code.  <a href="#gadef1fcf2218955344b2e1d5027f80bee">More...</a><br/></td></tr>
<tr class="separator:gadef1fcf2218955344b2e1d5027f80bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Idle kernel thread</h2></td></tr>
<tr class="memitem:ga639ded61b40c01f4a1f54814c4b94513"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structesThd.html">esThd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#ga639ded61b40c01f4a1f54814c4b94513">KIdle</a></td></tr>
<tr class="memdesc:ga639ded61b40c01f4a1f54814c4b94513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Idle thread ID.  <a href="#ga639ded61b40c01f4a1f54814c4b94513">More...</a><br/></td></tr>
<tr class="separator:ga639ded61b40c01f4a1f54814c4b94513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39cf986cee12aa37a066532e80a5f72a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#ga39cf986cee12aa37a066532e80a5f72a">kIdleInit</a> (void)</td></tr>
<tr class="memdesc:ga39cf986cee12aa37a066532e80a5f72a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization of Idle thread.  <a href="#ga39cf986cee12aa37a066532e80a5f72a">More...</a><br/></td></tr>
<tr class="separator:ga39cf986cee12aa37a066532e80a5f72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e968162935156b6617ff0d5cbccbe1c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#ga4e968162935156b6617ff0d5cbccbe1c">kIdle</a> (void *arg)</td></tr>
<tr class="memdesc:ga4e968162935156b6617ff0d5cbccbe1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Idle thread code.  <a href="#ga4e968162935156b6617ff0d5cbccbe1c">More...</a><br/></td></tr>
<tr class="separator:ga4e968162935156b6617ff0d5cbccbe1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Basic thread synchronization</h2></td></tr>
<tr class="memitem:gaae0a028e9f472994def9358f16cc40d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#gaae0a028e9f472994def9358f16cc40d3">thdPost</a> (<a class="el" href="group__kern__thd.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *thd)</td></tr>
<tr class="memdesc:gaae0a028e9f472994def9358f16cc40d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post a signal to a thread which is waiting.  <a href="#gaae0a028e9f472994def9358f16cc40d3">More...</a><br/></td></tr>
<tr class="separator:gaae0a028e9f472994def9358f16cc40d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59935809f83133fb909c513fb72576b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__impl.html#ga59935809f83133fb909c513fb72576b7">thdWait</a> (void)</td></tr>
<tr class="memdesc:ga59935809f83133fb909c513fb72576b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a signal.  <a href="#ga59935809f83133fb909c513fb72576b7">More...</a><br/></td></tr>
<tr class="separator:ga59935809f83133fb909c513fb72576b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Kernel port independent code implementation. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga8558d079ebfe8a9af11fc796d46d9ab5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEF_SCHED_STATE_INTSRV_MSK&#160;&#160;&#160;(0x01u &lt;&lt; 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel state variable bit position which defines if the kernel is in interrupt servicing state. </p>

</div>
</div>
<a class="anchor" id="gaaf8217f5d1bfca8caecc2206fa74abc7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEF_SCHED_STATE_LOCK_MSK&#160;&#160;&#160;(0x01u &lt;&lt; 1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel state variable bit position which defines if the kernel is locked or not. </p>

</div>
</div>
<a class="anchor" id="ga19da32f7a4f44e5a4bddb5a588d73677"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEF_THD_CONTRACT_SIGNATURE&#160;&#160;&#160;((portReg_T)0xfeedbeeful)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thread structure signature. </p>
<p>The signature is used to confirm that a structure passed to a kernel function is indeed a esThd_T thread structure. </p>

</div>
</div>
<a class="anchor" id="ga7f087a59efb2fe7078a7479aa674b7b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEF_THDQ_CONTRACT_SIGNATURE&#160;&#160;&#160;((portReg_T)0xfeedbef0ul)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thread Queue structure signature. </p>
<p>The signature is used to confirm that a structure passed to a kernel function is indeed a esThdQ_T thread queue structure. </p>

</div>
</div>
<a class="anchor" id="gaed6b30b1e098b37a398f58e2a5b73b8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEF_VTMR_CONTRACT_SIGNATURE&#160;&#160;&#160;((portReg_T)0xfeedbef1ul)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Timer structure signature. </p>
<p>The signature is used to confirm that a structure passed to a timer function is indeed a esVTmr_T timer structure. </p>

</div>
</div>
<a class="anchor" id="ga177fc11d78c08db1f70168bf971e0059"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DLIST_IS_ENTRY_FIRST</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">list, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">entry&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((entry) == (entry)-&gt;list.next)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DList macro: is the thread the first one in the list. </p>

</div>
</div>
<a class="anchor" id="gaad48325fff9eb7b4c41788e190a28cf2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DLIST_IS_ENTRY_LAST</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">list, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">entry&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__kern__impl.html#ga177fc11d78c08db1f70168bf971e0059">DLIST_IS_ENTRY_FIRST</a>(list, entry)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DList macro: is the thread the last one in the list. </p>

</div>
</div>
<a class="anchor" id="ga77e64b5c52cb61e2bb7f6a4c6b0c9acc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DLIST_IS_ENTRY_SINGLE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">list, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">entry&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__kern__impl.html#ga177fc11d78c08db1f70168bf971e0059">DLIST_IS_ENTRY_FIRST</a>(list, entry)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DList macro: is the thread single in the list. </p>

</div>
</div>
<a class="anchor" id="gab4b1b58e436cff32fc080493dfa35619"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DLIST_ENTRY_NEXT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">list, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">entry&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(entry)-&gt;list.next</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DList macro: get the next entry. </p>

</div>
</div>
<a class="anchor" id="ga23a7667839eb576ddc4f55f2fcf77d65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DLIST_ENTRY_INIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">list, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">entry&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                                                                        \</div>
<div class="line">        (entry)-&gt;list.next = (entry);                                           \</div>
<div class="line">        (entry)-&gt;list.prev = (entry);                                           \</div>
<div class="line">    } <span class="keywordflow">while</span> (0u)</div>
</div><!-- fragment -->
<p>DList macro: initialize entry. </p>

</div>
</div>
<a class="anchor" id="gaff514b213c2cd3ad388fd5479275834f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DLIST_ENTRY_ADD_AFTER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">list, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">current, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">entry&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                                                                        \</div>
<div class="line">        (entry)-&gt;list.next = (current);                                         \</div>
<div class="line">        (entry)-&gt;list.prev = (entry)-&gt;list.next-&gt;list.prev;                     \</div>
<div class="line">        (entry)-&gt;list.next-&gt;list.prev = (entry);                                \</div>
<div class="line">        (entry)-&gt;list.prev-&gt;list.next = (entry);                                \</div>
<div class="line">    } <span class="keywordflow">while</span> (0u)</div>
</div><!-- fragment -->
<p>DList macro: add new <code>entry</code> after <code>current</code> entry. </p>

</div>
</div>
<a class="anchor" id="ga4a663d16206e95f1084af0a44e8518a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DLIST_ENTRY_RM</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">list, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">entry&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                                                                        \</div>
<div class="line">        (entry)-&gt;list.next-&gt;list.prev = (entry)-&gt;list.prev;                     \</div>
<div class="line">        (entry)-&gt;list.prev-&gt;list.next = (entry)-&gt;list.next;                     \</div>
<div class="line">    } <span class="keywordflow">while</span> (0u)</div>
</div><!-- fragment -->
<p>DList macro: remove the <code>entry</code> from a list. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaccc724ae39d88a6fcf21891c390ea845"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__template__compiler.html#ga87952d6e574c7f437503926e833ba345">PORT_C_INLINE</a> void pbmInit </td>
          <td>(</td>
          <td class="paramtype">struct pbm_ *&#160;</td>
          <td class="paramname"><em>pbm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize bitmap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pbm</td><td>Pointer to the bit map structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabd45c91981a68e1b23c765e8eb59b07b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__template__compiler.html#ga87952d6e574c7f437503926e833ba345">PORT_C_INLINE</a> void pbmSet </td>
          <td>(</td>
          <td class="paramtype">struct pbm_ *&#160;</td>
          <td class="paramname"><em>pbm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>prio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the bit corresponding to the prio argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pbm</td><td>Pointer to the bit map structure </td></tr>
    <tr><td class="paramname">prio</td><td>Priority which will be marked as used </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga53b46c788cfe6e4cc27ee6a3b6c1dfea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__template__compiler.html#ga87952d6e574c7f437503926e833ba345">PORT_C_INLINE</a> void pbmClear </td>
          <td>(</td>
          <td class="paramtype">struct pbm_ *&#160;</td>
          <td class="paramname"><em>pbm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>prio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the bit corresponding to the prio argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pbm</td><td>Pointer to the bit map structure </td></tr>
    <tr><td class="paramname">prio</td><td>Priority which will be marked as unused </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga126e2a40ac85cba9f8ce32b803cb8906"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__template__compiler.html#ga87952d6e574c7f437503926e833ba345">PORT_C_INLINE</a> uint_fast8_t pbmGetHighest </td>
          <td>(</td>
          <td class="paramtype">const struct pbm_ *&#160;</td>
          <td class="paramname"><em>pbm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the highest priority set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pbm</td><td>Pointer to the bit map structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of the highest priority marked as used </dd></dl>

</div>
</div>
<a class="anchor" id="gae681fb07746d91e97533dfcd9d7b9a9c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__template__compiler.html#ga87952d6e574c7f437503926e833ba345">PORT_C_INLINE</a> <a class="el" href="group__template__compiler.html#ga74fbee312f9185efb602f89d21b53404">bool_T</a> pbmIsEmpty </td>
          <td>(</td>
          <td class="paramtype">const struct pbm_ *&#160;</td>
          <td class="paramname"><em>pbm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is bit map empty? </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pbm</td><td>Pointer to the bit map structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status of the bit map </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>- bit map is empty </td></tr>
    <tr><td class="paramname">FALSE</td><td>- there is at least one bit set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3a8d1dd61629856ac10022cd044591a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__template__compiler.html#ga87952d6e574c7f437503926e833ba345">PORT_C_INLINE</a> void schedInit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize Ready Thread Queue structure <a class="el" href="group__kern__impl.html#gafa3f26429f0f60e0d50eb119de1c8f49">RdyQueue</a> and Kernel control structure <a class="el" href="structkernCtrl__.html">kernCtrl_</a>. </p>

</div>
</div>
<a class="anchor" id="gaa2fd7336d999c956fa8b74a2405cffc7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__template__compiler.html#ga87952d6e574c7f437503926e833ba345">PORT_C_INLINE</a> void schedStart </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the scheduler data structures for multi-threading. </p>
<p>This function is called just before multi-threading will start. </p>

</div>
</div>
<a class="anchor" id="gaaab2c30affeef2604f69bea4d19f32e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__template__compiler.html#ga87952d6e574c7f437503926e833ba345">PORT_C_INLINE</a> void schedSleep </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the scheduler to sleep. </p>
<dl class="section note"><dt>Note</dt><dd>This function is used only when <a class="el" href="group__template__kern__cfg.html#ga4e6ab4994b34501bb71e75717b093376">CFG_SCHED_POWER_SAVE</a> option is active. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0ac09697c7f2168695a853598caac057"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__template__compiler.html#ga87952d6e574c7f437503926e833ba345">PORT_C_INLINE</a> void schedWakeUpI </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wake up the scheduler. </p>
<dl class="section note"><dt>Note</dt><dd>This function is used only when <a class="el" href="group__template__kern__cfg.html#ga4e6ab4994b34501bb71e75717b093376">CFG_SCHED_POWER_SAVE</a> option is active. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1317c12a1355ee8db4f104338f1df88d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__template__compiler.html#ga87952d6e574c7f437503926e833ba345">PORT_C_INLINE</a> void schedRdyAddInitI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__kern__thd.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize scheduler ready structure during the thread add operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Pointer to the thread currently being initialized.</td></tr>
  </table>
  </dd>
</dl>
<p>Function will initialize scheduler structures during the init phase of the kernel. </p>

</div>
</div>
<a class="anchor" id="ga56290a8f51b1d3babec91602292c8d61"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__template__compiler.html#ga87952d6e574c7f437503926e833ba345">PORT_C_INLINE</a> void schedQmNextI </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch and try to schedule the next thread of the same priority as the current thread. </p>

</div>
</div>
<a class="anchor" id="gaf57b17dda8d71ce9e7ef57ea0e7ef534"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__template__compiler.html#ga87952d6e574c7f437503926e833ba345">PORT_C_INLINE</a> void schedQmI </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do the Quantum (Round-Robin) scheduling. </p>

</div>
</div>
<a class="anchor" id="gaa284b6ec458b79a49c54eedc738259fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__template__compiler.html#ga87952d6e574c7f437503926e833ba345">PORT_C_INLINE</a> void sysTmrInit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize system timer hardware. </p>

</div>
</div>
<a class="anchor" id="gaac3698a7627e9d0b7b1f0d5f741d2816"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__template__compiler.html#ga87952d6e574c7f437503926e833ba345">PORT_C_INLINE</a> void sysTmrActivate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to activate system timer. </p>
<dl class="section note"><dt>Note</dt><dd>This function is used only when <a class="el" href="group__template__kern__cfg.html#ga5f07eea2a4be92cf0358f52eba6800c9">CFG_SYSTMR_ADAPTIVE_MODE</a> option is active. </dd></dl>

</div>
</div>
<a class="anchor" id="gab564a700462dce0be7ba31f2d3022f7b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__template__compiler.html#ga87952d6e574c7f437503926e833ba345">PORT_C_INLINE</a> void sysTmrDeactivateI </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to deactivate system timer. </p>
<dl class="section note"><dt>Note</dt><dd>This function is used only when <a class="el" href="group__template__kern__cfg.html#ga5f07eea2a4be92cf0358f52eba6800c9">CFG_SYSTMR_ADAPTIVE_MODE</a> option is active. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6ebc5795dbcc15e76f768133ba99ab17"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__template__compiler.html#ga87952d6e574c7f437503926e833ba345">PORT_C_INLINE</a> void vTmrSleep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__kern__vtmr.html#ga844873888c186ee81eb66620dadb0451">esTick_T</a>&#160;</td>
          <td class="paramname"><em>ticks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set up system timer for different tick period during sleeping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ticks</td><td>Number of ticks to sleep </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is used only when <a class="el" href="group__template__kern__cfg.html#ga5f07eea2a4be92cf0358f52eba6800c9">CFG_SYSTMR_ADAPTIVE_MODE</a> option is active. </dd></dl>

</div>
</div>
<a class="anchor" id="gab4f2cc4d4d36c36efb272306595a4474"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__template__compiler.html#ga87952d6e574c7f437503926e833ba345">PORT_C_INLINE</a> void vTmrEvaluateI </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate armed virtual timers. </p>

</div>
</div>
<a class="anchor" id="ga653b749536e91933ea9b651dbb8d5962"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vTmrAddArmedS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__kern__vtmr.html#ga3c020f0ca54ff412bc1d1505502d2afc">esVTmr_T</a> *&#160;</td>
          <td class="paramname"><em>vTmr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a virtual timer into sorted list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTmr</td><td>Virtual timer: pointer to virtual timer to add </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0ac5061b01fd5124dc99cba3a10b6025"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__template__compiler.html#ga87952d6e574c7f437503926e833ba345">PORT_C_INLINE</a> void vTmrImportPendSleepI </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Import timers from pending list to armed list. </p>
<dl class="section note"><dt>Note</dt><dd>This function is used only when <a class="el" href="group__template__kern__cfg.html#ga5f07eea2a4be92cf0358f52eba6800c9">CFG_SYSTMR_ADAPTIVE_MODE</a> option is active. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9ae79f667b0f7420b31e8a609c3150a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vTmrImportPend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Import timers from pending list to armed list. </p>

</div>
</div>
<a class="anchor" id="gaa03a91aeb99719724bc64c292f1a5959"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void kVTmrInit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialization of Virtual Timer kernel thread. </p>

</div>
</div>
<a class="anchor" id="gadef1fcf2218955344b2e1d5027f80bee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void kVTmr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual Timer thread code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>Argument: thread does not use argument</td></tr>
  </table>
  </dd>
</dl>
<p>This thread is responsible for virtual timer callback invocation and to import pending timers into armed linked list. </p>

</div>
</div>
<a class="anchor" id="ga39cf986cee12aa37a066532e80a5f72a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void kIdleInit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialization of Idle thread. </p>

</div>
</div>
<a class="anchor" id="ga4e968162935156b6617ff0d5cbccbe1c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void kIdle </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Idle thread code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>Argument: thread does not use argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaae0a028e9f472994def9358f16cc40d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thdPost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__kern__thd.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post a signal to a thread which is waiting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Pointer to thread which needs to be signaled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga59935809f83133fb909c513fb72576b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thdWait </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for a signal. </p>

</div>
</div>
<a class="anchor" id="ga52b5266d709bc1ce3ca9b1838f389023"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DECL_MODULE_INFO </td>
          <td>(</td>
          <td class="paramtype">&quot;Kernel&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__kern__id.html#ga7a9484c6b09349e4eb82ba67c0989e25">ES_KERN_ID</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Nenad Radulovic&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Module identification info. </p>

</div>
</div>
<a class="anchor" id="ga9e9ff699d62d6035cd51121bb3140704"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esKernInit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize kernel internal data structures. </p>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state == ES_KERN_INACTIVE</code>, see <a class="el" href="states.html">Kernel states</a>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>1) <code>The kernel state == ES_KERN_INIT</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>1) This function may be invoked only once.</dd></dl>
<p>This function must be called first before any other kernel API. It initializes internal data structures that are used by other API functions. </p>
<dl class="section user"><dt>This service can be called from:</dt><dd><ul>
<li>Application initialization code </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Rescheduling:</dt><dd><ul>
<li>never </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Object class:</dt><dd>Regular <b>API</b> object, this object is part of the application programming interface. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0e7a0a6b9c02df58de0f98de0229a09d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PORT_C_NORETURN void esKernStart </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start the multi-threading. </p>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state == ES_KERN_INIT</code>, see <a class="el" href="states.html">Kernel states</a>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>1) <code>The kernel state == ES_KERN_RUN</code> </dd>
<dd>
2) The multi-threading execution will commence. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>1) Once this function is called the execution of threads will start and this function will never return.</dd></dl>
<p>This function will start multi-threading. Once the multi-threading has started the execution will never return to this function again (this function never returns). </p>
<dl class="section user"><dt>This service can be called from:</dt><dd><ul>
<li>Application initialization code </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Rescheduling:</dt><dd><ul>
<li>always </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Object class:</dt><dd>Regular <b>API</b> object, this object is part of the application programming interface. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3182e4c1a47897109d0a429b10a2483e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esKernSysTmr </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process the system timer event. </p>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state &lt; ES_KERN_INIT</code>, see <a class="el" href="states.html">Kernel states</a>.</dd></dl>
<p>This function will be called only by port system timer interrupt. </p>
<dl class="section user"><dt>Object class:</dt><dd><b>Not API</b> object, this object is not part of the application programming interface and it is intended for internal use only. </dd></dl>

</div>
</div>
<a class="anchor" id="gac0d578bcd4a10b2c8e5fc90f0b86ccec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esKernIsrEnterI </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enter Interrupt Service Routine. </p>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state &lt; ES_KERN_INIT</code>, see <a class="el" href="states.html">Kernel states</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>1) You must call <a class="el" href="group__kern__general.html#gaa6347925fff1684b5425dd2857c27129" title="Exit Interrupt Service Routine. ">esKernIsrExitI()</a> at the exit of ISR. </dd>
<dd>
2) You must invoke <a class="el" href="group__kern__general.html#gac0d578bcd4a10b2c8e5fc90f0b86ccec" title="Enter Interrupt Service Routine. ">esKernIsrEnterI()</a> and <a class="el" href="group__kern__general.html#gaa6347925fff1684b5425dd2857c27129" title="Exit Interrupt Service Routine. ">esKernIsrExitI()</a> in pair. In other words, for every call to <a class="el" href="group__kern__general.html#gac0d578bcd4a10b2c8e5fc90f0b86ccec" title="Enter Interrupt Service Routine. ">esKernIsrEnterI()</a> at the beginning of the ISR you must have a call to <a class="el" href="group__kern__general.html#gaa6347925fff1684b5425dd2857c27129" title="Exit Interrupt Service Routine. ">esKernIsrExitI()</a> at the end of the ISR.</dd></dl>
<p>Function will notify kernel that you are about to enter interrupt service routine (ISR). This allows kernel to keep track of interrupt nesting and then only perform rescheduling at the last nested ISR. </p>
<dl class="section user"><dt>This service can be called from:</dt><dd><ul>
<li>Interrupt service routine </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Rescheduling:</dt><dd><ul>
<li>never </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function class:</dt><dd><b>I class</b>, Interrupt-lock API function, this function can be called only from interrupts locked code sections. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa6347925fff1684b5425dd2857c27129"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esKernIsrExitI </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exit Interrupt Service Routine. </p>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state &lt; ES_KERN_INIT</code>, see <a class="el" href="states.html">Kernel states</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>1) You must invoke <a class="el" href="group__kern__general.html#gac0d578bcd4a10b2c8e5fc90f0b86ccec" title="Enter Interrupt Service Routine. ">esKernIsrEnterI()</a> and <a class="el" href="group__kern__general.html#gaa6347925fff1684b5425dd2857c27129" title="Exit Interrupt Service Routine. ">esKernIsrExitI()</a> in pair. In other words, for every call to <a class="el" href="group__kern__general.html#gac0d578bcd4a10b2c8e5fc90f0b86ccec" title="Enter Interrupt Service Routine. ">esKernIsrEnterI()</a> at the beginning of the ISR you must have a call to <a class="el" href="group__kern__general.html#gaa6347925fff1684b5425dd2857c27129" title="Exit Interrupt Service Routine. ">esKernIsrExitI()</a> at the end of the ISR. </dd>
<dd>
2) Rescheduling is prevented when the scheduler is locked (see <a class="el" href="group__kern__lock.html#ga6dd45355c20a10f7272bd39670353428" title="Lock the scheduler. ">esKernLockEnterI()</a>)</dd></dl>
<p>This function is used to notify kernel that you have completed servicing an interrupt. When the last nested ISR has completed, the function will call the scheduler to determine whether a new, high-priority task, is ready to run. </p>
<dl class="section user"><dt>This service can be called from:</dt><dd><ul>
<li>Interrupt service routine </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Rescheduling:</dt><dd><ul>
<li>possible </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function class:</dt><dd><b>I class</b>, Interrupt-lock API function, this function can be called only from interrupts locked code sections. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa3ca4a02fafcfb840442506f42175a13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esKernLockIntEnter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__kern__lock.html#gad8b2b8257c3bf42c064adb66c0d45e2e">esLockCtx_T</a> *&#160;</td>
          <td class="paramname"><em>lockCtx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enter a critical code lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lockCtx</td><td>Pointer to context variable where to store the current lock context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>This service can be called from:</dt><dd><ul>
<li>Application initialization code</li>
<li>Application thread code </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Rescheduling:</dt><dd><ul>
<li>never </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Object class:</dt><dd>Regular <b>API</b> object, this object is part of the application programming interface. </dd></dl>

</div>
</div>
<a class="anchor" id="gad8cb192a48802804cc12162edd18668d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esKernLockIntExit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__kern__lock.html#gad8b2b8257c3bf42c064adb66c0d45e2e">esLockCtx_T</a>&#160;</td>
          <td class="paramname"><em>lockCtx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exit a critical code lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lockCtx</td><td>Context variable value</td></tr>
  </table>
  </dd>
</dl>
<p>Restores the lock context to state before the <a class="el" href="group__kern__lock.html#gaa3ca4a02fafcfb840442506f42175a13" title="Enter a critical code lock. ">esKernLockIntEnter()</a> was called. </p>
<dl class="section user"><dt>This service can be called from:</dt><dd><ul>
<li>Application initialization code</li>
<li>Application thread code </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Rescheduling:</dt><dd><ul>
<li>possible </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Object class:</dt><dd>Regular <b>API</b> object, this object is part of the application programming interface. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6dd45355c20a10f7272bd39670353428"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esKernLockEnterI </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock the scheduler. </p>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state &lt; ES_KERN_INIT</code>, see <a class="el" href="states.html">Kernel states</a>. </dd></dl>
<dl class="section user"><dt>This service can be called from:</dt><dd><ul>
<li>Application thread code </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Rescheduling:</dt><dd><ul>
<li>never </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function class:</dt><dd><b>I class</b>, Interrupt-lock API function, this function can be called only from interrupts locked code sections. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3287aefb2c7dd24672c716d86a008ad3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esKernLockExitI </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock the scheduler. </p>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state &lt; ES_KERN_INIT</code>, see <a class="el" href="states.html">Kernel states</a>. </dd>
<dd>
2) <code>gKernLockCnt &gt; 0u</code>, current number of locks must be greater than zero, in other words: each call to kernel lock function must have its matching call to kernel unlock function. </dd></dl>
<dl class="section user"><dt>This service can be called from:</dt><dd><ul>
<li>Application thread code </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Rescheduling:</dt><dd><ul>
<li>possible </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function class:</dt><dd><b>I class</b>, Interrupt-lock API function, this function can be called only from interrupts locked code sections. </dd></dl>

</div>
</div>
<a class="anchor" id="ga86ec4f4cbaa889b0f23c7e2ebdcbbb97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esKernLockEnter </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock the scheduler. </p>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state &lt; ES_KERN_INIT</code>, see <a class="el" href="states.html">Kernel states</a>. </dd></dl>
<dl class="section user"><dt>This service can be called from:</dt><dd><ul>
<li>Application thread code </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Rescheduling:</dt><dd><ul>
<li>never </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Object class:</dt><dd>Regular <b>API</b> object, this object is part of the application programming interface. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf1eec663f7cc5c414b113901382ccd82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esKernLockExit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock the scheduler. </p>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state &lt; ES_KERN_INIT</code>, see <a class="el" href="states.html">Kernel states</a>. </dd>
<dd>
2) <code>gKernLockCnt &gt; 0u</code>, current number of locks must be greater than zero, in other words: each call to kernel lock function must have its matching call to kernel unlock function. </dd></dl>
<dl class="section user"><dt>This service can be called from:</dt><dd><ul>
<li>Application thread code </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Rescheduling:</dt><dd><ul>
<li>possible </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Object class:</dt><dd>Regular <b>API</b> object, this object is part of the application programming interface. </dd></dl>

</div>
</div>
<a class="anchor" id="gac91734f3ee867b519f59bf81cc7fde88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esThdInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__kern__thd.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__template__cpu__intf.html#ga13cc91970e3e05fe4210440c068d3f4a">portStck_T</a> *&#160;</td>
          <td class="paramname"><em>stck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stckSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>prio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the specified thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread: is a pointer to the thread structure, <a class="el" href="structesThd.html">esThd</a>. The structure will be used as information container for the thread. It is assumed that storage for the <code><a class="el" href="structesThd.html" title="Thread structure. ">esThd</a></code> structure is allocated by the user code. </td></tr>
    <tr><td class="paramname">fn</td><td>Function: is a pointer to thread function. Thread function must have the following signature: <code>void thread (void * arg)</code>. </td></tr>
    <tr><td class="paramname">arg</td><td>Argument: is a void pointer to an optional data area. It's usage is application defined and it is intended to pass arguments to thread when it is started for the first time. </td></tr>
    <tr><td class="paramname">stck</td><td>Stack: is a pointer to a allocated memory for thread stack. The pointer always points to the first element in the array, regardless of what type of stack the CPU is using. The thread's stack is used to store local variables, function parameters, return addresses. Each thread has its own stack and different sized stack. The stack type must be an array of <a class="el" href="structportStck.html">portStck</a>. </td></tr>
    <tr><td class="paramname">stckSize</td><td>Stack Size: specifies the size of allocated stack memory. Size is expressed in bytes. Please see port documentation about minimal stack size. Usage of C unary operator <code>sizeof</code> is the recommended way of specifying stack size. Another way of specifying required stack size is through the usage of <a class="el" href="group__kern__thd.html#gaa707debebe3f98439911212b0cc8b3d1">ES_STCK_SIZE</a> macro. </td></tr>
    <tr><td class="paramname">prio</td><td>Priority: is the priority of the thread. The higher the number, the higher the priority (the importance) of the thread. Several threads can have the same priority. Note that lowest (0) and highest (CFG_SCHED_PRIO_LVL - 1) levels are reserved for kernel threads only. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state ES_KERN_INACTIVE</code>, see <a class="el" href="states.html">Kernel states</a>. </dd>
<dd>
2) <code>thd != NULL</code> </dd>
<dd>
3) <code>thd-&gt;signature != DEF_THD_CONTRACT_SIGNATURE</code>, the thread structure can't be initialized more than once. </dd>
<dd>
4) <code>fn != NULL</code> </dd>
<dd>
5) <code>stckSize &gt;= PORT_DEF_STCK_MINSIZE</code>, see <a class="el" href="group__template__cpu__intf.html#ga5a629fee11006b5b0b97f7cb7176efd4">PORT_DEF_STCK_MINSIZE</a>. </dd>
<dd>
6) <code>0 &lt; prio &lt; CFG_SCHED_PRIO_LVL - 1</code>, see <a class="el" href="group__template__kern__cfg.html#ga56bd89fe76f7fe22f3d8805bc3c68892">CFG_SCHED_PRIO_LVL</a>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>1) <code>thd-&gt;signature == DEF_THD_CONTRACT_SIGNATURE</code>, each <a class="el" href="structesThd.html">esThd</a> structure will have valid signature after initialization.</dd></dl>
<p>Threads must be created in order for kernel to recognize them as threads. Initialize a thread by calling <a class="el" href="group__kern__thd.html#gac91734f3ee867b519f59bf81cc7fde88" title="Initialize the specified thread. ">esThdInit()</a> and provide arguments specifying to kernel how the thread will be managed. Threads are always created in the <code>ready-to-run</code> state. Threads can be created either prior to the start of multi-threading (before calling <a class="el" href="group__kern__general.html#ga0e7a0a6b9c02df58de0f98de0229a09d" title="Start the multi-threading. ">esKernStart()</a>), or by a running thread. </p>
<dl class="section user"><dt>This service can be called from:</dt><dd><ul>
<li>Application initialization code</li>
<li>Application thread code </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Rescheduling:</dt><dd><ul>
<li>possible </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Object class:</dt><dd>Regular <b>API</b> object, this object is part of the application programming interface. </dd></dl>

</div>
</div>
<a class="anchor" id="gac9d1eac76f26096614e8196bcfd8b905"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esThdTerm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__kern__thd.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Terminate the specified thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread: is a pointer to the thread structure, <a class="el" href="structesThd.html">esThd</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state ES_KERN_INACTIVE</code>, see <a class="el" href="states.html">Kernel states</a>. </dd>
<dd>
2) <code>thd != NULL</code> </dd>
<dd>
3) <code>thd-&gt;signature == DEF_THD_CONTRACT_SIGNATURE</code>, the pointer must point to a valid <a class="el" href="structesThd.html">esThd</a> structure. </dd>
<dd>
4) <code>(thd-&gt;thdL_.q == NULL) OR (thd-&gt;thdL_.q == gRdyQueue)</code>, thread must be either in Ready Threads Queue or not be in any queue (e.g. not waiting for a synchronization mechanism). </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>1) <code>thd-&gt;signature == ~DEF_THD_CONTRACT_SIGNATURE</code>, each <a class="el" href="structesThd.html">esThd</a> structure will have invalid signature after termination. </dd></dl>
<dl class="section user"><dt>This service can be called from:</dt><dd><ul>
<li>Application initialization code</li>
<li>Application thread code </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Rescheduling:</dt><dd><ul>
<li>possible </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Object class:</dt><dd>Regular <b>API</b> object, this object is part of the application programming interface. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8eaa731d0026a8a1667d4422d5031df6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esThdSetPrioI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__kern__thd.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>prio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the priority of a thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread: is pointer to the thread structure, <a class="el" href="structesThd.html">esThd</a>. </td></tr>
    <tr><td class="paramname">prio</td><td>Priority: is new priority of the thread pointed by <code>thd</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state &lt; ES_KERN_INACTIVE</code>, see <a class="el" href="states.html">Kernel states</a>. </dd>
<dd>
2) <code>thd != NULL</code> </dd>
<dd>
3) <code>thd-&gt;signature == DEF_THD_CONTRACT_SIGNATURE</code>, the pointer must point to a valid <a class="el" href="structesThd.html">esThd</a> structure. </dd>
<dd>
4) <code>0 &lt; prio &lt; CFG_SCHED_PRIO_LVL - 1</code>, see <a class="el" href="group__template__kern__cfg.html#ga56bd89fe76f7fe22f3d8805bc3c68892">CFG_SCHED_PRIO_LVL</a>. </dd></dl>
<dl class="section user"><dt>This service can be called from:</dt><dd><ul>
<li>Application initialization code</li>
<li>Application thread code</li>
<li>Interrupt service routine </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Rescheduling:</dt><dd><ul>
<li>possible </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function class:</dt><dd><b>I class</b>, Interrupt-lock API function, this function can be called only from interrupts locked code sections. </dd></dl>

</div>
</div>
<a class="anchor" id="gaddd5fe0557c91559b9452beb0fc236fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esThdQInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__kern__thdq.html#ga7a1a060699e83a01512ebb5540019556">esThdQ_T</a> *&#160;</td>
          <td class="paramname"><em>thdQ</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize Thread Queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thdQ</td><td>Thread Queue: is a pointer to thread queue structure, <a class="el" href="structesThdQ.html">esThdQ</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>thdQ != NULL</code> </dd>
<dd>
2) <code>thdQ-&gt;signature != DEF_THDQ_CONTRACT_SIGNATURE</code>, the thread queue structure can't be initialized more than once. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>1) <code>thdQ-&gt;signature == DEF_THDQ_CONTRACT_SIGNATURE</code>, each <a class="el" href="structesThdQ.html">esThdQ</a> structure will have valid signature after initialization. </dd></dl>
<dl class="section user"><dt>This service can be called from:</dt><dd><ul>
<li>Application initialization code</li>
<li>Application thread code</li>
<li>Interrupt service routine </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Rescheduling:</dt><dd><ul>
<li>never </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Object class:</dt><dd>Regular <b>API</b> object, this object is part of the application programming interface. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa5f19b32a7f0c42616b5270dcbd73a3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esThdQTerm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__kern__thdq.html#ga7a1a060699e83a01512ebb5540019556">esThdQ_T</a> *&#160;</td>
          <td class="paramname"><em>thdQ</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Terminate Thread Queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thdQ</td><td>Thread Queue: is a pointer to thread queue structure, <a class="el" href="structesThdQ.html">esThdQ</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>thdQ != NULL</code> </dd>
<dd>
2) <code>thdQ-&gt;signature == DEF_THDQ_CONTRACT_SIGNATURE</code>, the thread queue structure must be already initialized. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>1) <code>thdQ-&gt;signature == ~DEF_THDQ_CONTRACT_SIGNATURE</code>, each <a class="el" href="structesThdQ.html">esThdQ</a> structure will have invalid signature after termination. </dd></dl>
<dl class="section user"><dt>This service can be called from:</dt><dd><ul>
<li>Application initialization code</li>
<li>Application thread code</li>
<li>Interrupt service routine </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Rescheduling:</dt><dd><ul>
<li>never </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Object class:</dt><dd>Regular <b>API</b> object, this object is part of the application programming interface. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9da1e71c137d8adb8c9bdead7052b5fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esThdQAddI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__kern__thdq.html#ga7a1a060699e83a01512ebb5540019556">esThdQ_T</a> *&#160;</td>
          <td class="paramname"><em>thdQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__kern__thd.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *&#160;</td>
          <td class="paramname"><em>thd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a thread to the Thread Queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thdQ</td><td>Thread Queue: is a pointer to thread queue structure, <a class="el" href="structesThdQ.html">esThdQ</a>. </td></tr>
    <tr><td class="paramname">thd</td><td>Thread: is a pointer to the thread ID structure, <a class="el" href="structesThd.html">esThd</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>thdQ != NULL</code> </dd>
<dd>
2) <code>thdQ-&gt;signature == DEF_THDQ_CONTRACT_SIGNATURE</code>, the pointer must point to a valid <a class="el" href="structesThdQ.html">esThdQ</a> structure. </dd>
<dd>
3) <code>thd != NULL</code> </dd>
<dd>
4) <code>thd-&gt;signature == DEF_THD_CONTRACT_SIGNATURE</code>, the pointer must point to a valid <a class="el" href="structesThd.html">esThd</a> structure. </dd>
<dd>
5) <code>thd-&gt;thdL_.q == NULL</code>, thread must not be in any queue.</dd></dl>
<p>This function adds a thread at the specified Thread Queue. </p>
<dl class="section user"><dt>This service can be called from:</dt><dd><ul>
<li>Application initialization code</li>
<li>Application thread code</li>
<li>Interrupt service routine </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Rescheduling:</dt><dd><ul>
<li>never </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function class:</dt><dd><b>I class</b>, Interrupt-lock API function, this function can be called only from interrupts locked code sections. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa18afa95e34035da03c5cb7ea3a96320"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esThdQRmI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__kern__thdq.html#ga7a1a060699e83a01512ebb5540019556">esThdQ_T</a> *&#160;</td>
          <td class="paramname"><em>thdQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__kern__thd.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *&#160;</td>
          <td class="paramname"><em>thd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the thread from the Thread Queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thdQ</td><td>Thread Queue: is a pointer to thread queue structure, <a class="el" href="structesThdQ.html">esThdQ</a>. </td></tr>
    <tr><td class="paramname">thd</td><td>Thread: is a pointer to the thread ID structure, <a class="el" href="structesThd.html">esThd</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>thd != NULL</code> </dd>
<dd>
2) <code>thd-&gt;signature == DEF_THD_CONTRACT_SIGNATURE</code>, the pointer must point to a valid <a class="el" href="structesThd.html">esThd</a> structure. </dd>
<dd>
3) <code>thdQ != NULL</code> </dd>
<dd>
4) <code>thdQ-&gt;signature == DEF_THDQ_CONTRACT_SIGNATURE</code>, the pointer must point to a valid <a class="el" href="structesThdQ.html">esThdQ</a> structure. </dd>
<dd>
5) <code>thd-&gt;thdL_.q == thdQ</code>, thread must be in the <code>thdQ</code> queue. </dd></dl>
<dl class="section user"><dt>This service can be called from:</dt><dd><ul>
<li>Application initialization code</li>
<li>Application thread code</li>
<li>Interrupt service routine </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Rescheduling:</dt><dd><ul>
<li>never </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function class:</dt><dd><b>I class</b>, Interrupt-lock API function, this function can be called only from interrupts locked code sections. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1670c123f31c346b24ec9d2b7ae35f88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__kern__thd.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a>* esThdQFetchI </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__kern__thdq.html#ga7a1a060699e83a01512ebb5540019556">esThdQ_T</a> *&#160;</td>
          <td class="paramname"><em>thdQ</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the first high priority thread from the Thread Queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thdQ</td><td>Thread Queue: is a pointer to thread queue structure, <a class="el" href="structesThdQ.html">esThdQ</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the thread ID structure with the highest priority. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>thdQ != NULL</code> </dd>
<dd>
2) <code>thdQ-&gt;signature == DEF_THDQ_CONTRACT_SIGNATURE</code>, the pointer must point to a valid <a class="el" href="structesThdQ.html">esThdQ</a> structure. </dd>
<dd>
3) <code>pbm_ != 0</code>, priority bit map must not be empty </dd></dl>
<dl class="section user"><dt>This service can be called from:</dt><dd><ul>
<li>Application initialization code</li>
<li>Application thread code</li>
<li>Interrupt service routine </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Rescheduling:</dt><dd><ul>
<li>never </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function class:</dt><dd><b>I class</b>, Interrupt-lock API function, this function can be called only from interrupts locked code sections. </dd></dl>

</div>
</div>
<a class="anchor" id="gae365b14292f1496a90d876baec84fb4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__kern__thd.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a>* esThdQFetchRotateI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__kern__thdq.html#ga7a1a060699e83a01512ebb5540019556">esThdQ_T</a> *&#160;</td>
          <td class="paramname"><em>thdQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>prio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the next thread and rotate thread linked list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thdQ</td><td>Thread Queue: is a pointer to thread queue structure, <a class="el" href="structesThdQ.html">esThdQ</a>. This is the thread queue to fetch from. </td></tr>
    <tr><td class="paramname">prio</td><td>Priority: is the priority level to fetch and rotate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the next thread in queue. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>thdQ != NULL</code> </dd>
<dd>
2) <code>thdQ-&gt;signature == DEF_THDQ_CONTRACT_SIGNATURE</code>, the pointer must point to a valid <a class="el" href="structesThdQ.html">esThdQ</a> structure. </dd>
<dd>
3) <code>0 &lt;= prio &lt;= CFG_SCHED_PRIO_LVL</code>, see <a class="el" href="group__template__kern__cfg.html#ga56bd89fe76f7fe22f3d8805bc3c68892">CFG_SCHED_PRIO_LVL</a>. </dd>
<dd>
4) <code>sentinel != NULL</code>, at least one thread must be in the selected priority level </dd></dl>
<dl class="section user"><dt>This service can be called from:</dt><dd><ul>
<li>Application initialization code</li>
<li>Application thread code</li>
<li>Interrupt service routine </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Rescheduling:</dt><dd><ul>
<li>never </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function class:</dt><dd><b>I class</b>, Interrupt-lock API function, this function can be called only from interrupts locked code sections. </dd></dl>

</div>
</div>
<a class="anchor" id="gacf2687b82ce64e2154d97fd3b69a4ab5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__template__compiler.html#ga74fbee312f9185efb602f89d21b53404">bool_T</a> esThdQIsEmpty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__kern__thdq.html#ga7a1a060699e83a01512ebb5540019556">esThdQ_T</a> *&#160;</td>
          <td class="paramname"><em>thdQ</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is thread queue empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thdQ</td><td>Thread Queue: is a pointer to thread queue structure, <a class="el" href="structesThdQ.html">esThdQ</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The state of thread queue </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>- thread queue is empty </td></tr>
    <tr><td class="paramname">FALSE</td><td>- thread queue is not empty </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>thdQ != NULL</code> </dd>
<dd>
2) <code>thdQ-&gt;signature == DEF_THDQ_CONTRACT_SIGNATURE</code>, the pointer must point to a valid <a class="el" href="structesThdQ.html">esThdQ</a> structure. </dd></dl>
<dl class="section user"><dt>This service can be called from:</dt><dd><ul>
<li>Application initialization code</li>
<li>Application thread code</li>
<li>Interrupt service routine </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Rescheduling:</dt><dd><ul>
<li>never </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Object class:</dt><dd>Regular <b>API</b> object, this object is part of the application programming interface. </dd></dl>

</div>
</div>
<a class="anchor" id="ga73e14b1860ce824c822adc407aee0977"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esSchedRdyAddI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__kern__thd.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add thread <code>thd</code> to the ready thread list and notify the scheduler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Pointer to the initialized thread ID structure, <a class="el" href="structesThd.html">esThd</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state &lt; ES_KERN_INACTIVE</code>, see <a class="el" href="states.html">Kernel states</a>. </dd>
<dd>
2) <code>thd != NULL</code> </dd>
<dd>
3) <code>thd-&gt;signature == DEF_THD_CONTRACT_SIGNATURE</code>, the pointer must point to a valid <a class="el" href="structesThd.html">esThd</a> structure. </dd>
<dd>
4) <code>thd-&gt;thdL_.q == NULL</code>, thread must not be in a queue. </dd></dl>
<dl class="section user"><dt>This service can be called from:</dt><dd><ul>
<li>Application initialization code</li>
<li>Application thread code</li>
<li>Interrupt service routine </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Rescheduling:</dt><dd><ul>
<li>never </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function class:</dt><dd><b>I class</b>, Interrupt-lock API function, this function can be called only from interrupts locked code sections. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0b8263c5024ebb59cd9b95cc9253b44d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esSchedRdyRmI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__kern__thd.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove thread <code>thd</code> from the ready thread list and notify the scheduler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Pointer to the initialized thread ID structure, <a class="el" href="structesThd.html">esThd</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state &lt; ES_KERN_INACTIVE</code>, see <a class="el" href="states.html">Kernel states</a>. </dd>
<dd>
2) <code>thd != NULL</code> </dd>
<dd>
3) <code>thd-&gt;signature == DEF_THD_CONTRACT_SIGNATURE</code>, the pointer must point to a valid <a class="el" href="structesThd.html">esThd</a> structure. </dd>
<dd>
4) <code>thd-&gt;thdL_.q == &amp;gRdyQueue</code>, thread must be in Ready Threads queue. </dd></dl>
<dl class="section user"><dt>This service can be called from:</dt><dd><ul>
<li>Application initialization code</li>
<li>Application thread code</li>
<li>Interrupt service routine </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Rescheduling:</dt><dd><ul>
<li>never </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function class:</dt><dd><b>I class</b>, Interrupt-lock API function, this function can be called only from interrupts locked code sections. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf90e487bfce974dafaeed5009e189810"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esSchedYieldI </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force the scheduler invocation which will evaluate all ready threads and switch to ready thread with the highest priority. </p>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state &lt; ES_KERN_INACTIVE</code>, see <a class="el" href="states.html">Kernel states</a>. </dd></dl>
<dl class="section user"><dt>This service can be called from:</dt><dd><ul>
<li>Application thread code </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Rescheduling:</dt><dd><ul>
<li>possible </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function class:</dt><dd><b>I class</b>, Interrupt-lock API function, this function can be called only from interrupts locked code sections. </dd></dl>

</div>
</div>
<a class="anchor" id="gafbea29b376b29f11bbfc48a0f5144e9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esSchedYieldIsrI </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force the scheduler invocation which will evaluate all ready threads and switch to ready thread with the highest priority. </p>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state &lt; ES_KERN_INACTIVE</code>, see <a class="el" href="states.html">Kernel states</a>. </dd></dl>
<dl class="section user"><dt>This service can be called from:</dt><dd><ul>
<li>Interrupt service routine </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Rescheduling:</dt><dd><ul>
<li>possible </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function class:</dt><dd><b>I class</b>, Interrupt-lock API function, this function can be called only from interrupts locked code sections. </dd></dl>

</div>
</div>
<a class="anchor" id="ga45fe650eac73e7fe203cc81565401555"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esVTmrInitI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__kern__vtmr.html#ga3c020f0ca54ff412bc1d1505502d2afc">esVTmr_T</a> *&#160;</td>
          <td class="paramname"><em>vTmr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__kern__vtmr.html#ga844873888c186ee81eb66620dadb0451">esTick_T</a>&#160;</td>
          <td class="paramname"><em>tick</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add and start a new virtual timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTmr</td><td>Virtual Timer: is pointer to the timer ID structure, <a class="el" href="structesVTmr.html">esVTmr</a>. </td></tr>
    <tr><td class="paramname">tick</td><td>Tick: the timer delay expressed in system ticks </td></tr>
    <tr><td class="paramname">fn</td><td>Function: is pointer to the callback function </td></tr>
    <tr><td class="paramname">arg</td><td>Argument: is pointer to the arguments of callback function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state &lt; ES_KERN_INACTIVE</code>, see <a class="el" href="states.html">Kernel states</a>. </dd>
<dd>
2) <code>vTmr != NULL</code> </dd>
<dd>
3) <code>vTmr-&gt;signature != DEF_VTMR_CONTRACT_SIGNATURE</code>, the timer structure can't be initialized more than once. </dd>
<dd>
4) <code>tick &gt; 1U</code> </dd>
<dd>
5) <code>fn != NULL</code> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>1) <code>vTmr-&gt;signature == DEF_VTMR_CONTRACT_SIGNATURE</code>, each <a class="el" href="structesVTmr.html">esVTmr</a> structure will have valid signature after initialization. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The callback function is invoked from interrupt context. </dd></dl>
<dl class="section user"><dt>This service can be called from:</dt><dd><ul>
<li>Application initialization code</li>
<li>Application thread code</li>
<li>Interrupt service routine </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Rescheduling:</dt><dd><ul>
<li>never </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function class:</dt><dd><b>I class</b>, Interrupt-lock API function, this function can be called only from interrupts locked code sections. </dd></dl>

</div>
</div>
<a class="anchor" id="gad932cf00aec4ba03a0df02ccc493c4c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esVTmrInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__kern__vtmr.html#ga3c020f0ca54ff412bc1d1505502d2afc">esVTmr_T</a> *&#160;</td>
          <td class="paramname"><em>vTmr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__kern__vtmr.html#ga844873888c186ee81eb66620dadb0451">esTick_T</a>&#160;</td>
          <td class="paramname"><em>tick</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add and start a new virtual timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTmr</td><td>Virtual Timer: is pointer to the timer ID structure, <a class="el" href="structesVTmr.html">esVTmr</a>. </td></tr>
    <tr><td class="paramname">tick</td><td>Tick: the timer delay expressed in system ticks </td></tr>
    <tr><td class="paramname">fn</td><td>Function: is pointer to the callback function </td></tr>
    <tr><td class="paramname">arg</td><td>Argument: is pointer to the arguments of callback function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state &lt; ES_KERN_INACTIVE</code>, see <a class="el" href="states.html">Kernel states</a>. </dd>
<dd>
2) <code>vTmr != NULL</code> </dd>
<dd>
3) <code>vTmr-&gt;signature != DEF_VTMR_CONTRACT_SIGNATURE</code>, the timer structure can't be initialized more than once. </dd>
<dd>
4) <code>tick &gt; 1U</code> </dd>
<dd>
5) <code>fn != NULL</code> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>1) <code>vTmr-&gt;signature == DEF_VTMR_CONTRACT_SIGNATURE</code>, each <a class="el" href="structesVTmr.html">esVTmr</a> structure will have valid signature after initialization. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The callback function is invoked from interrupt context. </dd></dl>
<dl class="section user"><dt>This service can be called from:</dt><dd><ul>
<li>Application initialization code</li>
<li>Application thread code</li>
<li>Interrupt service routine </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Rescheduling:</dt><dd><ul>
<li>never </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Object class:</dt><dd>Regular <b>API</b> object, this object is part of the application programming interface. </dd></dl>

</div>
</div>
<a class="anchor" id="ga96bb2c81f649c0305dfd08d1c79b2e37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esVTmrTermI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__kern__vtmr.html#ga3c020f0ca54ff412bc1d1505502d2afc">esVTmr_T</a> *&#160;</td>
          <td class="paramname"><em>vTmr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel and remove a virtual timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTmr</td><td>Timer: is pointer to the timer ID structure, <a class="el" href="structesVTmr.html">esVTmr</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state &lt; ES_KERN_INACTIVE</code>, see <a class="el" href="states.html">Kernel states</a>. </dd>
<dd>
2) <code>vTmr != NULL</code> </dd>
<dd>
3) <code>vTmr-&gt;signature == DEF_VTMR_CONTRACT_SIGNATURE</code>, the pointer must point to a valid <a class="el" href="structesVTmr.html">esVTmr</a> structure. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>1) <code>vTmr-&gt;signature = ~DEF_VTMR_CONTRACT_SIGNATURE</code>, each <a class="el" href="structesVTmr.html">esVTmr</a> structure will have invalid signature after termination. </dd></dl>
<dl class="section user"><dt>This service can be called from:</dt><dd><ul>
<li>Application initialization code</li>
<li>Application thread code</li>
<li>Interrupt service routine </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Rescheduling:</dt><dd><ul>
<li>never </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function class:</dt><dd><b>I class</b>, Interrupt-lock API function, this function can be called only from interrupts locked code sections. </dd></dl>

</div>
</div>
<a class="anchor" id="gad6ec93a68e3526f18ed926cd441878cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esVTmrTerm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__kern__vtmr.html#ga3c020f0ca54ff412bc1d1505502d2afc">esVTmr_T</a> *&#160;</td>
          <td class="paramname"><em>vTmr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel and remove a virtual timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTmr</td><td>Timer: is pointer to the timer ID structure, <a class="el" href="structesVTmr.html">esVTmr</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state &lt; ES_KERN_INACTIVE</code>, see <a class="el" href="states.html">Kernel states</a>. </dd>
<dd>
2) <code>vTmr != NULL</code> </dd>
<dd>
3) <code>vTmr-&gt;signature == DEF_VTMR_CONTRACT_SIGNATURE</code>, the pointer must point to a valid <a class="el" href="structesVTmr.html">esVTmr</a> structure. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>1) <code>vTmr-&gt;signature = ~DEF_VTMR_CONTRACT_SIGNATURE</code>, each <a class="el" href="structesVTmr.html">esVTmr</a> structure will have invalid signature after termination. </dd></dl>
<dl class="section user"><dt>This service can be called from:</dt><dd><ul>
<li>Application initialization code</li>
<li>Application thread code</li>
<li>Interrupt service routine </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Rescheduling:</dt><dd><ul>
<li>never </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Object class:</dt><dd>Regular <b>API</b> object, this object is part of the application programming interface. </dd></dl>

</div>
</div>
<a class="anchor" id="ga26d10c6aaa0cd1d04261d2c9911e890d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esVTmrDelay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__kern__vtmr.html#ga844873888c186ee81eb66620dadb0451">esTick_T</a>&#160;</td>
          <td class="paramname"><em>tick</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delay for specified amount of ticks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tick</td><td>Tick: number of system ticks to delay.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will create a virtual timer with count down time specified in argument <code>tick</code> and put the calling thread into <code>sleep</code> state. When timeout expires the thread will be placed back into <code>ready</code> state. </p>
<dl class="section note"><dt>Note</dt><dd>The sleeping thread can not be safely awaken until the specified time does not expire. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>tick &gt; 1u</code> </dd></dl>
<dl class="section user"><dt>This service can be called from:</dt><dd><ul>
<li>Application initialization code</li>
<li>Application thread code</li>
<li>Interrupt service routine </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Rescheduling:</dt><dd><ul>
<li>always </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Object class:</dt><dd>Regular <b>API</b> object, this object is part of the application programming interface. </dd></dl>

</div>
</div>
<a class="anchor" id="gacb0d88d6a7e467dc37a6a9a85945aaa6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__kern__vtmr.html#ga844873888c186ee81eb66620dadb0451">esTick_T</a> esSysTmrTickGet </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current tick value. </p>
<dl class="section return"><dt>Returns</dt><dd>Current tick value </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state &lt; ES_KERN_INACTIVE</code>, see <a class="el" href="states.html">Kernel states</a>. </dd></dl>
<dl class="section user"><dt>This service can be called from:</dt><dd><ul>
<li>Application initialization code</li>
<li>Application thread code</li>
<li>Interrupt service routine </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Rescheduling:</dt><dd><ul>
<li>never </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Object class:</dt><dd>Regular <b>API</b> object, this object is part of the application programming interface. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="gafa3f26429f0f60e0d50eb119de1c8f49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structesThdQ.html">esThdQ</a> RdyQueue</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ready Thread queue. </p>

</div>
</div>
<a class="anchor" id="gaf4fd8bfc453bbab3d94186c863a180c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structsysTmr.html">sysTmr</a> SysTmr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    0u,</div>
<div class="line">    0u,</div>
<div class="line">    0u,</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">}</div>
</div><!-- fragment -->
<p>Main System Timer structure. </p>

</div>
</div>
<a class="anchor" id="ga49813e0a9a014d99d076943e96b2408c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structesVTmr.html">esVTmr</a> VTmrArmed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">   {</div>
<div class="line">        &amp;<a class="code" href="group__kern__impl.html#ga49813e0a9a014d99d076943e96b2408c">VTmrArmed</a>,</div>
<div class="line">        &amp;<a class="code" href="group__kern__impl.html#ga49813e0a9a014d99d076943e96b2408c">VTmrArmed</a>,</div>
<div class="line">        &amp;VTmrArmed</div>
<div class="line">   },</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">   UINT_FAST8_MAX,</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">   NULL,</div>
<div class="line">   NULL,</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">}</div>
<div class="ttc" id="group__kern__impl_html_ga49813e0a9a014d99d076943e96b2408c"><div class="ttname"><a href="group__kern__impl.html#ga49813e0a9a014d99d076943e96b2408c">VTmrArmed</a></div><div class="ttdeci">static struct esVTmr VTmrArmed</div><div class="ttdoc">List of virtual armed timers waiting to expire. </div><div class="ttdef"><b>Definition:</b> kernel.c:388</div></div>
</div><!-- fragment -->
<p>List of virtual armed timers waiting to expire. </p>

</div>
</div>
<a class="anchor" id="gac27c4e18276b392295b973fc00f31765"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structesVTmr.html">esVTmr</a> VTmrPend</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">   {</div>
<div class="line">        &amp;<a class="code" href="group__kern__impl.html#gac27c4e18276b392295b973fc00f31765">VTmrPend</a>,</div>
<div class="line">        &amp;<a class="code" href="group__kern__impl.html#gac27c4e18276b392295b973fc00f31765">VTmrPend</a>,</div>
<div class="line">        &amp;VTmrPend</div>
<div class="line">   },</div>
<div class="line">   0u,</div>
<div class="line">   NULL,</div>
<div class="line">   NULL,</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">}</div>
<div class="ttc" id="group__kern__impl_html_gac27c4e18276b392295b973fc00f31765"><div class="ttname"><a href="group__kern__impl.html#gac27c4e18276b392295b973fc00f31765">VTmrPend</a></div><div class="ttdeci">static struct esVTmr VTmrPend</div><div class="ttdoc">Virtual timers pending to be inserted into waiting list. </div><div class="ttdef"><b>Definition:</b> kernel.c:411</div></div>
</div><!-- fragment -->
<p>Virtual timers pending to be inserted into waiting list. </p>

</div>
</div>
<a class="anchor" id="gaab82048477ffd940e6eff13d4280eb72"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structesThd.html">esThd</a> KVTmr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual timer thread ID. </p>

</div>
</div>
<a class="anchor" id="ga639ded61b40c01f4a1f54814c4b94513"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structesThd.html">esThd</a> KIdle</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Idle thread ID. </p>

</div>
</div>
<a class="anchor" id="gad8535f99414ea3e0e37a91fd6600246e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint_fast8_t KernLockCnt</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Kernel Lock Counter. </p>

</div>
</div>
<a class="anchor" id="ga93a7ee7768ffd94201bf1795a543194b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structkernCtrl__.html">kernCtrl_</a> KernCtrl</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    NULL,                                                                       </div>
<div class="line">    NULL,                                                                       </div>
<div class="line">    <a class="code" href="group__kern__ctrl.html#ggac9be6bfeddbd6af148cdb3867fbc24afa089165cac55f315953335f5ffe41b7c4">ES_KERN_INACTIVE</a>                                                            </div>
<div class="line">}</div>
<div class="ttc" id="group__kern__ctrl_html_ggac9be6bfeddbd6af148cdb3867fbc24afa089165cac55f315953335f5ffe41b7c4"><div class="ttname"><a href="group__kern__ctrl.html#ggac9be6bfeddbd6af148cdb3867fbc24afa089165cac55f315953335f5ffe41b7c4">ES_KERN_INACTIVE</a></div><div class="ttdef"><b>Definition:</b> kernel.h:237</div></div>
</div><!-- fragment -->
<p>Kernel control initialization. </p>
<p>Kernel control block. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
