<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>eSolid - Real-Time Kernel: Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="eSolid-logo_small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">eSolid - Real-Time Kernel
   &#160;<span id="projectnumber">1.0BetaR01</span>
   </div>
   <div id="projectbrief">Event Based System</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="/"><span>Home&#160;page</span></a></li>
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a>  </div>
  <div class="headertitle">
<div class="title">Interface<div class="ingroups"><a class="el" href="group__kernel.html">Kernel</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Application programming interface.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Interface:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__kern__intf.png" border="0" alt="" usemap="#group____kern____intf"/>
<map name="group____kern____intf" id="group____kern____intf">
<area shape="rect" id="node1" href="group__kernel.html" title="Overview. " alt="" coords="5,5,64,32"/></map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structesThd.html">esThd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread structure.  <a href="structesThd.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structesVTmr.html">esVTmr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual Timer structure.  <a href="structesVTmr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structesThdQ.html">esThdQ</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread Queue structure.  <a href="structesThdQ.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structesKernCtrl.html">esKernCtrl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel control block structure.  <a href="structesKernCtrl.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Kernel identification and version number</h2></td></tr>
<tr class="memitem:gacde22f7336a3c1c032dfc0ee3b94f506"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#gacde22f7336a3c1c032dfc0ee3b94f506">ES_KERN_VER</a>&#160;&#160;&#160;0x10000ul</td></tr>
<tr class="memdesc:gacde22f7336a3c1c032dfc0ee3b94f506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies the underlying kernel version number.  <a href="#gacde22f7336a3c1c032dfc0ee3b94f506">More...</a><br/></td></tr>
<tr class="separator:gacde22f7336a3c1c032dfc0ee3b94f506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a9484c6b09349e4eb82ba67c0989e25"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#ga7a9484c6b09349e4eb82ba67c0989e25">ES_KERN_ID</a>&#160;&#160;&#160;&quot;eSolid Kernel v1.0&quot;</td></tr>
<tr class="memdesc:ga7a9484c6b09349e4eb82ba67c0989e25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel identification string.  <a href="#ga7a9484c6b09349e4eb82ba67c0989e25">More...</a><br/></td></tr>
<tr class="separator:ga7a9484c6b09349e4eb82ba67c0989e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Critical section management</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp43784aebc31664bf2b83e85766997ec9"></a>These macros are used to prevent interrupts on entry into the critical section, and restoring interrupts to their previous state on exit from critical section.</p>
<p>For more details see <a class="el" href="critical_section.html">Critical sections</a>. </p>
</td></tr>
<tr class="memitem:ga0420d9c03ac590d6e3e46fd17f6a739e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#ga0420d9c03ac590d6e3e46fd17f6a739e">ES_CRITICAL_T</a>&#160;&#160;&#160;PORT_CRITICAL_T</td></tr>
<tr class="memdesc:ga0420d9c03ac590d6e3e46fd17f6a739e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Critical section context variable type.  <a href="#ga0420d9c03ac590d6e3e46fd17f6a739e">More...</a><br/></td></tr>
<tr class="separator:ga0420d9c03ac590d6e3e46fd17f6a739e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90ec47263e8a05b91fe9359c97eb1c9c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#ga90ec47263e8a05b91fe9359c97eb1c9c">ES_CRITICAL_ENTER</a>(ctx)&#160;&#160;&#160;<a class="el" href="group__template__cpu__intf.html#gad230b116bf8bc513e64c533d4e946054">PORT_CRITICAL_ENTER</a>(ctx)</td></tr>
<tr class="memdesc:ga90ec47263e8a05b91fe9359c97eb1c9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enter a critical section.  <a href="#ga90ec47263e8a05b91fe9359c97eb1c9c">More...</a><br/></td></tr>
<tr class="separator:ga90ec47263e8a05b91fe9359c97eb1c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade4fcc55ee1325723ed798a8c5e11e56"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#gade4fcc55ee1325723ed798a8c5e11e56">ES_CRITICAL_EXIT</a>(ctx)&#160;&#160;&#160;<a class="el" href="group__template__cpu__intf.html#ga95082ec189f12ed8e39efbda811dea77">PORT_CRITICAL_EXIT</a>(ctx)</td></tr>
<tr class="memdesc:gade4fcc55ee1325723ed798a8c5e11e56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit from critical section.  <a href="#gade4fcc55ee1325723ed798a8c5e11e56">More...</a><br/></td></tr>
<tr class="separator:gade4fcc55ee1325723ed798a8c5e11e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf1dc7063de829a77484e4c9e1e942a5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#gacf1dc7063de829a77484e4c9e1e942a5">ES_CRITICAL_ENTER_LOCK_EXIT</a>()</td></tr>
<tr class="memdesc:gacf1dc7063de829a77484e4c9e1e942a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enter critical section and exit scheduler lock.  <a href="#gacf1dc7063de829a77484e4c9e1e942a5">More...</a><br/></td></tr>
<tr class="separator:gacf1dc7063de829a77484e4c9e1e942a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4466c8aea583e299815926cd4d262a2c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#ga4466c8aea583e299815926cd4d262a2c">ES_CRITICAL_EXIT_LOCK_ENTER</a>()</td></tr>
<tr class="memdesc:ga4466c8aea583e299815926cd4d262a2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit critical section and enter scheduler lock.  <a href="#ga4466c8aea583e299815926cd4d262a2c">More...</a><br/></td></tr>
<tr class="separator:ga4466c8aea583e299815926cd4d262a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Thread management</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp46313fcfd6f520b7cdcbf505c023e3a2"></a>Basic thread management services</p>
<p>For more details see <a class="el" href="threads.html">Thread Management</a>. </p>
</td></tr>
<tr class="memitem:ga62e3a3ca0a4597a19c43cb8868810d82"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structesThd.html">esThd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a></td></tr>
<tr class="memdesc:ga62e3a3ca0a4597a19c43cb8868810d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread type.  <a href="#ga62e3a3ca0a4597a19c43cb8868810d82">More...</a><br/></td></tr>
<tr class="separator:ga62e3a3ca0a4597a19c43cb8868810d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24160ddd0cb0327108cc652bfe6a49e5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__template__cpu__intf.html#ga13cc91970e3e05fe4210440c068d3f4a">portStck_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#ga24160ddd0cb0327108cc652bfe6a49e5">esStck_T</a></td></tr>
<tr class="memdesc:ga24160ddd0cb0327108cc652bfe6a49e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack type.  <a href="#ga24160ddd0cb0327108cc652bfe6a49e5">More...</a><br/></td></tr>
<tr class="separator:ga24160ddd0cb0327108cc652bfe6a49e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac91734f3ee867b519f59bf81cc7fde88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#gac91734f3ee867b519f59bf81cc7fde88">esThdInit</a> (<a class="el" href="group__kern__intf.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *thd, void(*fn)(void *), void *arg, <a class="el" href="group__template__cpu__intf.html#ga13cc91970e3e05fe4210440c068d3f4a">portStck_T</a> *stck, size_t stckSize, uint8_t prio)</td></tr>
<tr class="memdesc:gac91734f3ee867b519f59bf81cc7fde88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the specified thread.  <a href="#gac91734f3ee867b519f59bf81cc7fde88">More...</a><br/></td></tr>
<tr class="separator:gac91734f3ee867b519f59bf81cc7fde88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9d1eac76f26096614e8196bcfd8b905"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#gac9d1eac76f26096614e8196bcfd8b905">esThdTerm</a> (<a class="el" href="group__kern__intf.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *thd)</td></tr>
<tr class="memdesc:gac9d1eac76f26096614e8196bcfd8b905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminate the specified thread.  <a href="#gac9d1eac76f26096614e8196bcfd8b905">More...</a><br/></td></tr>
<tr class="separator:gac9d1eac76f26096614e8196bcfd8b905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2a2c5fe0128d446a64512b0714bfb6d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__template__compiler.html#ga87952d6e574c7f437503926e833ba345">PORT_C_INLINE</a> <a class="el" href="group__kern__intf.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#gae2a2c5fe0128d446a64512b0714bfb6d">esThdGetId</a> (void)</td></tr>
<tr class="memdesc:gae2a2c5fe0128d446a64512b0714bfb6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current thread ID.  <a href="#gae2a2c5fe0128d446a64512b0714bfb6d">More...</a><br/></td></tr>
<tr class="separator:gae2a2c5fe0128d446a64512b0714bfb6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d2d033dc7e1226eccf4a51c666678ad"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__template__compiler.html#ga87952d6e574c7f437503926e833ba345">PORT_C_INLINE</a> uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#ga6d2d033dc7e1226eccf4a51c666678ad">esThdGetPrio</a> (<a class="el" href="group__kern__intf.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *thd)</td></tr>
<tr class="memdesc:ga6d2d033dc7e1226eccf4a51c666678ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the priority of a thread.  <a href="#ga6d2d033dc7e1226eccf4a51c666678ad">More...</a><br/></td></tr>
<tr class="separator:ga6d2d033dc7e1226eccf4a51c666678ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8eaa731d0026a8a1667d4422d5031df6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#ga8eaa731d0026a8a1667d4422d5031df6">esThdSetPrioI</a> (<a class="el" href="group__kern__intf.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *thd, uint8_t prio)</td></tr>
<tr class="memdesc:ga8eaa731d0026a8a1667d4422d5031df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the priority of a thread.  <a href="#ga8eaa731d0026a8a1667d4422d5031df6">More...</a><br/></td></tr>
<tr class="separator:ga8eaa731d0026a8a1667d4422d5031df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c846f96eb842774a35fb1f8f720a229"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#ga1c846f96eb842774a35fb1f8f720a229">esThdPostI</a> (<a class="el" href="group__kern__intf.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *thd)</td></tr>
<tr class="memdesc:ga1c846f96eb842774a35fb1f8f720a229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post to thread semaphore.  <a href="#ga1c846f96eb842774a35fb1f8f720a229">More...</a><br/></td></tr>
<tr class="separator:ga1c846f96eb842774a35fb1f8f720a229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2505a886a7bc006061317a4924651e7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#ga2505a886a7bc006061317a4924651e7c">esThdPost</a> (<a class="el" href="group__kern__intf.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *thd)</td></tr>
<tr class="memdesc:ga2505a886a7bc006061317a4924651e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post to thread semaphore.  <a href="#ga2505a886a7bc006061317a4924651e7c">More...</a><br/></td></tr>
<tr class="separator:ga2505a886a7bc006061317a4924651e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6835afa8c355e01dc35a83310770a47c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#ga6835afa8c355e01dc35a83310770a47c">esThdWaitI</a> (void)</td></tr>
<tr class="memdesc:ga6835afa8c355e01dc35a83310770a47c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for thread semaphore.  <a href="#ga6835afa8c355e01dc35a83310770a47c">More...</a><br/></td></tr>
<tr class="separator:ga6835afa8c355e01dc35a83310770a47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbe4d89d1eba04a007fc39a9db6a5db9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#gabbe4d89d1eba04a007fc39a9db6a5db9">esThdWait</a> (void)</td></tr>
<tr class="memdesc:gabbe4d89d1eba04a007fc39a9db6a5db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for thread semaphore.  <a href="#gabbe4d89d1eba04a007fc39a9db6a5db9">More...</a><br/></td></tr>
<tr class="separator:gabbe4d89d1eba04a007fc39a9db6a5db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa707debebe3f98439911212b0cc8b3d1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#gaa707debebe3f98439911212b0cc8b3d1">ES_STCK_SIZE</a>(elem)&#160;&#160;&#160;<a class="el" href="group__template__cpu__intf.html#gacb3a46e89d327fbaf5c122fe23877b24">PORT_STCK_SIZE</a>(elem)</td></tr>
<tr class="memdesc:gaa707debebe3f98439911212b0cc8b3d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the required stack elements into the stack array index.  <a href="#gaa707debebe3f98439911212b0cc8b3d1">More...</a><br/></td></tr>
<tr class="separator:gaa707debebe3f98439911212b0cc8b3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea99f5a5153b96c419c384323a9e7bca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaea99f5a5153b96c419c384323a9e7bca"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ES_THD_PRIO_MAX</b>&#160;&#160;&#160;(<a class="el" href="group__template__kern__cfg.html#ga56bd89fe76f7fe22f3d8805bc3c68892">CFG_SCHED_PRIO_LVL</a> - 2u)</td></tr>
<tr class="separator:gaea99f5a5153b96c419c384323a9e7bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec52780457f8ad9d4701b0d44a7ee0bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaec52780457f8ad9d4701b0d44a7ee0bc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ES_THD_PRIO_MIN</b>&#160;&#160;&#160;(1u)</td></tr>
<tr class="separator:gaec52780457f8ad9d4701b0d44a7ee0bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Virtual Timer management</h2></td></tr>
<tr class="memitem:ga844873888c186ee81eb66620dadb0451"><td class="memItemLeft" align="right" valign="top">typedef uint_fast32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#ga844873888c186ee81eb66620dadb0451">esTick_T</a></td></tr>
<tr class="memdesc:ga844873888c186ee81eb66620dadb0451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timer tick type.  <a href="#ga844873888c186ee81eb66620dadb0451">More...</a><br/></td></tr>
<tr class="separator:ga844873888c186ee81eb66620dadb0451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c020f0ca54ff412bc1d1505502d2afc"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structesVTmr.html">esVTmr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#ga3c020f0ca54ff412bc1d1505502d2afc">esVTmr_T</a></td></tr>
<tr class="memdesc:ga3c020f0ca54ff412bc1d1505502d2afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual Timer type.  <a href="#ga3c020f0ca54ff412bc1d1505502d2afc">More...</a><br/></td></tr>
<tr class="separator:ga3c020f0ca54ff412bc1d1505502d2afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45fe650eac73e7fe203cc81565401555"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#ga45fe650eac73e7fe203cc81565401555">esVTmrInitI</a> (<a class="el" href="group__kern__intf.html#ga3c020f0ca54ff412bc1d1505502d2afc">esVTmr_T</a> *vTmr, <a class="el" href="group__kern__intf.html#ga844873888c186ee81eb66620dadb0451">esTick_T</a> tick, void(*fn)(void *), void *arg)</td></tr>
<tr class="memdesc:ga45fe650eac73e7fe203cc81565401555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add and start a new virtual timer.  <a href="#ga45fe650eac73e7fe203cc81565401555">More...</a><br/></td></tr>
<tr class="separator:ga45fe650eac73e7fe203cc81565401555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad932cf00aec4ba03a0df02ccc493c4c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#gad932cf00aec4ba03a0df02ccc493c4c2">esVTmrInit</a> (<a class="el" href="group__kern__intf.html#ga3c020f0ca54ff412bc1d1505502d2afc">esVTmr_T</a> *vTmr, <a class="el" href="group__kern__intf.html#ga844873888c186ee81eb66620dadb0451">esTick_T</a> tick, void(*fn)(void *), void *arg)</td></tr>
<tr class="memdesc:gad932cf00aec4ba03a0df02ccc493c4c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add and start a new virtual timer.  <a href="#gad932cf00aec4ba03a0df02ccc493c4c2">More...</a><br/></td></tr>
<tr class="separator:gad932cf00aec4ba03a0df02ccc493c4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96bb2c81f649c0305dfd08d1c79b2e37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#ga96bb2c81f649c0305dfd08d1c79b2e37">esVTmrTermI</a> (<a class="el" href="group__kern__intf.html#ga3c020f0ca54ff412bc1d1505502d2afc">esVTmr_T</a> *vTmr)</td></tr>
<tr class="memdesc:ga96bb2c81f649c0305dfd08d1c79b2e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel and remove a virtual timer.  <a href="#ga96bb2c81f649c0305dfd08d1c79b2e37">More...</a><br/></td></tr>
<tr class="separator:ga96bb2c81f649c0305dfd08d1c79b2e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6ec93a68e3526f18ed926cd441878cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#gad6ec93a68e3526f18ed926cd441878cd">esVTmrTerm</a> (<a class="el" href="group__kern__intf.html#ga3c020f0ca54ff412bc1d1505502d2afc">esVTmr_T</a> *vTmr)</td></tr>
<tr class="memdesc:gad6ec93a68e3526f18ed926cd441878cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel and remove a virtual timer.  <a href="#gad6ec93a68e3526f18ed926cd441878cd">More...</a><br/></td></tr>
<tr class="separator:gad6ec93a68e3526f18ed926cd441878cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26d10c6aaa0cd1d04261d2c9911e890d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#ga26d10c6aaa0cd1d04261d2c9911e890d">esVTmrDelay</a> (<a class="el" href="group__kern__intf.html#ga844873888c186ee81eb66620dadb0451">esTick_T</a> tick)</td></tr>
<tr class="memdesc:ga26d10c6aaa0cd1d04261d2c9911e890d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delay for specified amount of ticks.  <a href="#ga26d10c6aaa0cd1d04261d2c9911e890d">More...</a><br/></td></tr>
<tr class="separator:ga26d10c6aaa0cd1d04261d2c9911e890d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb0d88d6a7e467dc37a6a9a85945aaa6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacb0d88d6a7e467dc37a6a9a85945aaa6"></a>
<a class="el" href="group__kern__intf.html#ga844873888c186ee81eb66620dadb0451">esTick_T</a>&#160;</td><td class="memItemRight" valign="bottom"><b>esSysTmrTickGet</b> (void)</td></tr>
<tr class="separator:gacb0d88d6a7e467dc37a6a9a85945aaa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Thread Queue management</h2></td></tr>
<tr class="memitem:ga7a1a060699e83a01512ebb5540019556"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structesThdQ.html">esThdQ</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#ga7a1a060699e83a01512ebb5540019556">esThdQ_T</a></td></tr>
<tr class="memdesc:ga7a1a060699e83a01512ebb5540019556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread queue type.  <a href="#ga7a1a060699e83a01512ebb5540019556">More...</a><br/></td></tr>
<tr class="separator:ga7a1a060699e83a01512ebb5540019556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddd5fe0557c91559b9452beb0fc236fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#gaddd5fe0557c91559b9452beb0fc236fd">esThdQInit</a> (<a class="el" href="group__kern__intf.html#ga7a1a060699e83a01512ebb5540019556">esThdQ_T</a> *thdQ)</td></tr>
<tr class="memdesc:gaddd5fe0557c91559b9452beb0fc236fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize Thread Queue.  <a href="#gaddd5fe0557c91559b9452beb0fc236fd">More...</a><br/></td></tr>
<tr class="separator:gaddd5fe0557c91559b9452beb0fc236fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5f19b32a7f0c42616b5270dcbd73a3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#gaa5f19b32a7f0c42616b5270dcbd73a3e">esThdQTerm</a> (<a class="el" href="group__kern__intf.html#ga7a1a060699e83a01512ebb5540019556">esThdQ_T</a> *thdQ)</td></tr>
<tr class="memdesc:gaa5f19b32a7f0c42616b5270dcbd73a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminate Thread Queue.  <a href="#gaa5f19b32a7f0c42616b5270dcbd73a3e">More...</a><br/></td></tr>
<tr class="separator:gaa5f19b32a7f0c42616b5270dcbd73a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9da1e71c137d8adb8c9bdead7052b5fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#ga9da1e71c137d8adb8c9bdead7052b5fa">esThdQAddI</a> (<a class="el" href="group__kern__intf.html#ga7a1a060699e83a01512ebb5540019556">esThdQ_T</a> *thdQ, <a class="el" href="group__kern__intf.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *thd)</td></tr>
<tr class="memdesc:ga9da1e71c137d8adb8c9bdead7052b5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a thread to the Thread Queue.  <a href="#ga9da1e71c137d8adb8c9bdead7052b5fa">More...</a><br/></td></tr>
<tr class="separator:ga9da1e71c137d8adb8c9bdead7052b5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa18afa95e34035da03c5cb7ea3a96320"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#gaa18afa95e34035da03c5cb7ea3a96320">esThdQRmI</a> (<a class="el" href="group__kern__intf.html#ga7a1a060699e83a01512ebb5540019556">esThdQ_T</a> *thdQ, <a class="el" href="group__kern__intf.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *thd)</td></tr>
<tr class="memdesc:gaa18afa95e34035da03c5cb7ea3a96320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the thread from the Thread Queue.  <a href="#gaa18afa95e34035da03c5cb7ea3a96320">More...</a><br/></td></tr>
<tr class="separator:gaa18afa95e34035da03c5cb7ea3a96320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1670c123f31c346b24ec9d2b7ae35f88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__kern__intf.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#ga1670c123f31c346b24ec9d2b7ae35f88">esThdQFetchI</a> (const <a class="el" href="group__kern__intf.html#ga7a1a060699e83a01512ebb5540019556">esThdQ_T</a> *thdQ)</td></tr>
<tr class="memdesc:ga1670c123f31c346b24ec9d2b7ae35f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the first high priority thread from the Thread Queue.  <a href="#ga1670c123f31c346b24ec9d2b7ae35f88">More...</a><br/></td></tr>
<tr class="separator:ga1670c123f31c346b24ec9d2b7ae35f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae365b14292f1496a90d876baec84fb4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__kern__intf.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#gae365b14292f1496a90d876baec84fb4e">esThdQFetchRotateI</a> (<a class="el" href="group__kern__intf.html#ga7a1a060699e83a01512ebb5540019556">esThdQ_T</a> *thdQ, uint_fast8_t prio)</td></tr>
<tr class="memdesc:gae365b14292f1496a90d876baec84fb4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the next thread and rotate thread linked list.  <a href="#gae365b14292f1496a90d876baec84fb4e">More...</a><br/></td></tr>
<tr class="separator:gae365b14292f1496a90d876baec84fb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf2687b82ce64e2154d97fd3b69a4ab5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__template__compiler.html#ga74fbee312f9185efb602f89d21b53404">bool_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#gacf2687b82ce64e2154d97fd3b69a4ab5">esThdQIsEmpty</a> (const <a class="el" href="group__kern__intf.html#ga7a1a060699e83a01512ebb5540019556">esThdQ_T</a> *thdQ)</td></tr>
<tr class="memdesc:gacf2687b82ce64e2154d97fd3b69a4ab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is thread queue empty.  <a href="#gacf2687b82ce64e2154d97fd3b69a4ab5">More...</a><br/></td></tr>
<tr class="separator:gacf2687b82ce64e2154d97fd3b69a4ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28fb55234bec595dbeb2c264ac084cc1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#ga28fb55234bec595dbeb2c264ac084cc1">PRIO_BM_GRP_INDX</a>&#160;&#160;&#160;((<a class="el" href="group__template__kern__cfg.html#ga56bd89fe76f7fe22f3d8805bc3c68892">CFG_SCHED_PRIO_LVL</a> + PORT_DEF_DATA_WIDTH - 1u) / PORT_DEF_DATA_WIDTH)</td></tr>
<tr class="memdesc:ga28fb55234bec595dbeb2c264ac084cc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Priority Bit Map Group Index.  <a href="#ga28fb55234bec595dbeb2c264ac084cc1">More...</a><br/></td></tr>
<tr class="separator:ga28fb55234bec595dbeb2c264ac084cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Kernel control block</h2></td></tr>
<tr class="memitem:gac9be6bfeddbd6af148cdb3867fbc24af"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#gac9be6bfeddbd6af148cdb3867fbc24af">esKernState</a> { <br/>
&#160;&#160;<a class="el" href="group__kern__intf.html#ggac9be6bfeddbd6af148cdb3867fbc24afa31a7e1ee10bcd82aaf8f5eca06ecdbe8">ES_KERN_RUN</a> = 0x00u, 
<br/>
&#160;&#160;<a class="el" href="group__kern__intf.html#ggac9be6bfeddbd6af148cdb3867fbc24afa62e34103bea61ea0b7a9816180a43905">ES_KERN_INTSRV_RUN</a> = 0x01u, 
<br/>
&#160;&#160;<a class="el" href="group__kern__intf.html#ggac9be6bfeddbd6af148cdb3867fbc24afa4e5b5c809ea9cdbae536b701003278cc">ES_KERN_LOCK</a> = 0x02u, 
<br/>
&#160;&#160;<a class="el" href="group__kern__intf.html#ggac9be6bfeddbd6af148cdb3867fbc24afa2b35c503975df4c289e9cbff3e815f8b">ES_KERN_INTSRV_LOCK</a> = 0x03u, 
<br/>
&#160;&#160;<a class="el" href="group__kern__intf.html#ggac9be6bfeddbd6af148cdb3867fbc24afad45a94c8b4975fd162d683201a75cceb">ES_KERN_SLEEP</a> = 0x06u, 
<br/>
&#160;&#160;<a class="el" href="group__kern__intf.html#ggac9be6bfeddbd6af148cdb3867fbc24afacad35dc43528f96d27696db584f05cff">ES_KERN_INIT</a> = 0x08u, 
<br/>
&#160;&#160;<a class="el" href="group__kern__intf.html#ggac9be6bfeddbd6af148cdb3867fbc24afa089165cac55f315953335f5ffe41b7c4">ES_KERN_INACTIVE</a> = 0x10u
<br/>
 }</td></tr>
<tr class="memdesc:gac9be6bfeddbd6af148cdb3867fbc24af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel state enumeration.  <a href="group__kern__intf.html#gac9be6bfeddbd6af148cdb3867fbc24af">More...</a><br/></td></tr>
<tr class="separator:gac9be6bfeddbd6af148cdb3867fbc24af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5edef44fe53303f96dc5e9f567babaf"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group__kern__intf.html#gac9be6bfeddbd6af148cdb3867fbc24af">esKernState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#gab5edef44fe53303f96dc5e9f567babaf">esKernState_T</a></td></tr>
<tr class="memdesc:gab5edef44fe53303f96dc5e9f567babaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel state type.  <a href="#gab5edef44fe53303f96dc5e9f567babaf">More...</a><br/></td></tr>
<tr class="separator:gab5edef44fe53303f96dc5e9f567babaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae54a9918d92a2105b1d331b083d21b7"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structesKernCtrl.html">esKernCtrl</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#gaae54a9918d92a2105b1d331b083d21b7">esKernCtrl_T</a></td></tr>
<tr class="memdesc:gaae54a9918d92a2105b1d331b083d21b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel control block type.  <a href="#gaae54a9918d92a2105b1d331b083d21b7">More...</a><br/></td></tr>
<tr class="separator:gaae54a9918d92a2105b1d331b083d21b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga299ac766f155bf1ef931627e2a0b895b"><td class="memItemLeft" align="right" valign="top">const volatile <a class="el" href="group__kern__intf.html#gaae54a9918d92a2105b1d331b083d21b7">esKernCtrl_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#ga299ac766f155bf1ef931627e2a0b895b">gKernCtrl</a></td></tr>
<tr class="memdesc:ga299ac766f155bf1ef931627e2a0b895b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel control block.  <a href="#ga299ac766f155bf1ef931627e2a0b895b">More...</a><br/></td></tr>
<tr class="separator:ga299ac766f155bf1ef931627e2a0b895b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
General kernel functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp41382adffec1bac51ecae38edaa569b6"></a>There are several groups of functions:</p>
<ul>
<li>kernel initialization and start</li>
<li>ISR prologue and epilogue </li>
</ul>
</td></tr>
<tr class="memitem:ga9e9ff699d62d6035cd51121bb3140704"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#ga9e9ff699d62d6035cd51121bb3140704">esKernInit</a> (void)</td></tr>
<tr class="memdesc:ga9e9ff699d62d6035cd51121bb3140704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize kernel internal data structures.  <a href="#ga9e9ff699d62d6035cd51121bb3140704">More...</a><br/></td></tr>
<tr class="separator:ga9e9ff699d62d6035cd51121bb3140704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e7a0a6b9c02df58de0f98de0229a09d"><td class="memItemLeft" align="right" valign="top">PORT_C_NORETURN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#ga0e7a0a6b9c02df58de0f98de0229a09d">esKernStart</a> (void)</td></tr>
<tr class="memdesc:ga0e7a0a6b9c02df58de0f98de0229a09d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the multi-threading.  <a href="#ga0e7a0a6b9c02df58de0f98de0229a09d">More...</a><br/></td></tr>
<tr class="separator:ga0e7a0a6b9c02df58de0f98de0229a09d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3182e4c1a47897109d0a429b10a2483e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#ga3182e4c1a47897109d0a429b10a2483e">esKernSysTmr</a> (void)</td></tr>
<tr class="memdesc:ga3182e4c1a47897109d0a429b10a2483e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process the system timer event.  <a href="#ga3182e4c1a47897109d0a429b10a2483e">More...</a><br/></td></tr>
<tr class="separator:ga3182e4c1a47897109d0a429b10a2483e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga194f9cbc5398fe0938504a378fcff810"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#ga194f9cbc5398fe0938504a378fcff810">esKernIsrPrologueI</a> (void)</td></tr>
<tr class="memdesc:ga194f9cbc5398fe0938504a378fcff810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enter Interrupt Service Routine.  <a href="#ga194f9cbc5398fe0938504a378fcff810">More...</a><br/></td></tr>
<tr class="separator:ga194f9cbc5398fe0938504a378fcff810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62d9b43eb8faf6c5df37e7b89811ac8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#ga62d9b43eb8faf6c5df37e7b89811ac8d">esKernIsrEpilogueI</a> (void)</td></tr>
<tr class="memdesc:ga62d9b43eb8faf6c5df37e7b89811ac8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit Interrupt Service Routine.  <a href="#ga62d9b43eb8faf6c5df37e7b89811ac8d">More...</a><br/></td></tr>
<tr class="separator:ga62d9b43eb8faf6c5df37e7b89811ac8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Scheduler notification and invocation</h2></td></tr>
<tr class="memitem:ga73e14b1860ce824c822adc407aee0977"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#ga73e14b1860ce824c822adc407aee0977">esSchedRdyAddI</a> (<a class="el" href="group__kern__intf.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *thd)</td></tr>
<tr class="memdesc:ga73e14b1860ce824c822adc407aee0977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add thread <code>thd</code> to the ready thread list and notify the scheduler.  <a href="#ga73e14b1860ce824c822adc407aee0977">More...</a><br/></td></tr>
<tr class="separator:ga73e14b1860ce824c822adc407aee0977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b8263c5024ebb59cd9b95cc9253b44d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#ga0b8263c5024ebb59cd9b95cc9253b44d">esSchedRdyRmI</a> (<a class="el" href="group__kern__intf.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *thd)</td></tr>
<tr class="memdesc:ga0b8263c5024ebb59cd9b95cc9253b44d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove thread <code>thd</code> from the ready thread list and notify the scheduler.  <a href="#ga0b8263c5024ebb59cd9b95cc9253b44d">More...</a><br/></td></tr>
<tr class="separator:ga0b8263c5024ebb59cd9b95cc9253b44d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf90e487bfce974dafaeed5009e189810"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#gaf90e487bfce974dafaeed5009e189810">esSchedYieldI</a> (void)</td></tr>
<tr class="memdesc:gaf90e487bfce974dafaeed5009e189810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force the scheduler invocation which will evaluate all ready threads and switch to ready thread with the highest priority.  <a href="#gaf90e487bfce974dafaeed5009e189810">More...</a><br/></td></tr>
<tr class="separator:gaf90e487bfce974dafaeed5009e189810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbea29b376b29f11bbfc48a0f5144e9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#gafbea29b376b29f11bbfc48a0f5144e9a">esSchedYieldIsrI</a> (void)</td></tr>
<tr class="memdesc:gafbea29b376b29f11bbfc48a0f5144e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force the scheduler invocation which will evaluate all ready threads and switch to ready thread with the highest priority.  <a href="#gafbea29b376b29f11bbfc48a0f5144e9a">More...</a><br/></td></tr>
<tr class="separator:gafbea29b376b29f11bbfc48a0f5144e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e60d9df6ad1712ed57cd4ca038fcad2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#ga1e60d9df6ad1712ed57cd4ca038fcad2">esSchedLockEnterI</a> (void)</td></tr>
<tr class="memdesc:ga1e60d9df6ad1712ed57cd4ca038fcad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the scheduler.  <a href="#ga1e60d9df6ad1712ed57cd4ca038fcad2">More...</a><br/></td></tr>
<tr class="separator:ga1e60d9df6ad1712ed57cd4ca038fcad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddd9b2fcbc03765f63f81b64e6663934"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#gaddd9b2fcbc03765f63f81b64e6663934">esSchedLockExitI</a> (void)</td></tr>
<tr class="memdesc:gaddd9b2fcbc03765f63f81b64e6663934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the scheduler.  <a href="#gaddd9b2fcbc03765f63f81b64e6663934">More...</a><br/></td></tr>
<tr class="separator:gaddd9b2fcbc03765f63f81b64e6663934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b70a0e213b791b4e51840352d144a22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#ga4b70a0e213b791b4e51840352d144a22">esSchedLockEnter</a> (void)</td></tr>
<tr class="memdesc:ga4b70a0e213b791b4e51840352d144a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the scheduler.  <a href="#ga4b70a0e213b791b4e51840352d144a22">More...</a><br/></td></tr>
<tr class="separator:ga4b70a0e213b791b4e51840352d144a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4c263203fcf700d96fe21782cfde219"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#gac4c263203fcf700d96fe21782cfde219">esSchedLockExit</a> (void)</td></tr>
<tr class="memdesc:gac4c263203fcf700d96fe21782cfde219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the scheduler.  <a href="#gac4c263203fcf700d96fe21782cfde219">More...</a><br/></td></tr>
<tr class="separator:gac4c263203fcf700d96fe21782cfde219"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Kernel hook functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp1ac47bb3ac7873775afb0f49bf86f38e"></a></p>
<dl class="section note"><dt>Note</dt><dd>1) The definition of this functions must be written by the user. </dd></dl>
</td></tr>
<tr class="memitem:ga9a0d562969acef0121136b11be7b4728"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#ga9a0d562969acef0121136b11be7b4728">userPreSysTmr</a> (void)</td></tr>
<tr class="memdesc:ga9a0d562969acef0121136b11be7b4728"><td class="mdescLeft">&#160;</td><td class="mdescRight">System timer hook function, called from system system timer ISR function before the kernel functions.  <a href="#ga9a0d562969acef0121136b11be7b4728">More...</a><br/></td></tr>
<tr class="separator:ga9a0d562969acef0121136b11be7b4728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac77966856c9a299cda4794cbcc87edf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#gaac77966856c9a299cda4794cbcc87edf">userPreKernInit</a> (void)</td></tr>
<tr class="memdesc:gaac77966856c9a299cda4794cbcc87edf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel initialization hook function, called from <a class="el" href="group__kern__intf.html#ga9e9ff699d62d6035cd51121bb3140704" title="Initialize kernel internal data structures. ">esKernInit()</a> function before kernel initialization.  <a href="#gaac77966856c9a299cda4794cbcc87edf">More...</a><br/></td></tr>
<tr class="separator:gaac77966856c9a299cda4794cbcc87edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3579ac6964a314ad03d13da0507f57e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#ga3579ac6964a314ad03d13da0507f57e8">userPostKernInit</a> (void)</td></tr>
<tr class="memdesc:ga3579ac6964a314ad03d13da0507f57e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel initialization hook function, called from <a class="el" href="group__kern__intf.html#ga9e9ff699d62d6035cd51121bb3140704" title="Initialize kernel internal data structures. ">esKernInit()</a> function after kernel initialization.  <a href="#ga3579ac6964a314ad03d13da0507f57e8">More...</a><br/></td></tr>
<tr class="separator:ga3579ac6964a314ad03d13da0507f57e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac505ab4c72e0fb346ca441d6def327d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#gaac505ab4c72e0fb346ca441d6def327d">userPreKernStart</a> (void)</td></tr>
<tr class="memdesc:gaac505ab4c72e0fb346ca441d6def327d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel start hook function, called from <a class="el" href="group__kern__intf.html#ga0e7a0a6b9c02df58de0f98de0229a09d" title="Start the multi-threading. ">esKernStart()</a> function.  <a href="#gaac505ab4c72e0fb346ca441d6def327d">More...</a><br/></td></tr>
<tr class="separator:gaac505ab4c72e0fb346ca441d6def327d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64ca864d0ff2aaa532208d7c2b88bdb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#ga64ca864d0ff2aaa532208d7c2b88bdb3">userPostThdInit</a> (<a class="el" href="group__kern__intf.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *thd)</td></tr>
<tr class="memdesc:ga64ca864d0ff2aaa532208d7c2b88bdb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread initialization end hook function, called from <a class="el" href="group__kern__intf.html#gac91734f3ee867b519f59bf81cc7fde88" title="Initialize the specified thread. ">esThdInit()</a> function.  <a href="#ga64ca864d0ff2aaa532208d7c2b88bdb3">More...</a><br/></td></tr>
<tr class="separator:ga64ca864d0ff2aaa532208d7c2b88bdb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga076ad76633999c9d5e245e3b5c6e0c09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#ga076ad76633999c9d5e245e3b5c6e0c09">userPreThdTerm</a> (void)</td></tr>
<tr class="memdesc:ga076ad76633999c9d5e245e3b5c6e0c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread terminate hook function, called from <a class="el" href="group__kern__intf.html#gac9d1eac76f26096614e8196bcfd8b905" title="Terminate the specified thread. ">esThdTerm()</a> or when a thread terminates itself.  <a href="#ga076ad76633999c9d5e245e3b5c6e0c09">More...</a><br/></td></tr>
<tr class="separator:ga076ad76633999c9d5e245e3b5c6e0c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bd40d82f768787c3dab2f4df336685e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#ga2bd40d82f768787c3dab2f4df336685e">userPreIdle</a> (void)</td></tr>
<tr class="memdesc:ga2bd40d82f768787c3dab2f4df336685e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre Idle hook function, called from idle thread, just before entering idle period.  <a href="#ga2bd40d82f768787c3dab2f4df336685e">More...</a><br/></td></tr>
<tr class="separator:ga2bd40d82f768787c3dab2f4df336685e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ca4a96cbe5064d633298d1d172fd4e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#ga7ca4a96cbe5064d633298d1d172fd4e7">userPostIdle</a> (void)</td></tr>
<tr class="memdesc:ga7ca4a96cbe5064d633298d1d172fd4e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post idle hook function, called from idle thread, just after exiting idle period.  <a href="#ga7ca4a96cbe5064d633298d1d172fd4e7">More...</a><br/></td></tr>
<tr class="separator:ga7ca4a96cbe5064d633298d1d172fd4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74a38c965110d0f2f2e44e13571fe3fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__intf.html#ga74a38c965110d0f2f2e44e13571fe3fc">userPreCtxSw</a> (<a class="el" href="group__kern__intf.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *oldThd, <a class="el" href="group__kern__intf.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *newThd)</td></tr>
<tr class="memdesc:ga74a38c965110d0f2f2e44e13571fe3fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel context switch hook function, called from <a class="el" href="group__kern__intf.html#gaf90e487bfce974dafaeed5009e189810" title="Force the scheduler invocation which will evaluate all ready threads and switch to ready thread with ...">esSchedYieldI()</a> and <a class="el" href="group__kern__intf.html#gafbea29b376b29f11bbfc48a0f5144e9a" title="Force the scheduler invocation which will evaluate all ready threads and switch to ready thread with ...">esSchedYieldIsrI()</a> functions just before context switch.  <a href="#ga74a38c965110d0f2f2e44e13571fe3fc">More...</a><br/></td></tr>
<tr class="separator:ga74a38c965110d0f2f2e44e13571fe3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Application programming interface. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gacde22f7336a3c1c032dfc0ee3b94f506"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ES_KERN_VER&#160;&#160;&#160;0x10000ul</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identifies the underlying kernel version number. </p>
<p>Kernel identification and version (main [31:16] .sub [15:0]) </p>

</div>
</div>
<a class="anchor" id="ga7a9484c6b09349e4eb82ba67c0989e25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ES_KERN_ID&#160;&#160;&#160;&quot;eSolid Kernel v1.0&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel identification string. </p>

</div>
</div>
<a class="anchor" id="ga0420d9c03ac590d6e3e46fd17f6a739e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ES_CRITICAL_T&#160;&#160;&#160;PORT_CRITICAL_T</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Critical section context variable type. </p>

</div>
</div>
<a class="anchor" id="ga90ec47263e8a05b91fe9359c97eb1c9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ES_CRITICAL_ENTER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ctx</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__template__cpu__intf.html#gad230b116bf8bc513e64c533d4e946054">PORT_CRITICAL_ENTER</a>(ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enter a critical section. </p>

</div>
</div>
<a class="anchor" id="gade4fcc55ee1325723ed798a8c5e11e56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ES_CRITICAL_EXIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ctx</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__template__cpu__intf.html#ga95082ec189f12ed8e39efbda811dea77">PORT_CRITICAL_EXIT</a>(ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exit from critical section. </p>

</div>
</div>
<a class="anchor" id="gacf1dc7063de829a77484e4c9e1e942a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ES_CRITICAL_ENTER_LOCK_EXIT</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                                                                        <a class="code" href="group__template__cpu__intf.html#gad230b116bf8bc513e64c533d4e946054">\</a></div>
<div class="line"><a class="code" href="group__template__cpu__intf.html#gad230b116bf8bc513e64c533d4e946054">        PORT_CRITICAL_ENTER</a>();                                                  <a class="code" href="group__kern__intf.html#gaddd9b2fcbc03765f63f81b64e6663934">\</a></div>
<div class="line"><a class="code" href="group__kern__intf.html#gaddd9b2fcbc03765f63f81b64e6663934">        esSchedLockExitI</a>();                                                     \</div>
<div class="line">    } <span class="keywordflow">while</span> (0U)</div>
<div class="ttc" id="group__kern__intf_html_gaddd9b2fcbc03765f63f81b64e6663934"><div class="ttname"><a href="group__kern__intf.html#gaddd9b2fcbc03765f63f81b64e6663934">esSchedLockExitI</a></div><div class="ttdeci">void esSchedLockExitI(void)</div><div class="ttdoc">Unlock the scheduler. </div><div class="ttdef"><b>Definition:</b> kernel.c:1444</div></div>
<div class="ttc" id="group__template__cpu__intf_html_gad230b116bf8bc513e64c533d4e946054"><div class="ttname"><a href="group__template__cpu__intf.html#gad230b116bf8bc513e64c533d4e946054">PORT_CRITICAL_ENTER</a></div><div class="ttdeci">#define PORT_CRITICAL_ENTER()</div><div class="ttdoc">Enter critical section. </div><div class="ttdef"><b>Definition:</b> cpu.h:173</div></div>
</div><!-- fragment -->
<p>Enter critical section and exit scheduler lock. </p>

</div>
</div>
<a class="anchor" id="ga4466c8aea583e299815926cd4d262a2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ES_CRITICAL_EXIT_LOCK_ENTER</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                                                                        <a class="code" href="group__kern__intf.html#ga1e60d9df6ad1712ed57cd4ca038fcad2">\</a></div>
<div class="line"><a class="code" href="group__kern__intf.html#ga1e60d9df6ad1712ed57cd4ca038fcad2">        esSchedLockEnterI</a>();                                                    <a class="code" href="group__template__cpu__intf.html#ga95082ec189f12ed8e39efbda811dea77">\</a></div>
<div class="line"><a class="code" href="group__template__cpu__intf.html#ga95082ec189f12ed8e39efbda811dea77">        PORT_CRITICAL_EXIT</a>();                                                   \</div>
<div class="line">    } <span class="keywordflow">while</span> (0U)</div>
<div class="ttc" id="group__template__cpu__intf_html_ga95082ec189f12ed8e39efbda811dea77"><div class="ttname"><a href="group__template__cpu__intf.html#ga95082ec189f12ed8e39efbda811dea77">PORT_CRITICAL_EXIT</a></div><div class="ttdeci">#define PORT_CRITICAL_EXIT()</div><div class="ttdoc">Exit critical section. </div><div class="ttdef"><b>Definition:</b> cpu.h:177</div></div>
<div class="ttc" id="group__kern__intf_html_ga1e60d9df6ad1712ed57cd4ca038fcad2"><div class="ttname"><a href="group__kern__intf.html#ga1e60d9df6ad1712ed57cd4ca038fcad2">esSchedLockEnterI</a></div><div class="ttdeci">void esSchedLockEnterI(void)</div><div class="ttdoc">Lock the scheduler. </div><div class="ttdef"><b>Definition:</b> kernel.c:1435</div></div>
</div><!-- fragment -->
<p>Exit critical section and enter scheduler lock. </p>

</div>
</div>
<a class="anchor" id="gaa707debebe3f98439911212b0cc8b3d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ES_STCK_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">elem</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__template__cpu__intf.html#gacb3a46e89d327fbaf5c122fe23877b24">PORT_STCK_SIZE</a>(elem)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the required stack elements into the stack array index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elem</td><td>Number of stack elements: the stack size is expressed in number of elements regardles of the size of port general purpose registers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga28fb55234bec595dbeb2c264ac084cc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PRIO_BM_GRP_INDX&#160;&#160;&#160;((<a class="el" href="group__template__kern__cfg.html#ga56bd89fe76f7fe22f3d8805bc3c68892">CFG_SCHED_PRIO_LVL</a> + PORT_DEF_DATA_WIDTH - 1u) / PORT_DEF_DATA_WIDTH)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Priority Bit Map Group Index. </p>
<dl class="section user"><dt>Object class:</dt><dd><b>Not API</b> object, this object is not part of the application programming interface and it is intended for internal use only. </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga62e3a3ca0a4597a19c43cb8868810d82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structesThd.html">esThd</a> <a class="el" href="group__kern__intf.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thread type. </p>

</div>
</div>
<a class="anchor" id="ga24160ddd0cb0327108cc652bfe6a49e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__template__cpu__intf.html#ga13cc91970e3e05fe4210440c068d3f4a">portStck_T</a> <a class="el" href="group__kern__intf.html#ga24160ddd0cb0327108cc652bfe6a49e5">esStck_T</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stack type. </p>

</div>
</div>
<a class="anchor" id="ga844873888c186ee81eb66620dadb0451"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint_fast32_t <a class="el" href="group__kern__intf.html#ga844873888c186ee81eb66620dadb0451">esTick_T</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Timer tick type. </p>

</div>
</div>
<a class="anchor" id="ga3c020f0ca54ff412bc1d1505502d2afc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structesVTmr.html">esVTmr</a> <a class="el" href="group__kern__intf.html#ga3c020f0ca54ff412bc1d1505502d2afc">esVTmr_T</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Virtual Timer type. </p>

</div>
</div>
<a class="anchor" id="ga7a1a060699e83a01512ebb5540019556"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structesThdQ.html">esThdQ</a> <a class="el" href="group__kern__intf.html#ga7a1a060699e83a01512ebb5540019556">esThdQ_T</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thread queue type. </p>

</div>
</div>
<a class="anchor" id="gab5edef44fe53303f96dc5e9f567babaf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group__kern__intf.html#gac9be6bfeddbd6af148cdb3867fbc24af">esKernState</a> <a class="el" href="group__kern__intf.html#gab5edef44fe53303f96dc5e9f567babaf">esKernState_T</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel state type. </p>

</div>
</div>
<a class="anchor" id="gaae54a9918d92a2105b1d331b083d21b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structesKernCtrl.html">esKernCtrl</a> <a class="el" href="group__kern__intf.html#gaae54a9918d92a2105b1d331b083d21b7">esKernCtrl_T</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel control block type. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gac9be6bfeddbd6af148cdb3867fbc24af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__kern__intf.html#gac9be6bfeddbd6af148cdb3867fbc24af">esKernState</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel state enumeration. </p>
<p>For more details see: <a class="el" href="states.html">Kernel states</a> </p>
<dl class="section user"><dt>Object class:</dt><dd>Regular <b>API</b> object, this object is part of the application programming interface. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ggac9be6bfeddbd6af148cdb3867fbc24afa31a7e1ee10bcd82aaf8f5eca06ecdbe8"></a>ES_KERN_RUN</em>&nbsp;</td><td class="fielddoc">
<p>Kernel is active </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggac9be6bfeddbd6af148cdb3867fbc24afa62e34103bea61ea0b7a9816180a43905"></a>ES_KERN_INTSRV_RUN</em>&nbsp;</td><td class="fielddoc">
<p>Servicing an interrupt return to ES_KERN_RUN state </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggac9be6bfeddbd6af148cdb3867fbc24afa4e5b5c809ea9cdbae536b701003278cc"></a>ES_KERN_LOCK</em>&nbsp;</td><td class="fielddoc">
<p>Kernel is locked </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggac9be6bfeddbd6af148cdb3867fbc24afa2b35c503975df4c289e9cbff3e815f8b"></a>ES_KERN_INTSRV_LOCK</em>&nbsp;</td><td class="fielddoc">
<p>Servicing an interrupt, return to ES_KERN_LOCK state </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggac9be6bfeddbd6af148cdb3867fbc24afad45a94c8b4975fd162d683201a75cceb"></a>ES_KERN_SLEEP</em>&nbsp;</td><td class="fielddoc">
<p>Kernel is sleeping </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggac9be6bfeddbd6af148cdb3867fbc24afacad35dc43528f96d27696db584f05cff"></a>ES_KERN_INIT</em>&nbsp;</td><td class="fielddoc">
<p>Kernel is in initialization state </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggac9be6bfeddbd6af148cdb3867fbc24afa089165cac55f315953335f5ffe41b7c4"></a>ES_KERN_INACTIVE</em>&nbsp;</td><td class="fielddoc">
<p>Kernel data structures are not initialized </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga9e9ff699d62d6035cd51121bb3140704"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esKernInit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize kernel internal data structures. </p>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state == ES_KERN_INACTIVE</code>, see <a class="el" href="states.html">Kernel states</a>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>1) <code>The kernel state == ES_KERN_INIT</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>1) This function may be invoked only once.</dd></dl>
<p>This function must be called first before any other kernel API. It initializes internal data structures that are used by other API functions. </p>
<dl class="section user"><dt>This service can be called from:</dt><dd><ul>
<li>Application initialization code </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Rescheduling:</dt><dd><ul>
<li>never </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Object class:</dt><dd>Regular <b>API</b> object, this object is part of the application programming interface. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0e7a0a6b9c02df58de0f98de0229a09d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PORT_C_NORETURN void esKernStart </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start the multi-threading. </p>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state == ES_KERN_INIT</code>, see <a class="el" href="states.html">Kernel states</a>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>1) <code>The kernel state == ES_KERN_RUN</code> </dd>
<dd>
2) The multi-threading execution will commence. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>1) Once this function is called the execution of threads will start and this function will never return.</dd></dl>
<p>This function will start multi-threading. Once the multi-threading has started the execution will never return to this function again (this function never returns). </p>
<dl class="section user"><dt>This service can be called from:</dt><dd><ul>
<li>Application initialization code </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Rescheduling:</dt><dd><ul>
<li>always </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Object class:</dt><dd>Regular <b>API</b> object, this object is part of the application programming interface. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3182e4c1a47897109d0a429b10a2483e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esKernSysTmr </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process the system timer event. </p>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state &lt; ES_KERN_INIT</code>, see <a class="el" href="states.html">Kernel states</a>.</dd></dl>
<p>This function will be called only by port system timer interrupt. </p>
<dl class="section user"><dt>Object class:</dt><dd><b>Not API</b> object, this object is not part of the application programming interface and it is intended for internal use only. </dd></dl>

</div>
</div>
<a class="anchor" id="ga194f9cbc5398fe0938504a378fcff810"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esKernIsrPrologueI </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enter Interrupt Service Routine. </p>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state &lt; ES_KERN_INIT</code>, see <a class="el" href="states.html">Kernel states</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>1) You must call <a class="el" href="group__kern__intf.html#ga62d9b43eb8faf6c5df37e7b89811ac8d" title="Exit Interrupt Service Routine. ">esKernIsrEpilogueI()</a> at the exit of ISR. </dd>
<dd>
2) You must invoke <a class="el" href="group__kern__intf.html#ga194f9cbc5398fe0938504a378fcff810" title="Enter Interrupt Service Routine. ">esKernIsrPrologueI()</a> and <a class="el" href="group__kern__intf.html#ga62d9b43eb8faf6c5df37e7b89811ac8d" title="Exit Interrupt Service Routine. ">esKernIsrEpilogueI()</a> in pair. In other words, for every call to <a class="el" href="group__kern__intf.html#ga194f9cbc5398fe0938504a378fcff810" title="Enter Interrupt Service Routine. ">esKernIsrPrologueI()</a> at the beginning of the ISR you must have a call to <a class="el" href="group__kern__intf.html#ga62d9b43eb8faf6c5df37e7b89811ac8d" title="Exit Interrupt Service Routine. ">esKernIsrEpilogueI()</a> at the end of the ISR.</dd></dl>
<p>Function will notify kernel that you are about to enter interrupt service routine (ISR). This allows kernel to keep track of interrupt nesting and then only perform rescheduling at the last nested ISR. </p>
<dl class="section user"><dt>This service can be called from:</dt><dd><ul>
<li>Interrupt service routine </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Rescheduling:</dt><dd><ul>
<li>never </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function class:</dt><dd><b>I class</b>, Interrupt-lock API function, this function can be called only from interrupts locked code sections. </dd></dl>

</div>
</div>
<a class="anchor" id="ga62d9b43eb8faf6c5df37e7b89811ac8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esKernIsrEpilogueI </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exit Interrupt Service Routine. </p>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state &lt; ES_KERN_INIT</code>, see <a class="el" href="states.html">Kernel states</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>1) You must invoke <a class="el" href="group__kern__intf.html#ga194f9cbc5398fe0938504a378fcff810" title="Enter Interrupt Service Routine. ">esKernIsrPrologueI()</a> and <a class="el" href="group__kern__intf.html#ga62d9b43eb8faf6c5df37e7b89811ac8d" title="Exit Interrupt Service Routine. ">esKernIsrEpilogueI()</a> in pair. In other words, for every call to <a class="el" href="group__kern__intf.html#ga194f9cbc5398fe0938504a378fcff810" title="Enter Interrupt Service Routine. ">esKernIsrPrologueI()</a> at the beginning of the ISR you must have a call to <a class="el" href="group__kern__intf.html#ga62d9b43eb8faf6c5df37e7b89811ac8d" title="Exit Interrupt Service Routine. ">esKernIsrEpilogueI()</a> at the end of the ISR. </dd>
<dd>
2) Rescheduling is prevented when the scheduler is locked (see <a class="el" href="group__kern__intf.html#ga1e60d9df6ad1712ed57cd4ca038fcad2" title="Lock the scheduler. ">esSchedLockEnterI()</a>)</dd></dl>
<p>This function is used to notify kernel that you have completed servicing an interrupt. When the last nested ISR has completed, the function will call the scheduler to determine whether a new, high-priority task, is ready to run. </p>
<dl class="section user"><dt>This service can be called from:</dt><dd><ul>
<li>Interrupt service routine </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Rescheduling:</dt><dd><ul>
<li>possible </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function class:</dt><dd><b>I class</b>, Interrupt-lock API function, this function can be called only from interrupts locked code sections. </dd></dl>

</div>
</div>
<a class="anchor" id="gac91734f3ee867b519f59bf81cc7fde88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esThdInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__kern__intf.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__template__cpu__intf.html#ga13cc91970e3e05fe4210440c068d3f4a">portStck_T</a> *&#160;</td>
          <td class="paramname"><em>stck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stckSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>prio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the specified thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread: is a pointer to the thread structure, <a class="el" href="structesThd.html">esThd</a>. The structure will be used as information container for the thread. It is assumed that storage for the <code><a class="el" href="structesThd.html" title="Thread structure. ">esThd</a></code> structure is allocated by the user code. </td></tr>
    <tr><td class="paramname">fn</td><td>Function: is a pointer to thread function. Thread function must have the following signature: <code>void thread (void * arg)</code>. </td></tr>
    <tr><td class="paramname">arg</td><td>Argument: is a void pointer to an optional data area. It's usage is application defined and it is intended to pass arguments to thread when it is started for the first time. </td></tr>
    <tr><td class="paramname">stck</td><td>Stack: is a pointer to a allocated memory for thread stack. The pointer always points to the first element in the array, regardless of what type of stack the CPU is using. The thread's stack is used to store local variables, function parameters, return addresses. Each thread has its own stack and different sized stack. The stack type must be an array of <a class="el" href="structportStck.html">portStck</a>. </td></tr>
    <tr><td class="paramname">stckSize</td><td>Stack Size: specifies the size of allocated stack memory. Size is expressed in bytes. Please see port documentation about minimal stack size. Usage of C unary operator <code>sizeof</code> is the recommended way of specifying stack size. </td></tr>
    <tr><td class="paramname">prio</td><td>Priority: is the priority of the thread. The higher the number, the higher the priority (the importance) of the thread. Several threads can have the same priority. Note that lowest (0) and highest (CFG_SCHED_PRIO_LVL - 1) levels are reserved for kernel threads only. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state ES_KERN_INACTIVE</code>, see <a class="el" href="states.html">Kernel states</a>. </dd>
<dd>
2) <code>thd != NULL</code> </dd>
<dd>
3) <code>thd-&gt;signature != THD_CONTRACT_SIGNATURE</code>, the thread structure can't be initialized more than once. </dd>
<dd>
4) <code>fn != NULL</code> </dd>
<dd>
5) <code>stckSize &gt;= PORT_DEF_STCK_MINSIZE</code>, see PORT_DEF_STCK_MINSIZE. </dd>
<dd>
6) <code>0 &lt; prio &lt; CFG_SCHED_PRIO_LVL - 1</code>, see <a class="el" href="group__template__kern__cfg.html#ga56bd89fe76f7fe22f3d8805bc3c68892">CFG_SCHED_PRIO_LVL</a>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>1) <code>thd-&gt;signature == THD_CONTRACT_SIGNATURE</code>, each <a class="el" href="structesThd.html">esThd</a> structure will have valid signature after initialization.</dd></dl>
<p>Threads must be created in order for kernel to recognize them as threads. Initialize a thread by calling <a class="el" href="group__kern__intf.html#gac91734f3ee867b519f59bf81cc7fde88" title="Initialize the specified thread. ">esThdInit()</a> and provide arguments specifying to kernel how the thread will be managed. Threads are always created in the <code>ready-to-run</code> state. Threads can be created either prior to the start of multi-threading (before calling <a class="el" href="group__kern__intf.html#ga0e7a0a6b9c02df58de0f98de0229a09d" title="Start the multi-threading. ">esKernStart()</a>), or by a running thread. </p>
<dl class="section user"><dt>This service can be called from:</dt><dd><ul>
<li>Application initialization code</li>
<li>Application thread code </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Rescheduling:</dt><dd><ul>
<li>possible </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Object class:</dt><dd>Regular <b>API</b> object, this object is part of the application programming interface. </dd></dl>

</div>
</div>
<a class="anchor" id="gac9d1eac76f26096614e8196bcfd8b905"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esThdTerm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__kern__intf.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Terminate the specified thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread: is a pointer to the thread structure, <a class="el" href="structesThd.html">esThd</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state ES_KERN_INACTIVE</code>, see <a class="el" href="states.html">Kernel states</a>. </dd>
<dd>
2) <code>thd != NULL</code> </dd>
<dd>
3) <code>thd-&gt;signature == THD_CONTRACT_SIGNATURE</code>, the pointer must point to a valid <a class="el" href="structesThd.html">esThd</a> structure. </dd>
<dd>
4) <code>(thd-&gt;thdL.q == NULL) OR (thd-&gt;thdL.q == gRdyQueue)</code>, thread must be either in Ready Threads Queue or not be in any queue (e.g. not waiting for a synchronization mechanism). </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>1) <code>thd-&gt;signature == ~THD_CONTRACT_SIGNATURE</code>, each <a class="el" href="structesThd.html">esThd</a> structure will have invalid signature after termination. </dd></dl>
<dl class="section user"><dt>This service can be called from:</dt><dd><ul>
<li>Application initialization code</li>
<li>Application thread code </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Rescheduling:</dt><dd><ul>
<li>possible </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Object class:</dt><dd>Regular <b>API</b> object, this object is part of the application programming interface. </dd></dl>

</div>
</div>
<a class="anchor" id="gae2a2c5fe0128d446a64512b0714bfb6d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__template__compiler.html#ga87952d6e574c7f437503926e833ba345">PORT_C_INLINE</a> <a class="el" href="group__kern__intf.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a>* esThdGetId </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current thread ID. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to current thread ID structure <a class="el" href="structesThd.html">esThd</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is <code>inline</code> function. </dd></dl>
<dl class="section user"><dt>This service can be called from:</dt><dd><ul>
<li>Application initialization code</li>
<li>Application thread code</li>
<li>Interrupt service routine </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Rescheduling:</dt><dd><ul>
<li>never </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Object class:</dt><dd>Regular <b>API</b> object, this object is part of the application programming interface. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6d2d033dc7e1226eccf4a51c666678ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__template__compiler.html#ga87952d6e574c7f437503926e833ba345">PORT_C_INLINE</a> uint8_t esThdGetPrio </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__kern__intf.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the priority of a thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread: is pointer to the thread structure, <a class="el" href="structesThd.html">esThd</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The priority of the thread pointed by <code>thd</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is <code>inline</code> function. </dd></dl>
<dl class="section user"><dt>This service can be called from:</dt><dd><ul>
<li>Application initialization code</li>
<li>Application thread code</li>
<li>Interrupt service routine </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Rescheduling:</dt><dd><ul>
<li>never </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Object class:</dt><dd>Regular <b>API</b> object, this object is part of the application programming interface. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8eaa731d0026a8a1667d4422d5031df6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esThdSetPrioI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__kern__intf.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>prio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the priority of a thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread: is pointer to the thread structure, <a class="el" href="structesThd.html">esThd</a>. </td></tr>
    <tr><td class="paramname">prio</td><td>Priority: is new priority of the thread pointed by <code>thd</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state &lt; ES_KERN_INACTIVE</code>, see <a class="el" href="states.html">Kernel states</a>. </dd>
<dd>
2) <code>thd != NULL</code> </dd>
<dd>
3) <code>thd-&gt;signature == THD_CONTRACT_SIGNATURE</code>, the pointer must point to a valid <a class="el" href="structesThd.html">esThd</a> structure. </dd>
<dd>
4) <code>0 &lt; prio &lt; CFG_SCHED_PRIO_LVL - 1</code>, see <a class="el" href="group__template__kern__cfg.html#ga56bd89fe76f7fe22f3d8805bc3c68892">CFG_SCHED_PRIO_LVL</a>. </dd></dl>
<dl class="section user"><dt>This service can be called from:</dt><dd><ul>
<li>Application initialization code</li>
<li>Application thread code</li>
<li>Interrupt service routine </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Rescheduling:</dt><dd><ul>
<li>possible </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function class:</dt><dd><b>I class</b>, Interrupt-lock API function, this function can be called only from interrupts locked code sections. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1c846f96eb842774a35fb1f8f720a229"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esThdPostI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__kern__intf.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post to thread semaphore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Pointer to the thread ID structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state &lt; ES_KERN_INACTIVE</code>, see <a class="el" href="states.html">Kernel states</a>. </dd>
<dd>
2) <code>thd != NULL</code> </dd>
<dd>
3) <code>thd-&gt;signature == THD_CONTRACT_SIGNATURE</code>, the pointer must point to a valid <a class="el" href="structesThd.html">esThd</a> structure. </dd></dl>
<dl class="section user"><dt>This service can be called from:</dt><dd><ul>
<li>Application initialization code</li>
<li>Application thread code</li>
<li>Interrupt service routine </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Rescheduling:</dt><dd><ul>
<li>possible </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function class:</dt><dd><b>I class</b>, Interrupt-lock API function, this function can be called only from interrupts locked code sections. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2505a886a7bc006061317a4924651e7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esThdPost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__kern__intf.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post to thread semaphore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Pointer to the thread ID structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state &lt; ES_KERN_INACTIVE</code>, see <a class="el" href="states.html">Kernel states</a>. </dd>
<dd>
2) <code>thd != NULL</code> </dd>
<dd>
3) <code>thd-&gt;signature == THD_CONTRACT_SIGNATURE</code>, the pointer must point to a valid <a class="el" href="structesThd.html">esThd</a> structure. </dd></dl>
<dl class="section user"><dt>This service can be called from:</dt><dd><ul>
<li>Application initialization code</li>
<li>Application thread code </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Rescheduling:</dt><dd><ul>
<li>possible </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Object class:</dt><dd>Regular <b>API</b> object, this object is part of the application programming interface. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6835afa8c355e01dc35a83310770a47c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esThdWaitI </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for thread semaphore. </p>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state == ES_KERN_RUN</code>, see <a class="el" href="states.html">Kernel states</a>. </dd></dl>
<dl class="section user"><dt>This service can be called from:</dt><dd><ul>
<li>Application thread code </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Rescheduling:</dt><dd><ul>
<li>always </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function class:</dt><dd><b>I class</b>, Interrupt-lock API function, this function can be called only from interrupts locked code sections. </dd></dl>

</div>
</div>
<a class="anchor" id="gabbe4d89d1eba04a007fc39a9db6a5db9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esThdWait </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for thread semaphore. </p>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state == ES_KERN_RUN</code>, see <a class="el" href="states.html">Kernel states</a>. </dd></dl>
<dl class="section user"><dt>This service can be called from:</dt><dd><ul>
<li>Application thread code </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Rescheduling:</dt><dd><ul>
<li>always </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Object class:</dt><dd>Regular <b>API</b> object, this object is part of the application programming interface. </dd></dl>

</div>
</div>
<a class="anchor" id="gaddd5fe0557c91559b9452beb0fc236fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esThdQInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__kern__intf.html#ga7a1a060699e83a01512ebb5540019556">esThdQ_T</a> *&#160;</td>
          <td class="paramname"><em>thdQ</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize Thread Queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thdQ</td><td>Thread Queue: is a pointer to thread queue structure, <a class="el" href="structesThdQ.html">esThdQ</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>thdQ != NULL</code> </dd>
<dd>
2) <code>thdQ-&gt;signature != THDQ_CONTRACT_SIGNATURE</code>, the thread queue structure can't be initialized more than once. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>1) <code>thdQ-&gt;signature == THDQ_CONTRACT_SIGNATURE</code>, each <a class="el" href="structesThdQ.html">esThdQ</a> structure will have valid signature after initialization. </dd></dl>
<dl class="section user"><dt>Object class:</dt><dd>Regular <b>API</b> object, this object is part of the application programming interface. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa5f19b32a7f0c42616b5270dcbd73a3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esThdQTerm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__kern__intf.html#ga7a1a060699e83a01512ebb5540019556">esThdQ_T</a> *&#160;</td>
          <td class="paramname"><em>thdQ</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Terminate Thread Queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thdQ</td><td>Thread Queue: is a pointer to thread queue structure, <a class="el" href="structesThdQ.html">esThdQ</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>thdQ != NULL</code> </dd>
<dd>
2) <code>thdQ-&gt;signature == THDQ_CONTRACT_SIGNATURE</code>, the thread queue structure must be already initialized. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>1) <code>thdQ-&gt;signature == ~THDQ_CONTRACT_SIGNATURE</code>, each <a class="el" href="structesThdQ.html">esThdQ</a> structure will have invalid signature after termination. </dd></dl>
<dl class="section user"><dt>Object class:</dt><dd>Regular <b>API</b> object, this object is part of the application programming interface. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9da1e71c137d8adb8c9bdead7052b5fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esThdQAddI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__kern__intf.html#ga7a1a060699e83a01512ebb5540019556">esThdQ_T</a> *&#160;</td>
          <td class="paramname"><em>thdQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__kern__intf.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *&#160;</td>
          <td class="paramname"><em>thd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a thread to the Thread Queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thdQ</td><td>Thread Queue: is a pointer to thread queue structure, <a class="el" href="structesThdQ.html">esThdQ</a>. </td></tr>
    <tr><td class="paramname">thd</td><td>Thread: is a pointer to the thread ID structure, <a class="el" href="structesThd.html">esThd</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>thdQ != NULL</code> </dd>
<dd>
2) <code>thdQ-&gt;signature == THDQ_CONTRACT_SIGNATURE</code>, the pointer must point to a valid <a class="el" href="structesThdQ.html">esThdQ</a> structure. </dd>
<dd>
3) <code>thd != NULL</code> </dd>
<dd>
4) <code>thd-&gt;signature == THD_CONTRACT_SIGNATURE</code>, the pointer must point to a valid <a class="el" href="structesThd.html">esThd</a> structure. </dd>
<dd>
5) <code>thd-&gt;thdL.q == NULL</code>, thread must not be in any queue.</dd></dl>
<p>This function adds a thread at the specified Thread Queue. </p>
<dl class="section user"><dt>Function class:</dt><dd><b>I class</b>, Interrupt-lock API function, this function can be called only from interrupts locked code sections. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa18afa95e34035da03c5cb7ea3a96320"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esThdQRmI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__kern__intf.html#ga7a1a060699e83a01512ebb5540019556">esThdQ_T</a> *&#160;</td>
          <td class="paramname"><em>thdQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__kern__intf.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *&#160;</td>
          <td class="paramname"><em>thd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the thread from the Thread Queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thdQ</td><td>Thread Queue: is a pointer to thread queue structure, <a class="el" href="structesThdQ.html">esThdQ</a>. </td></tr>
    <tr><td class="paramname">thd</td><td>Thread: is a pointer to the thread ID structure, <a class="el" href="structesThd.html">esThd</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>thd != NULL</code> </dd>
<dd>
2) <code>thd-&gt;signature == THD_CONTRACT_SIGNATURE</code>, the pointer must point to a valid <a class="el" href="structesThd.html">esThd</a> structure. </dd>
<dd>
3) <code>thdQ != NULL</code> </dd>
<dd>
4) <code>thdQ-&gt;signature == THDQ_CONTRACT_SIGNATURE</code>, the pointer must point to a valid <a class="el" href="structesThdQ.html">esThdQ</a> structure. </dd>
<dd>
5) <code>thd-&gt;thdL.q == thdQ</code>, thread must be in the <code>thdQ</code> queue. </dd></dl>
<dl class="section user"><dt>Function class:</dt><dd><b>I class</b>, Interrupt-lock API function, this function can be called only from interrupts locked code sections. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1670c123f31c346b24ec9d2b7ae35f88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__kern__intf.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a>* esThdQFetchI </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__kern__intf.html#ga7a1a060699e83a01512ebb5540019556">esThdQ_T</a> *&#160;</td>
          <td class="paramname"><em>thdQ</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the first high priority thread from the Thread Queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thdQ</td><td>Thread Queue: is a pointer to thread queue structure, <a class="el" href="structesThdQ.html">esThdQ</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the thread ID structure with the highest priority. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>thdQ != NULL</code> </dd>
<dd>
2) <code>thdQ-&gt;signature == THDQ_CONTRACT_SIGNATURE</code>, the pointer must point to a valid <a class="el" href="structesThdQ.html">esThdQ</a> structure. </dd>
<dd>
3) <code>prioBM != 0</code>, priority bit map must not be empty </dd></dl>
<dl class="section user"><dt>Function class:</dt><dd><b>I class</b>, Interrupt-lock API function, this function can be called only from interrupts locked code sections. </dd></dl>

</div>
</div>
<a class="anchor" id="gae365b14292f1496a90d876baec84fb4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__kern__intf.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a>* esThdQFetchRotateI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__kern__intf.html#ga7a1a060699e83a01512ebb5540019556">esThdQ_T</a> *&#160;</td>
          <td class="paramname"><em>thdQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>prio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the next thread and rotate thread linked list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thdQ</td><td>Thread Queue: is a pointer to thread queue structure, <a class="el" href="structesThdQ.html">esThdQ</a>. This is the thread queue to fetch from. </td></tr>
    <tr><td class="paramname">prio</td><td>Priority: is the priority level to fetch and rotate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the next thread in queue. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>thdQ != NULL</code> </dd>
<dd>
2) <code>thdQ-&gt;signature == THDQ_CONTRACT_SIGNATURE</code>, the pointer must point to a valid <a class="el" href="structesThdQ.html">esThdQ</a> structure. </dd>
<dd>
3) <code>0 &lt;= prio &lt;= CFG_SCHED_PRIO_LVL</code>, see <a class="el" href="group__template__kern__cfg.html#ga56bd89fe76f7fe22f3d8805bc3c68892">CFG_SCHED_PRIO_LVL</a>. </dd>
<dd>
4) <code>sentinel != NULL</code>, at least one thread must be in the selected priority level </dd></dl>
<dl class="section user"><dt>Function class:</dt><dd><b>I class</b>, Interrupt-lock API function, this function can be called only from interrupts locked code sections. </dd></dl>

</div>
</div>
<a class="anchor" id="gacf2687b82ce64e2154d97fd3b69a4ab5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__template__compiler.html#ga74fbee312f9185efb602f89d21b53404">bool_T</a> esThdQIsEmpty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__kern__intf.html#ga7a1a060699e83a01512ebb5540019556">esThdQ_T</a> *&#160;</td>
          <td class="paramname"><em>thdQ</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is thread queue empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thdQ</td><td>Thread Queue: is a pointer to thread queue structure, <a class="el" href="structesThdQ.html">esThdQ</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The state of thread queue </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>- thread queue is empty </td></tr>
    <tr><td class="paramname">FALSE</td><td>- thread queue is not empty </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>thdQ != NULL</code> </dd>
<dd>
2) <code>thdQ-&gt;signature == THDQ_CONTRACT_SIGNATURE</code>, the pointer must point to a valid <a class="el" href="structesThdQ.html">esThdQ</a> structure. </dd></dl>
<dl class="section user"><dt>Object class:</dt><dd>Regular <b>API</b> object, this object is part of the application programming interface. </dd></dl>

</div>
</div>
<a class="anchor" id="ga73e14b1860ce824c822adc407aee0977"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esSchedRdyAddI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__kern__intf.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add thread <code>thd</code> to the ready thread list and notify the scheduler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Pointer to the initialized thread ID structure, <a class="el" href="structesThd.html">esThd</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state &lt; ES_KERN_INACTIVE</code>, see <a class="el" href="states.html">Kernel states</a>. </dd>
<dd>
2) <code>thd != NULL</code> </dd>
<dd>
3) <code>thd-&gt;signature == THD_CONTRACT_SIGNATURE</code>, the pointer must point to a valid <a class="el" href="structesThd.html">esThd</a> structure. </dd>
<dd>
4) <code>thd-&gt;thdL.q == NULL</code>, thread must not be in a queue. </dd></dl>
<dl class="section user"><dt>Function class:</dt><dd><b>I class</b>, Interrupt-lock API function, this function can be called only from interrupts locked code sections. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0b8263c5024ebb59cd9b95cc9253b44d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esSchedRdyRmI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__kern__intf.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove thread <code>thd</code> from the ready thread list and notify the scheduler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Pointer to the initialized thread ID structure, <a class="el" href="structesThd.html">esThd</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state &lt; ES_KERN_INACTIVE</code>, see <a class="el" href="states.html">Kernel states</a>. </dd>
<dd>
2) <code>thd != NULL</code> </dd>
<dd>
3) <code>thd-&gt;signature == THD_CONTRACT_SIGNATURE</code>, the pointer must point to a valid <a class="el" href="structesThd.html">esThd</a> structure. </dd>
<dd>
4) <code>thd-&gt;thdL.q == &amp;gRdyQueue</code>, thread must be in Ready Threads queue. </dd></dl>
<dl class="section user"><dt>Function class:</dt><dd><b>I class</b>, Interrupt-lock API function, this function can be called only from interrupts locked code sections. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf90e487bfce974dafaeed5009e189810"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esSchedYieldI </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force the scheduler invocation which will evaluate all ready threads and switch to ready thread with the highest priority. </p>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state &lt; ES_KERN_INACTIVE</code>, see <a class="el" href="states.html">Kernel states</a>. </dd></dl>
<dl class="section user"><dt>Function class:</dt><dd><b>I class</b>, Interrupt-lock API function, this function can be called only from interrupts locked code sections. </dd></dl>

</div>
</div>
<a class="anchor" id="gafbea29b376b29f11bbfc48a0f5144e9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esSchedYieldIsrI </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force the scheduler invocation which will evaluate all ready threads and switch to ready thread with the highest priority. </p>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state &lt; ES_KERN_INACTIVE</code>, see <a class="el" href="states.html">Kernel states</a>. </dd></dl>
<dl class="section user"><dt>Function class:</dt><dd><b>I class</b>, Interrupt-lock API function, this function can be called only from interrupts locked code sections. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1e60d9df6ad1712ed57cd4ca038fcad2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esSchedLockEnterI </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock the scheduler. </p>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state &lt; ES_KERN_INIT</code>, see <a class="el" href="states.html">Kernel states</a>. </dd></dl>
<dl class="section user"><dt>Function class:</dt><dd><b>I class</b>, Interrupt-lock API function, this function can be called only from interrupts locked code sections. </dd></dl>

</div>
</div>
<a class="anchor" id="gaddd9b2fcbc03765f63f81b64e6663934"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esSchedLockExitI </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock the scheduler. </p>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state &lt; ES_KERN_INIT</code>, see <a class="el" href="states.html">Kernel states</a>. </dd>
<dd>
2) <code>gKernLockCnt &gt; 0U</code>, current number of locks must be greater than zero, in other words: each call to kernel lock function must have its matching call to kernel unlock function. </dd></dl>
<dl class="section user"><dt>Function class:</dt><dd><b>I class</b>, Interrupt-lock API function, this function can be called only from interrupts locked code sections. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4b70a0e213b791b4e51840352d144a22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esSchedLockEnter </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock the scheduler. </p>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state &lt; ES_KERN_INIT</code>, see <a class="el" href="states.html">Kernel states</a>. </dd></dl>
<dl class="section user"><dt>Object class:</dt><dd>Regular <b>API</b> object, this object is part of the application programming interface. </dd></dl>

</div>
</div>
<a class="anchor" id="gac4c263203fcf700d96fe21782cfde219"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esSchedLockExit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock the scheduler. </p>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state &lt; ES_KERN_INIT</code>, see <a class="el" href="states.html">Kernel states</a>. </dd>
<dd>
2) <code>gKernLockCnt &gt; 0U</code>, current number of locks must be greater than zero, in other words: each call to kernel lock function must have its matching call to kernel unlock function. </dd></dl>
<dl class="section user"><dt>Object class:</dt><dd>Regular <b>API</b> object, this object is part of the application programming interface. </dd></dl>

</div>
</div>
<a class="anchor" id="ga45fe650eac73e7fe203cc81565401555"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esVTmrInitI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__kern__intf.html#ga3c020f0ca54ff412bc1d1505502d2afc">esVTmr_T</a> *&#160;</td>
          <td class="paramname"><em>vTmr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__kern__intf.html#ga844873888c186ee81eb66620dadb0451">esTick_T</a>&#160;</td>
          <td class="paramname"><em>tick</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add and start a new virtual timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTmr</td><td>Virtual Timer: is pointer to the timer ID structure, <a class="el" href="structesVTmr.html">esVTmr</a>. </td></tr>
    <tr><td class="paramname">tick</td><td>Tick: the timer delay expressed in system ticks </td></tr>
    <tr><td class="paramname">fn</td><td>Function: is pointer to the callback function </td></tr>
    <tr><td class="paramname">arg</td><td>Argument: is pointer to the arguments of callback function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state &lt; ES_KERN_INACTIVE</code>, see <a class="el" href="states.html">Kernel states</a>. </dd>
<dd>
2) <code>vTmr != NULL</code> </dd>
<dd>
3) <code>vTmr-&gt;signature != VTMR_CONTRACT_SIGNATURE</code>, the timer structure can't be initialized more than once. </dd>
<dd>
4) <code>tick &gt; 1U</code> </dd>
<dd>
5) <code>fn != NULL</code> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>1) <code>vTmr-&gt;signature == VTMR_CONTRACT_SIGNATURE</code>, each <a class="el" href="structesVTmr.html">esVTmr</a> structure will have valid signature after initialization. </dd></dl>
<dl class="section user"><dt>Function class:</dt><dd><b>I class</b>, Interrupt-lock API function, this function can be called only from interrupts locked code sections. </dd></dl>

</div>
</div>
<a class="anchor" id="gad932cf00aec4ba03a0df02ccc493c4c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esVTmrInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__kern__intf.html#ga3c020f0ca54ff412bc1d1505502d2afc">esVTmr_T</a> *&#160;</td>
          <td class="paramname"><em>vTmr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__kern__intf.html#ga844873888c186ee81eb66620dadb0451">esTick_T</a>&#160;</td>
          <td class="paramname"><em>tick</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add and start a new virtual timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTmr</td><td>Virtual Timer: is pointer to the timer ID structure, <a class="el" href="structesVTmr.html">esVTmr</a>. </td></tr>
    <tr><td class="paramname">tick</td><td>Tick: the timer delay expressed in system ticks </td></tr>
    <tr><td class="paramname">fn</td><td>Function: is pointer to the callback function </td></tr>
    <tr><td class="paramname">arg</td><td>Argument: is pointer to the arguments of callback function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state &lt; ES_KERN_INACTIVE</code>, see <a class="el" href="states.html">Kernel states</a>. </dd>
<dd>
2) <code>vTmr != NULL</code> </dd>
<dd>
3) <code>vTmr-&gt;signature != VTMR_CONTRACT_SIGNATURE</code>, the timer structure can't be initialized more than once. </dd>
<dd>
4) <code>tick &gt; 1U</code> </dd>
<dd>
5) <code>fn != NULL</code> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>1) <code>vTmr-&gt;signature == VTMR_CONTRACT_SIGNATURE</code>, each <a class="el" href="structesVTmr.html">esVTmr</a> structure will have valid signature after initialization. </dd></dl>
<dl class="section user"><dt>Object class:</dt><dd>Regular <b>API</b> object, this object is part of the application programming interface. </dd></dl>

</div>
</div>
<a class="anchor" id="ga96bb2c81f649c0305dfd08d1c79b2e37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esVTmrTermI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__kern__intf.html#ga3c020f0ca54ff412bc1d1505502d2afc">esVTmr_T</a> *&#160;</td>
          <td class="paramname"><em>vTmr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel and remove a virtual timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTmr</td><td>Timer: is pointer to the timer ID structure, <a class="el" href="structesVTmr.html">esVTmr</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state &lt; ES_KERN_INACTIVE</code>, see <a class="el" href="states.html">Kernel states</a>. </dd>
<dd>
2) <code>vTmr != NULL</code> </dd>
<dd>
3) <code>vTmr-&gt;signature == VTMR_CONTRACT_SIGNATURE</code>, the pointer must point to a valid <a class="el" href="structesVTmr.html">esVTmr</a> structure. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>1) <code>vTmr-&gt;signature = ~VTMR_CONTRACT_SIGNATURE</code>, each <a class="el" href="structesVTmr.html">esVTmr</a> structure will have invalid signature after termination. </dd></dl>
<dl class="section user"><dt>Function class:</dt><dd><b>I class</b>, Interrupt-lock API function, this function can be called only from interrupts locked code sections. </dd></dl>

</div>
</div>
<a class="anchor" id="gad6ec93a68e3526f18ed926cd441878cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esVTmrTerm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__kern__intf.html#ga3c020f0ca54ff412bc1d1505502d2afc">esVTmr_T</a> *&#160;</td>
          <td class="paramname"><em>vTmr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel and remove a virtual timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTmr</td><td>Timer: is pointer to the timer ID structure, <a class="el" href="structesVTmr.html">esVTmr</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>The kernel state &lt; ES_KERN_INACTIVE</code>, see <a class="el" href="states.html">Kernel states</a>. </dd>
<dd>
2) <code>vTmr != NULL</code> </dd>
<dd>
3) <code>vTmr-&gt;signature == VTMR_CONTRACT_SIGNATURE</code>, the pointer must point to a valid <a class="el" href="structesVTmr.html">esVTmr</a> structure. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>1) <code>vTmr-&gt;signature = ~VTMR_CONTRACT_SIGNATURE</code>, each <a class="el" href="structesVTmr.html">esVTmr</a> structure will have invalid signature after termination. </dd></dl>
<dl class="section user"><dt>Object class:</dt><dd>Regular <b>API</b> object, this object is part of the application programming interface. </dd></dl>

</div>
</div>
<a class="anchor" id="ga26d10c6aaa0cd1d04261d2c9911e890d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esVTmrDelay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__kern__intf.html#ga844873888c186ee81eb66620dadb0451">esTick_T</a>&#160;</td>
          <td class="paramname"><em>tick</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delay for specified amount of ticks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tick</td><td>Tick: number of system ticks to delay.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will create a virtual timer with count down time specified in argument <code>tick</code> and put the calling thread into <code>sleep</code> state. When timeout expires the thread will be placed back into <code>ready</code> state. </p>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>tick &gt; 1U</code> </dd></dl>
<dl class="section user"><dt>Object class:</dt><dd>Regular <b>API</b> object, this object is part of the application programming interface. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9a0d562969acef0121136b11be7b4728"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void userPreSysTmr </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>System timer hook function, called from system system timer ISR function before the kernel functions. </p>
<dl class="section note"><dt>Note</dt><dd>1) This function is called only if <a class="el" href="group__template__kern__cfg.html#gaa130bc9f72010b44b4b06618d8f8d0bc">CFG_HOOK_PRE_SYSTMR_EVENT</a> is active.</dd></dl>
<p>This function is called whenever a system event is generated. </p>

</div>
</div>
<a class="anchor" id="gaac77966856c9a299cda4794cbcc87edf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void userPreKernInit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel initialization hook function, called from <a class="el" href="group__kern__intf.html#ga9e9ff699d62d6035cd51121bb3140704" title="Initialize kernel internal data structures. ">esKernInit()</a> function before kernel initialization. </p>
<dl class="section note"><dt>Note</dt><dd>1) This function is called only if <a class="el" href="group__template__kern__cfg.html#ga4093113f2105d2716f86c6509a6e643a">CFG_HOOK_PRE_KERN_INIT</a> is active.</dd></dl>
<p>This function is called before the kernel initialization. </p>

</div>
</div>
<a class="anchor" id="ga3579ac6964a314ad03d13da0507f57e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void userPostKernInit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel initialization hook function, called from <a class="el" href="group__kern__intf.html#ga9e9ff699d62d6035cd51121bb3140704" title="Initialize kernel internal data structures. ">esKernInit()</a> function after kernel initialization. </p>
<dl class="section note"><dt>Note</dt><dd>1) This function is called only if <a class="el" href="group__template__kern__cfg.html#ga85dea823714335c2ec9e9f7750996e83">CFG_HOOK_POST_KERN_INIT</a> is active.</dd></dl>
<p>This function is called after the kernel initialization. </p>

</div>
</div>
<a class="anchor" id="gaac505ab4c72e0fb346ca441d6def327d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void userPreKernStart </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel start hook function, called from <a class="el" href="group__kern__intf.html#ga0e7a0a6b9c02df58de0f98de0229a09d" title="Start the multi-threading. ">esKernStart()</a> function. </p>
<dl class="section note"><dt>Note</dt><dd>1) This function is called only if <a class="el" href="group__template__kern__cfg.html#gad67d998118375811b0f3e63543311661">CFG_HOOK_PRE_KERN_START</a> is active.</dd></dl>
<p>This function is called before kernel start. </p>

</div>
</div>
<a class="anchor" id="ga64ca864d0ff2aaa532208d7c2b88bdb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void userPostThdInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__kern__intf.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thread initialization end hook function, called from <a class="el" href="group__kern__intf.html#gac91734f3ee867b519f59bf81cc7fde88" title="Initialize the specified thread. ">esThdInit()</a> function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread: pointer to thread Id structure that has just been initialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>1) This function is called only if <a class="el" href="group__template__kern__cfg.html#ga23deae306171d1a8dda4d0e33efdb6bb">CFG_HOOK_POST_THD_INIT</a> is active.</dd></dl>
<p>This function is called after the thread initialization. </p>

</div>
</div>
<a class="anchor" id="ga076ad76633999c9d5e245e3b5c6e0c09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void userPreThdTerm </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thread terminate hook function, called from <a class="el" href="group__kern__intf.html#gac9d1eac76f26096614e8196bcfd8b905" title="Terminate the specified thread. ">esThdTerm()</a> or when a thread terminates itself. </p>
<dl class="section note"><dt>Note</dt><dd>1) This function is called only if <a class="el" href="group__template__kern__cfg.html#ga9c7dd4e009a89e9cffb0f9b404bc6250">CFG_HOOK_PRE_THD_TERM</a> is active. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2bd40d82f768787c3dab2f4df336685e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void userPreIdle </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pre Idle hook function, called from idle thread, just before entering idle period. </p>
<dl class="section note"><dt>Note</dt><dd>1) This function is called only if <a class="el" href="group__template__kern__cfg.html#ga7c2b0410404256c4804758090401f7e4">CFG_HOOK_PRE_IDLE</a> and <a class="el" href="group__template__kern__cfg.html#ga4e6ab4994b34501bb71e75717b093376">CFG_SCHED_POWER_SAVE</a> are active. </dd>
<dd>
2) This function is called with interrupts and scheduler locked. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7ca4a96cbe5064d633298d1d172fd4e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void userPostIdle </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post idle hook function, called from idle thread, just after exiting idle period. </p>
<dl class="section note"><dt>Note</dt><dd>1) This function is called only if <a class="el" href="group__template__kern__cfg.html#ga8f8751efe94964bef25673deca6b9b26">CFG_HOOK_POST_IDLE</a> and <a class="el" href="group__template__kern__cfg.html#ga4e6ab4994b34501bb71e75717b093376">CFG_SCHED_POWER_SAVE</a> are active. </dd>
<dd>
2) This function is called with scheduler locked. </dd></dl>

</div>
</div>
<a class="anchor" id="ga74a38c965110d0f2f2e44e13571fe3fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void userPreCtxSw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__kern__intf.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *&#160;</td>
          <td class="paramname"><em>oldThd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__kern__intf.html#ga62e3a3ca0a4597a19c43cb8868810d82">esThd_T</a> *&#160;</td>
          <td class="paramname"><em>newThd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel context switch hook function, called from <a class="el" href="group__kern__intf.html#gaf90e487bfce974dafaeed5009e189810" title="Force the scheduler invocation which will evaluate all ready threads and switch to ready thread with ...">esSchedYieldI()</a> and <a class="el" href="group__kern__intf.html#gafbea29b376b29f11bbfc48a0f5144e9a" title="Force the scheduler invocation which will evaluate all ready threads and switch to ready thread with ...">esSchedYieldIsrI()</a> functions just before context switch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldThd</td><td>Pointer to the thread being switched out. </td></tr>
    <tr><td class="paramname">newThd</td><td>Pointer to the thread being switched in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>1) This function is called only if <a class="el" href="group__template__kern__cfg.html#gac84acbf84222018398089920dd429635">CFG_HOOK_PRE_CTX_SW</a> is active.</dd></dl>
<p>This function is called at each context switch. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga299ac766f155bf1ef931627e2a0b895b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const volatile <a class="el" href="group__kern__intf.html#gaae54a9918d92a2105b1d331b083d21b7">esKernCtrl_T</a> gKernCtrl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel control block. </p>
<dl class="section note"><dt>Note</dt><dd>This variable has Read-Only access rights for application.</dd></dl>
<p>Kernel control block. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
