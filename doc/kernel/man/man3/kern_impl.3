.TH "Internals" 3 "Tue Oct 29 2013" "Version 1.0BetaR01" "eSolid - Real-Time Kernel" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Internals \- 
.PP
Kernel inner work\&.  

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBsysTmr\fP"
.br
.RI "\fIMain System Timer structure\&. \fP"
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBPRIO_BM_DATA_WIDTH_LOG2\fP"
.br
.RI "\fIPriority Bit Map log base 2: \fClog2(PORT_DEF_DATA_WIDTH)\fP \fP"
.ti -1c
.RI "#define \fBSCHED_STATE_INTSRV_MSK\fP   (1u << 0)"
.br
.RI "\fIKernel state variable bit position which defines if the kernel is in interrupt servicing state\&. \fP"
.ti -1c
.RI "#define \fBSCHED_STATE_LOCK_MSK\fP   (1u << 1)"
.br
.RI "\fIKernel state variable bit position which defines if the kernel is locked or not\&. \fP"
.ti -1c
.RI "#define \fBPORT_DEF_SYSTMR_ONE_TICK\fP   (\fBCFG_SYSTMR_CLOCK_FREQUENCY\fP / \fBCFG_SYSTMR_EVENT_FREQUENCY\fP)"
.br
.RI "\fISystem timer one tick value\&. \fP"
.ti -1c
.RI "#define \fBTHD_CONTRACT_SIGNATURE\fP   ((\fBportReg_T\fP)0xFEEDBEEFUL)"
.br
.RI "\fIThread structure signature\&. \fP"
.ti -1c
.RI "#define \fBTHDQ_CONTRACT_SIGNATURE\fP   ((\fBportReg_T\fP)0xFEEDBEEEUL)"
.br
.RI "\fIThread Queue structure signature\&. \fP"
.ti -1c
.RI "#define \fBVTMR_CONTRACT_SIGNATURE\fP   ((\fBportReg_T\fP)0xFEEDBCCCUL)"
.br
.RI "\fITimer structure signature\&. \fP"
.ti -1c
.RI "#define \fBDLIST_IS_ENTRY_FIRST\fP(list, entry)   ((entry) == (entry)->list\&.next)"
.br
.RI "\fIDList macro: is the thread the first one in the list\&. \fP"
.ti -1c
.RI "#define \fBDLIST_IS_ENTRY_LAST\fP(list, entry)   \fBDLIST_IS_ENTRY_FIRST\fP(list, entry)"
.br
.RI "\fIDList macro: is the thread the last one in the list\&. \fP"
.ti -1c
.RI "#define \fBDLIST_IS_ENTRY_SINGLE\fP(list, entry)   \fBDLIST_IS_ENTRY_FIRST\fP(list, entry)"
.br
.RI "\fIDList macro: is the thread single in the list\&. \fP"
.ti -1c
.RI "#define \fBDLIST_ENTRY_NEXT\fP(list, entry)   (entry)->list\&.next"
.br
.RI "\fIDList macro: get the next entry\&. \fP"
.ti -1c
.RI "#define \fBDLIST_ENTRY_INIT\fP(list, entry)"
.br
.RI "\fIDList macro: initialize entry\&. \fP"
.ti -1c
.RI "#define \fBDLIST_ENTRY_ADD_AFTER\fP(list, current, entry)"
.br
.RI "\fIDList macro: add new \fCentry\fP after \fCcurrent\fP entry\&. \fP"
.ti -1c
.RI "#define \fBDLIST_ENTRY_RM\fP(list, entry)"
.br
.RI "\fIDList macro: remove the \fCentry\fP from a list\&. \fP"
.ti -1c
.RI "#define \fBPORT_SYSTMR_WAKEUP_TH_VAL\fP   600U"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBDECL_MODULE_INFO\fP ('Kernel','eSolid RT Kernel','Nenad Radulovic')"
.br
.ti -1c
.RI "void \fBesKernInit\fP (void)"
.br
.RI "\fIInitialize kernel internal data structures\&. \fP"
.ti -1c
.RI "PORT_C_NORETURN void \fBesKernStart\fP (void)"
.br
.RI "\fIStart the multi-threading\&. \fP"
.ti -1c
.RI "void \fBesKernSysTmr\fP (void)"
.br
.RI "\fIProcess the system timer event\&. \fP"
.ti -1c
.RI "void \fBesKernIsrPrologueI\fP (void)"
.br
.RI "\fIEnter Interrupt Service Routine\&. \fP"
.ti -1c
.RI "void \fBesKernIsrEpilogueI\fP (void)"
.br
.RI "\fIExit Interrupt Service Routine\&. \fP"
.ti -1c
.RI "void \fBesThdInit\fP (\fBesThd_T\fP *thd, void(*fn)(void *), void *arg, \fBportStck_T\fP *stck, size_t stckSize, uint8_t prio)"
.br
.RI "\fIInitialize the specified thread\&. \fP"
.ti -1c
.RI "void \fBesThdTerm\fP (\fBesThd_T\fP *thd)"
.br
.RI "\fITerminate the specified thread\&. \fP"
.ti -1c
.RI "void \fBesThdSetPrioI\fP (\fBesThd_T\fP *thd, uint8_t prio)"
.br
.RI "\fISet the priority of a thread\&. \fP"
.ti -1c
.RI "void \fBesThdPostI\fP (\fBesThd_T\fP *thd)"
.br
.RI "\fIPost to thread semaphore\&. \fP"
.ti -1c
.RI "void \fBesThdPost\fP (\fBesThd_T\fP *thd)"
.br
.RI "\fIPost to thread semaphore\&. \fP"
.ti -1c
.RI "void \fBesThdWaitI\fP (void)"
.br
.RI "\fIWait for thread semaphore\&. \fP"
.ti -1c
.RI "void \fBesThdWait\fP (void)"
.br
.RI "\fIWait for thread semaphore\&. \fP"
.ti -1c
.RI "void \fBesThdQInit\fP (\fBesThdQ_T\fP *thdQ)"
.br
.RI "\fIInitialize Thread Queue\&. \fP"
.ti -1c
.RI "void \fBesThdQTerm\fP (\fBesThdQ_T\fP *thdQ)"
.br
.RI "\fITerminate Thread Queue\&. \fP"
.ti -1c
.RI "void \fBesThdQAddI\fP (\fBesThdQ_T\fP *thdQ, \fBesThd_T\fP *thd)"
.br
.RI "\fIAdd a thread to the Thread Queue\&. \fP"
.ti -1c
.RI "void \fBesThdQRmI\fP (\fBesThdQ_T\fP *thdQ, \fBesThd_T\fP *thd)"
.br
.RI "\fIRemoves the thread from the Thread Queue\&. \fP"
.ti -1c
.RI "\fBesThd_T\fP * \fBesThdQFetchI\fP (const \fBesThdQ_T\fP *thdQ)"
.br
.RI "\fIFetch the first high priority thread from the Thread Queue\&. \fP"
.ti -1c
.RI "\fBesThd_T\fP * \fBesThdQFetchRotateI\fP (\fBesThdQ_T\fP *thdQ, uint_fast8_t prio)"
.br
.RI "\fIFetch the next thread and rotate thread linked list\&. \fP"
.ti -1c
.RI "\fBbool_T\fP \fBesThdQIsEmpty\fP (const \fBesThdQ_T\fP *thdQ)"
.br
.RI "\fIIs thread queue empty\&. \fP"
.ti -1c
.RI "void \fBesSchedRdyAddI\fP (\fBesThd_T\fP *thd)"
.br
.RI "\fIAdd thread \fCthd\fP to the ready thread list and notify the scheduler\&. \fP"
.ti -1c
.RI "void \fBesSchedRdyRmI\fP (\fBesThd_T\fP *thd)"
.br
.RI "\fIRemove thread \fCthd\fP from the ready thread list and notify the scheduler\&. \fP"
.ti -1c
.RI "void \fBesSchedYieldI\fP (void)"
.br
.RI "\fIForce the scheduler invocation which will evaluate all ready threads and switch to ready thread with the highest priority\&. \fP"
.ti -1c
.RI "void \fBesSchedYieldIsrI\fP (void)"
.br
.RI "\fIForce the scheduler invocation which will evaluate all ready threads and switch to ready thread with the highest priority\&. \fP"
.ti -1c
.RI "void \fBesSchedLockEnterI\fP (void)"
.br
.RI "\fILock the scheduler\&. \fP"
.ti -1c
.RI "void \fBesSchedLockExitI\fP (void)"
.br
.RI "\fIUnlock the scheduler\&. \fP"
.ti -1c
.RI "void \fBesSchedLockEnter\fP (void)"
.br
.RI "\fILock the scheduler\&. \fP"
.ti -1c
.RI "void \fBesSchedLockExit\fP (void)"
.br
.RI "\fIUnlock the scheduler\&. \fP"
.ti -1c
.RI "void \fBesVTmrInitI\fP (\fBesVTmr_T\fP *vTmr, \fBesTick_T\fP tick, void(*fn)(void *), void *arg)"
.br
.RI "\fIAdd and start a new virtual timer\&. \fP"
.ti -1c
.RI "void \fBesVTmrInit\fP (\fBesVTmr_T\fP *vTmr, \fBesTick_T\fP tick, void(*fn)(void *), void *arg)"
.br
.RI "\fIAdd and start a new virtual timer\&. \fP"
.ti -1c
.RI "void \fBesVTmrTermI\fP (\fBesVTmr_T\fP *vTmr)"
.br
.RI "\fICancel and remove a virtual timer\&. \fP"
.ti -1c
.RI "void \fBesVTmrTerm\fP (\fBesVTmr_T\fP *vTmr)"
.br
.RI "\fICancel and remove a virtual timer\&. \fP"
.ti -1c
.RI "void \fBesVTmrDelay\fP (\fBesTick_T\fP tick)"
.br
.RI "\fIDelay for specified amount of ticks\&. \fP"
.ti -1c
.RI "\fBesTick_T\fP \fBesSysTmrTickGet\fP (void)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "static uint_fast8_t \fBgKernLockCnt\fP"
.br
.RI "\fIKernel Lock Counter\&. \fP"
.ti -1c
.RI "const volatile \fBesKernCtrl_T\fP \fBgKernCtrl\fP"
.br
.RI "\fIKernel control initialization\&. \fP"
.in -1c
.SS "System timer"

.in +1c
.ti -1c
.RI "typedef struct \fBsysTmr\fP \fBsysTmr_T\fP"
.br
.RI "\fISystem Timer type\&. \fP"
.ti -1c
.RI "static \fBsysTmr_T\fP \fBgSysTmr\fP"
.br
.RI "\fIMain System Timer structure\&. \fP"
.ti -1c
.RI "static \fBesVTmr_T\fP \fBgVTmrArmed\fP"
.br
.RI "\fIList of virtual timers to armed expire\&. \fP"
.ti -1c
.RI "static \fBesVTmr_T\fP \fBgVTmrPend\fP"
.br
.RI "\fIVirtual timers pending to be inserted into waiting list\&. \fP"
.ti -1c
.RI "static \fBesThd_T\fP \fBgKVTmr\fP"
.br
.RI "\fIVirtual timer thread ID\&. \fP"
.ti -1c
.RI "static \fBPORT_C_INLINE\fP void \fBsysTmrInit\fP (void)"
.br
.RI "\fIInitialize system timer hardware\&. \fP"
.ti -1c
.RI "static \fBPORT_C_INLINE\fP void \fBsysTmrActivate\fP (void)"
.br
.RI "\fITry to activate system timer\&. \fP"
.ti -1c
.RI "static \fBPORT_C_INLINE\fP void \fBsysTmrDeactivateI\fP (void)"
.br
.RI "\fITry to deactivate system timer\&. \fP"
.in -1c
.SS "Priority Bit Map"

.in +1c
.ti -1c
.RI "typedef struct prioBM \fBprioBM_T\fP"
.br
.RI "\fIPriority Bit Map type\&. \fP"
.ti -1c
.RI "static \fBPORT_C_INLINE\fP void \fBprioBMInit\fP (\fBprioBM_T\fP *bm)"
.br
.RI "\fIInitialize bitmap\&. \fP"
.ti -1c
.RI "static \fBPORT_C_INLINE\fP void \fBprioBMSet\fP (\fBprioBM_T\fP *bm, uint_fast8_t prio)"
.br
.RI "\fISet the bit corresponding to the prio argument\&. \fP"
.ti -1c
.RI "static \fBPORT_C_INLINE\fP void \fBprioBMClear\fP (\fBprioBM_T\fP *bm, uint_fast8_t prio)"
.br
.RI "\fIClear the bit corresponding to the prio argument\&. \fP"
.ti -1c
.RI "static \fBPORT_C_INLINE\fP uint_fast8_t \fBprioBMGet\fP (const \fBprioBM_T\fP *bm)"
.br
.RI "\fIGet the highest priority set\&. \fP"
.ti -1c
.RI "static \fBPORT_C_INLINE\fP \fBbool_T\fP \fBprioBMIsEmpty\fP (const \fBprioBM_T\fP *bm)"
.br
.RI "\fIIs bit map empty? \fP"
.in -1c
.SS "Threads Queue"

.in +1c
.ti -1c
.RI "typedef struct thdLSentinel \fBthdLSentinel_T\fP"
.br
.RI "\fIThread list sentinel type\&. \fP"
.in -1c
.SS "Scheduler"

.in +1c
.ti -1c
.RI "static \fBesThdQ_T\fP \fBgRdyQueue\fP"
.br
.RI "\fIReady Thread queue\&. \fP"
.ti -1c
.RI "static \fBPORT_C_INLINE\fP void \fBschedInit\fP (void)"
.br
.RI "\fIInitialize Ready Thread Queue structure \fBgRdyQueue\fP and Kernel control structure \fBesKernCtrl\fP\&. \fP"
.ti -1c
.RI "static \fBPORT_C_INLINE\fP void \fBschedStart\fP (void)"
.br
.RI "\fISet the scheduler data structures for multi-threading\&. \fP"
.ti -1c
.RI "static \fBPORT_C_INLINE\fP void \fBschedSleep\fP (void)"
.br
.RI "\fISet the scheduler to sleep\&. \fP"
.ti -1c
.RI "static \fBPORT_C_INLINE\fP void \fBschedWakeUpI\fP (void)"
.br
.RI "\fIWake up the scheduler\&. \fP"
.ti -1c
.RI "static \fBPORT_C_INLINE\fP void \fBschedRdyAddInitI\fP (\fBesThd_T\fP *thd)"
.br
.RI "\fIInitialize scheduler ready structure during the thread add operation\&. \fP"
.ti -1c
.RI "static \fBPORT_C_INLINE\fP void \fBschedQmNextI\fP (void)"
.br
.RI "\fIFetch and try to schedule the next thread of the same priority as the current thread\&. \fP"
.ti -1c
.RI "static \fBPORT_C_INLINE\fP void \fBschedQmI\fP (void)"
.br
.RI "\fIDo the Quantum (Round-Robin) scheduling\&. \fP"
.in -1c
.SS "Virtual Timer and Virtual Timer kernel thread"

.in +1c
.ti -1c
.RI "static \fBPORT_C_INLINE\fP void \fBvTmrSleep\fP (\fBesTick_T\fP ticks)"
.br
.RI "\fISet up system timer for different tick period during sleeping\&. \fP"
.ti -1c
.RI "static \fBPORT_C_INLINE\fP void \fBvTmrEvaluateI\fP (void)"
.br
.RI "\fIEvaluate armed virtual timers\&. \fP"
.ti -1c
.RI "static void \fBvTmrAddArmedS\fP (\fBesVTmr_T\fP *vTmr)"
.br
.RI "\fIAdd a virtual timer into sorted list\&. \fP"
.ti -1c
.RI "static \fBPORT_C_INLINE\fP void \fBvTmrImportPendSleepI\fP (void)"
.br
.RI "\fIImport timers from pending list to armed list\&. \fP"
.ti -1c
.RI "static void \fBvTmrImportPend\fP (void)"
.br
.RI "\fIImport timers from pending list to armed list\&. \fP"
.ti -1c
.RI "static void \fBkVTmrInit\fP (void)"
.br
.RI "\fIInitialization of Virtual Timer kernel thread\&. \fP"
.ti -1c
.RI "static void \fBkVTmr\fP (void *arg)"
.br
.RI "\fIVirtual Timer thread code\&. \fP"
.in -1c
.SS "Idle kernel thread"

.in +1c
.ti -1c
.RI "static \fBesThd_T\fP \fBgKIdle\fP"
.br
.RI "\fIIdle thread ID\&. \fP"
.ti -1c
.RI "static void \fBkIdleInit\fP (void)"
.br
.RI "\fIInitialization of Idle thread\&. \fP"
.ti -1c
.RI "static void \fBkIdle\fP (void *arg)"
.br
.RI "\fIIdle thread code\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
Kernel inner work\&. 


.SH "Macro Definition Documentation"
.PP 
.SS "#define PRIO_BM_DATA_WIDTH_LOG2"
\fBValue:\fP
.PP
.nf
(PORT_DEF_DATA_WIDTH <   2u ? 0u :                                          \
     (PORT_DEF_DATA_WIDTH <   4u ? 1u :                                         \
      (PORT_DEF_DATA_WIDTH <   8u ? 2u :                                        \
       (PORT_DEF_DATA_WIDTH <  16u ? 3u :                                       \
        (PORT_DEF_DATA_WIDTH <  32u ? 4u :                                      \
         (PORT_DEF_DATA_WIDTH <  64u ? 5u :                                     \
          (PORT_DEF_DATA_WIDTH < 128u ? 6u : 7u)))))))
.fi
.PP
Priority Bit Map log base 2: \fClog2(PORT_DEF_DATA_WIDTH)\fP 
.SS "#define SCHED_STATE_INTSRV_MSK   (1u << 0)"

.PP
Kernel state variable bit position which defines if the kernel is in interrupt servicing state\&. 
.SS "#define SCHED_STATE_LOCK_MSK   (1u << 1)"

.PP
Kernel state variable bit position which defines if the kernel is locked or not\&. 
.SS "#define PORT_DEF_SYSTMR_ONE_TICK   (\fBCFG_SYSTMR_CLOCK_FREQUENCY\fP / \fBCFG_SYSTMR_EVENT_FREQUENCY\fP)"

.PP
System timer one tick value\&. 
.SS "#define THD_CONTRACT_SIGNATURE   ((\fBportReg_T\fP)0xFEEDBEEFUL)"

.PP
Thread structure signature\&. The signature is used to confirm that a structure passed to a kernel function is indeed a esThd_T thread structure\&. 
.SS "#define THDQ_CONTRACT_SIGNATURE   ((\fBportReg_T\fP)0xFEEDBEEEUL)"

.PP
Thread Queue structure signature\&. The signature is used to confirm that a structure passed to a kernel function is indeed a esThdQ_T thread queue structure\&. 
.SS "#define VTMR_CONTRACT_SIGNATURE   ((\fBportReg_T\fP)0xFEEDBCCCUL)"

.PP
Timer structure signature\&. The signature is used to confirm that a structure passed to a timer function is indeed a esVTmr_T timer structure\&. 
.SS "#define DLIST_IS_ENTRY_FIRST(list, entry)   ((entry) == (entry)->list\&.next)"

.PP
DList macro: is the thread the first one in the list\&. 
.SS "#define DLIST_IS_ENTRY_LAST(list, entry)   \fBDLIST_IS_ENTRY_FIRST\fP(list, entry)"

.PP
DList macro: is the thread the last one in the list\&. 
.SS "#define DLIST_IS_ENTRY_SINGLE(list, entry)   \fBDLIST_IS_ENTRY_FIRST\fP(list, entry)"

.PP
DList macro: is the thread single in the list\&. 
.SS "#define DLIST_ENTRY_NEXT(list, entry)   (entry)->list\&.next"

.PP
DList macro: get the next entry\&. 
.SS "#define DLIST_ENTRY_INIT(list, entry)"
\fBValue:\fP
.PP
.nf
do {                                                                        \
        (entry)->list\&.next = (entry);                                           \
        (entry)->list\&.prev = (entry);                                           \
    } while (0u)
.fi
.PP
DList macro: initialize entry\&. 
.SS "#define DLIST_ENTRY_ADD_AFTER(list, current, entry)"
\fBValue:\fP
.PP
.nf
do {                                                                        \
        (entry)->list\&.next = (current);                                         \
        (entry)->list\&.prev = (entry)->list\&.next->list\&.prev;                     \
        (entry)->list\&.next->list\&.prev = (entry);                                \
        (entry)->list\&.prev->list\&.next = (entry);                                \
    } while (0u)
.fi
.PP
DList macro: add new \fCentry\fP after \fCcurrent\fP entry\&. 
.SS "#define DLIST_ENTRY_RM(list, entry)"
\fBValue:\fP
.PP
.nf
do {                                                                        \
        (entry)->list\&.next->list\&.prev = (entry)->list\&.prev;                     \
        (entry)->list\&.prev->list\&.next = (entry)->list\&.next;                     \
    } while (0u)
.fi
.PP
DList macro: remove the \fCentry\fP from a list\&. 
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fBsysTmr\fP \fBsysTmr_T\fP"

.PP
System Timer type\&. 
.SS "typedef struct prioBM \fBprioBM_T\fP"

.PP
Priority Bit Map type\&. 
.SS "typedef struct thdLSentinel \fBthdLSentinel_T\fP"

.PP
Thread list sentinel type\&. 
.SH "Function Documentation"
.PP 
.SS "static \fBPORT_C_INLINE\fP void prioBMInit (\fBprioBM_T\fP *bm)\fC [static]\fP"

.PP
Initialize bitmap\&. 
.PP
\fBParameters:\fP
.RS 4
\fIbm\fP Pointer to the bit map structure 
.RE
.PP

.SS "static \fBPORT_C_INLINE\fP void prioBMSet (\fBprioBM_T\fP *bm, uint_fast8_tprio)\fC [static]\fP"

.PP
Set the bit corresponding to the prio argument\&. 
.PP
\fBParameters:\fP
.RS 4
\fIbm\fP Pointer to the bit map structure 
.br
\fIprio\fP Priority which will be marked as used 
.RE
.PP

.SS "static \fBPORT_C_INLINE\fP void prioBMClear (\fBprioBM_T\fP *bm, uint_fast8_tprio)\fC [static]\fP"

.PP
Clear the bit corresponding to the prio argument\&. 
.PP
\fBParameters:\fP
.RS 4
\fIbm\fP Pointer to the bit map structure 
.br
\fIprio\fP Priority which will be marked as unused 
.RE
.PP

.SS "static \fBPORT_C_INLINE\fP uint_fast8_t prioBMGet (const \fBprioBM_T\fP *bm)\fC [static]\fP"

.PP
Get the highest priority set\&. 
.PP
\fBParameters:\fP
.RS 4
\fIbm\fP Pointer to the bit map structure 
.RE
.PP
\fBReturns:\fP
.RS 4
The number of the highest priority marked as used 
.RE
.PP

.SS "static \fBPORT_C_INLINE\fP \fBbool_T\fP prioBMIsEmpty (const \fBprioBM_T\fP *bm)\fC [static]\fP"

.PP
Is bit map empty? 
.PP
\fBParameters:\fP
.RS 4
\fIbm\fP Pointer to the bit map structure 
.RE
.PP
\fBReturns:\fP
.RS 4
The status of the bit map 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fITRUE\fP - bit map is empty 
.br
\fIFALSE\fP - there is at least one bit set 
.RE
.PP

.SS "static \fBPORT_C_INLINE\fP void schedInit (void)\fC [static]\fP"

.PP
Initialize Ready Thread Queue structure \fBgRdyQueue\fP and Kernel control structure \fBesKernCtrl\fP\&. 
.SS "static \fBPORT_C_INLINE\fP void schedStart (void)\fC [static]\fP"

.PP
Set the scheduler data structures for multi-threading\&. This function is called just before multi-threading will start\&. 
.SS "static \fBPORT_C_INLINE\fP void schedSleep (void)\fC [static]\fP"

.PP
Set the scheduler to sleep\&. 
.PP
\fBNote:\fP
.RS 4
This function is used only when \fBCFG_SCHED_POWER_SAVE\fP option is active\&. 
.RE
.PP

.SS "static \fBPORT_C_INLINE\fP void schedWakeUpI (void)\fC [static]\fP"

.PP
Wake up the scheduler\&. 
.PP
\fBNote:\fP
.RS 4
This function is used only when \fBCFG_SCHED_POWER_SAVE\fP option is active\&. 
.RE
.PP

.SS "static \fBPORT_C_INLINE\fP void schedRdyAddInitI (\fBesThd_T\fP *thd)\fC [static]\fP"

.PP
Initialize scheduler ready structure during the thread add operation\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthd\fP Pointer to the thread currently being initialized\&.
.RE
.PP
Function will initialize scheduler structures during the init phase of the kernel\&. 
.SS "static \fBPORT_C_INLINE\fP void schedQmNextI (void)\fC [static]\fP"

.PP
Fetch and try to schedule the next thread of the same priority as the current thread\&. 
.SS "static \fBPORT_C_INLINE\fP void schedQmI (void)\fC [static]\fP"

.PP
Do the Quantum (Round-Robin) scheduling\&. 
.SS "static \fBPORT_C_INLINE\fP void sysTmrInit (void)\fC [static]\fP"

.PP
Initialize system timer hardware\&. 
.SS "static \fBPORT_C_INLINE\fP void sysTmrActivate (void)\fC [static]\fP"

.PP
Try to activate system timer\&. 
.PP
\fBNote:\fP
.RS 4
This function is used only when \fBCFG_SYSTMR_ADAPTIVE_MODE\fP option is active\&. 
.RE
.PP

.SS "static \fBPORT_C_INLINE\fP void sysTmrDeactivateI (void)\fC [static]\fP"

.PP
Try to deactivate system timer\&. 
.PP
\fBNote:\fP
.RS 4
This function is used only when \fBCFG_SYSTMR_ADAPTIVE_MODE\fP option is active\&. 
.RE
.PP

.SS "static \fBPORT_C_INLINE\fP void vTmrSleep (\fBesTick_T\fPticks)\fC [static]\fP"

.PP
Set up system timer for different tick period during sleeping\&. 
.PP
\fBParameters:\fP
.RS 4
\fIticks\fP Number of ticks to sleep 
.RE
.PP
\fBNote:\fP
.RS 4
This function is used only when \fBCFG_SYSTMR_ADAPTIVE_MODE\fP option is active\&. 
.RE
.PP

.SS "static \fBPORT_C_INLINE\fP void vTmrEvaluateI (void)\fC [static]\fP"

.PP
Evaluate armed virtual timers\&. 
.SS "static void vTmrAddArmedS (\fBesVTmr_T\fP *vTmr)\fC [static]\fP"

.PP
Add a virtual timer into sorted list\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvTmr\fP Virtual timer: pointer to virtual timer to add 
.RE
.PP

.SS "static \fBPORT_C_INLINE\fP void vTmrImportPendSleepI (void)\fC [static]\fP"

.PP
Import timers from pending list to armed list\&. 
.PP
\fBNote:\fP
.RS 4
This function is used only when \fBCFG_SYSTMR_ADAPTIVE_MODE\fP option is active\&. 
.RE
.PP

.SS "static void vTmrImportPend (void)\fC [static]\fP"

.PP
Import timers from pending list to armed list\&. 
.SS "static void kVTmrInit (void)\fC [static]\fP"

.PP
Initialization of Virtual Timer kernel thread\&. 
.SS "static void kVTmr (void *arg)\fC [static]\fP"

.PP
Virtual Timer thread code\&. 
.PP
\fBParameters:\fP
.RS 4
\fIarg\fP Argument: thread does not use argument
.RE
.PP
This thread is responsible for virtual timer callback invocation and to import pending timers into armed linked list\&. 
.SS "static void kIdleInit (void)\fC [static]\fP"

.PP
Initialization of Idle thread\&. 
.SS "static void kIdle (void *arg)\fC [static]\fP"

.PP
Idle thread code\&. 
.PP
\fBParameters:\fP
.RS 4
\fIarg\fP Argument: thread does not use argument 
.RE
.PP

.SS "void esKernInit (void)"

.PP
Initialize kernel internal data structures\&. 
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state == ES_KERN_INACTIVE\fP, see \fBKernel states\fP\&. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
1) \fCThe kernel state == ES_KERN_INIT\fP\&. 
.RE
.PP
\fBNote:\fP
.RS 4
1) This function may be invoked only once\&.
.RE
.PP
This function must be called first before any other kernel API\&. It initializes internal data structures that are used by other API functions\&. 
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application initialization code 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
never 
.PP
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SS "PORT_C_NORETURN void esKernStart (void)"

.PP
Start the multi-threading\&. 
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state == ES_KERN_INIT\fP, see \fBKernel states\fP\&. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
1) \fCThe kernel state == ES_KERN_RUN\fP 
.PP
2) The multi-threading execution will commence\&. 
.RE
.PP
\fBNote:\fP
.RS 4
1) Once this function is called the execution of threads will start and this function will never return\&.
.RE
.PP
This function will start multi-threading\&. Once the multi-threading has started the execution will never return to this function again (this function never returns)\&. 
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application initialization code 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
always 
.PP
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SS "void esKernSysTmr (void)"

.PP
Process the system timer event\&. 
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INIT\fP, see \fBKernel states\fP\&.
.RE
.PP
This function will be called only by port system timer interrupt\&. 
.PP
\fBObject class:\fP
.RS 4
\fBNot API\fP object, this object is not part of the application programming interface and it is intended for internal use only\&. 
.RE
.PP

.SS "void esKernIsrPrologueI (void)"

.PP
Enter Interrupt Service Routine\&. 
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INIT\fP, see \fBKernel states\fP\&. 
.RE
.PP
\fBNote:\fP
.RS 4
1) You must call \fBesKernIsrEpilogueI()\fP at the exit of ISR\&. 
.PP
2) You must invoke \fBesKernIsrPrologueI()\fP and \fBesKernIsrEpilogueI()\fP in pair\&. In other words, for every call to \fBesKernIsrPrologueI()\fP at the beginning of the ISR you must have a call to \fBesKernIsrEpilogueI()\fP at the end of the ISR\&.
.RE
.PP
Function will notify kernel that you are about to enter interrupt service routine (ISR)\&. This allows kernel to keep track of interrupt nesting and then only perform rescheduling at the last nested ISR\&. 
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Interrupt service routine 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
never 
.PP
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "void esKernIsrEpilogueI (void)"

.PP
Exit Interrupt Service Routine\&. 
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INIT\fP, see \fBKernel states\fP\&. 
.RE
.PP
\fBNote:\fP
.RS 4
1) You must invoke \fBesKernIsrPrologueI()\fP and \fBesKernIsrEpilogueI()\fP in pair\&. In other words, for every call to \fBesKernIsrPrologueI()\fP at the beginning of the ISR you must have a call to \fBesKernIsrEpilogueI()\fP at the end of the ISR\&. 
.PP
2) Rescheduling is prevented when the scheduler is locked (see \fBesSchedLockEnterI()\fP)
.RE
.PP
This function is used to notify kernel that you have completed servicing an interrupt\&. When the last nested ISR has completed, the function will call the scheduler to determine whether a new, high-priority task, is ready to run\&. 
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Interrupt service routine 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
possible 
.PP
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "void esThdInit (\fBesThd_T\fP *thd, void(*)(void *)fn, void *arg, \fBportStck_T\fP *stck, size_tstckSize, uint8_tprio)"

.PP
Initialize the specified thread\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthd\fP Thread: is a pointer to the thread structure, \fBesThd\fP\&. The structure will be used as information container for the thread\&. It is assumed that storage for the \fC\fBesThd\fP\fP structure is allocated by the user code\&. 
.br
\fIfn\fP Function: is a pointer to thread function\&. Thread function must have the following signature: \fCvoid thread (void * arg)\fP\&. 
.br
\fIarg\fP Argument: is a void pointer to an optional data area\&. It's usage is application defined and it is intended to pass arguments to thread when it is started for the first time\&. 
.br
\fIstck\fP Stack: is a pointer to a allocated memory for thread stack\&. The pointer always points to the first element in the array, regardless of what type of stack the CPU is using\&. The thread's stack is used to store local variables, function parameters, return addresses\&. Each thread has its own stack and different sized stack\&. The stack type must be an array of \fBportStck\fP\&. 
.br
\fIstckSize\fP Stack Size: specifies the size of allocated stack memory\&. Size is expressed in bytes\&. Please see port documentation about minimal stack size\&. Usage of C unary operator \fCsizeof\fP is the recommended way of specifying stack size\&. 
.br
\fIprio\fP Priority: is the priority of the thread\&. The higher the number, the higher the priority (the importance) of the thread\&. Several threads can have the same priority\&. Note that lowest (0) and highest (CFG_SCHED_PRIO_LVL - 1) levels are reserved for kernel threads only\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state ES_KERN_INACTIVE\fP, see \fBKernel states\fP\&. 
.PP
2) \fCthd != NULL\fP 
.PP
3) \fCthd->signature != THD_CONTRACT_SIGNATURE\fP, the thread structure can't be initialized more than once\&. 
.PP
4) \fCfn != NULL\fP 
.PP
5) \fCstckSize >= PORT_DEF_STCK_MINSIZE\fP, see \fBPORT_DEF_STCK_MINSIZE\fP\&. 
.PP
6) \fC0 < prio < CFG_SCHED_PRIO_LVL - 1\fP, see \fBCFG_SCHED_PRIO_LVL\fP\&. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
1) \fCthd->signature == THD_CONTRACT_SIGNATURE\fP, each \fBesThd\fP structure will have valid signature after initialization\&.
.RE
.PP
Threads must be created in order for kernel to recognize them as threads\&. Initialize a thread by calling \fBesThdInit()\fP and provide arguments specifying to kernel how the thread will be managed\&. Threads are always created in the \fCready-to-run\fP state\&. Threads can be created either prior to the start of multi-threading (before calling \fBesKernStart()\fP), or by a running thread\&. 
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application initialization code
.IP "\(bu" 2
Application thread code 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
possible 
.PP
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SS "void esThdTerm (\fBesThd_T\fP *thd)"

.PP
Terminate the specified thread\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthd\fP Thread: is a pointer to the thread structure, \fBesThd\fP\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state ES_KERN_INACTIVE\fP, see \fBKernel states\fP\&. 
.PP
2) \fCthd != NULL\fP 
.PP
3) \fCthd->signature == THD_CONTRACT_SIGNATURE\fP, the pointer must point to a valid \fBesThd\fP structure\&. 
.PP
4) \fC(thd->thdL\&.q == NULL) OR (thd->thdL\&.q == gRdyQueue)\fP, thread must be either in Ready Threads Queue or not be in any queue (e\&.g\&. not waiting for a synchronization mechanism)\&. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
1) \fCthd->signature == ~THD_CONTRACT_SIGNATURE\fP, each \fBesThd\fP structure will have invalid signature after termination\&. 
.RE
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application initialization code
.IP "\(bu" 2
Application thread code 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
possible 
.PP
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SS "void esThdSetPrioI (\fBesThd_T\fP *thd, uint8_tprio)"

.PP
Set the priority of a thread\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthd\fP Thread: is pointer to the thread structure, \fBesThd\fP\&. 
.br
\fIprio\fP Priority: is new priority of the thread pointed by \fCthd\fP\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INACTIVE\fP, see \fBKernel states\fP\&. 
.PP
2) \fCthd != NULL\fP 
.PP
3) \fCthd->signature == THD_CONTRACT_SIGNATURE\fP, the pointer must point to a valid \fBesThd\fP structure\&. 
.PP
4) \fC0 < prio < CFG_SCHED_PRIO_LVL - 1\fP, see \fBCFG_SCHED_PRIO_LVL\fP\&. 
.RE
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application initialization code
.IP "\(bu" 2
Application thread code
.IP "\(bu" 2
Interrupt service routine 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
possible 
.PP
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "void esThdPostI (\fBesThd_T\fP *thd)"

.PP
Post to thread semaphore\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthd\fP Pointer to the thread ID structure 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INACTIVE\fP, see \fBKernel states\fP\&. 
.PP
2) \fCthd != NULL\fP 
.PP
3) \fCthd->signature == THD_CONTRACT_SIGNATURE\fP, the pointer must point to a valid \fBesThd\fP structure\&. 
.RE
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application initialization code
.IP "\(bu" 2
Application thread code
.IP "\(bu" 2
Interrupt service routine 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
possible 
.PP
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "void esThdPost (\fBesThd_T\fP *thd)"

.PP
Post to thread semaphore\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthd\fP Pointer to the thread ID structure 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INACTIVE\fP, see \fBKernel states\fP\&. 
.PP
2) \fCthd != NULL\fP 
.PP
3) \fCthd->signature == THD_CONTRACT_SIGNATURE\fP, the pointer must point to a valid \fBesThd\fP structure\&. 
.RE
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application initialization code
.IP "\(bu" 2
Application thread code 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
possible 
.PP
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SS "void esThdWaitI (void)"

.PP
Wait for thread semaphore\&. 
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state == ES_KERN_RUN\fP, see \fBKernel states\fP\&. 
.RE
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application thread code 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
always 
.PP
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "void esThdWait (void)"

.PP
Wait for thread semaphore\&. 
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state == ES_KERN_RUN\fP, see \fBKernel states\fP\&. 
.RE
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application thread code 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
always 
.PP
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SS "void esThdQInit (\fBesThdQ_T\fP *thdQ)"

.PP
Initialize Thread Queue\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthdQ\fP Thread Queue: is a pointer to thread queue structure, \fBesThdQ\fP\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCthdQ != NULL\fP 
.PP
2) \fCthdQ->signature != THDQ_CONTRACT_SIGNATURE\fP, the thread queue structure can't be initialized more than once\&. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
1) \fCthdQ->signature == THDQ_CONTRACT_SIGNATURE\fP, each \fBesThdQ\fP structure will have valid signature after initialization\&. 
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SS "void esThdQTerm (\fBesThdQ_T\fP *thdQ)"

.PP
Terminate Thread Queue\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthdQ\fP Thread Queue: is a pointer to thread queue structure, \fBesThdQ\fP\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCthdQ != NULL\fP 
.PP
2) \fCthdQ->signature == THDQ_CONTRACT_SIGNATURE\fP, the thread queue structure must be already initialized\&. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
1) \fCthdQ->signature == ~THDQ_CONTRACT_SIGNATURE\fP, each \fBesThdQ\fP structure will have invalid signature after termination\&. 
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SS "void esThdQAddI (\fBesThdQ_T\fP *thdQ, \fBesThd_T\fP *thd)"

.PP
Add a thread to the Thread Queue\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthdQ\fP Thread Queue: is a pointer to thread queue structure, \fBesThdQ\fP\&. 
.br
\fIthd\fP Thread: is a pointer to the thread ID structure, \fBesThd\fP\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCthdQ != NULL\fP 
.PP
2) \fCthdQ->signature == THDQ_CONTRACT_SIGNATURE\fP, the pointer must point to a valid \fBesThdQ\fP structure\&. 
.PP
3) \fCthd != NULL\fP 
.PP
4) \fCthd->signature == THD_CONTRACT_SIGNATURE\fP, the pointer must point to a valid \fBesThd\fP structure\&. 
.PP
5) \fCthd->thdL\&.q == NULL\fP, thread must not be in any queue\&.
.RE
.PP
This function adds a thread at the specified Thread Queue\&. 
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "void esThdQRmI (\fBesThdQ_T\fP *thdQ, \fBesThd_T\fP *thd)"

.PP
Removes the thread from the Thread Queue\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthdQ\fP Thread Queue: is a pointer to thread queue structure, \fBesThdQ\fP\&. 
.br
\fIthd\fP Thread: is a pointer to the thread ID structure, \fBesThd\fP\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCthd != NULL\fP 
.PP
2) \fCthd->signature == THD_CONTRACT_SIGNATURE\fP, the pointer must point to a valid \fBesThd\fP structure\&. 
.PP
3) \fCthdQ != NULL\fP 
.PP
4) \fCthdQ->signature == THDQ_CONTRACT_SIGNATURE\fP, the pointer must point to a valid \fBesThdQ\fP structure\&. 
.PP
5) \fCthd->thdL\&.q == thdQ\fP, thread must be in the \fCthdQ\fP queue\&. 
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "\fBesThd_T\fP* esThdQFetchI (const \fBesThdQ_T\fP *thdQ)"

.PP
Fetch the first high priority thread from the Thread Queue\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthdQ\fP Thread Queue: is a pointer to thread queue structure, \fBesThdQ\fP\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
A pointer to the thread ID structure with the highest priority\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCthdQ != NULL\fP 
.PP
2) \fCthdQ->signature == THDQ_CONTRACT_SIGNATURE\fP, the pointer must point to a valid \fBesThdQ\fP structure\&. 
.PP
3) \fCprioBM != 0\fP, priority bit map must not be empty 
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "\fBesThd_T\fP* esThdQFetchRotateI (\fBesThdQ_T\fP *thdQ, uint_fast8_tprio)"

.PP
Fetch the next thread and rotate thread linked list\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthdQ\fP Thread Queue: is a pointer to thread queue structure, \fBesThdQ\fP\&. This is the thread queue to fetch from\&. 
.br
\fIprio\fP Priority: is the priority level to fetch and rotate\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Pointer to the next thread in queue\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCthdQ != NULL\fP 
.PP
2) \fCthdQ->signature == THDQ_CONTRACT_SIGNATURE\fP, the pointer must point to a valid \fBesThdQ\fP structure\&. 
.PP
3) \fC0 <= prio <= CFG_SCHED_PRIO_LVL\fP, see \fBCFG_SCHED_PRIO_LVL\fP\&. 
.PP
4) \fCsentinel != NULL\fP, at least one thread must be in the selected priority level 
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "\fBbool_T\fP esThdQIsEmpty (const \fBesThdQ_T\fP *thdQ)"

.PP
Is thread queue empty\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthdQ\fP Thread Queue: is a pointer to thread queue structure, \fBesThdQ\fP\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
The state of thread queue 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fITRUE\fP - thread queue is empty 
.br
\fIFALSE\fP - thread queue is not empty 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCthdQ != NULL\fP 
.PP
2) \fCthdQ->signature == THDQ_CONTRACT_SIGNATURE\fP, the pointer must point to a valid \fBesThdQ\fP structure\&. 
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SS "void esSchedRdyAddI (\fBesThd_T\fP *thd)"

.PP
Add thread \fCthd\fP to the ready thread list and notify the scheduler\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthd\fP Pointer to the initialized thread ID structure, \fBesThd\fP\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INACTIVE\fP, see \fBKernel states\fP\&. 
.PP
2) \fCthd != NULL\fP 
.PP
3) \fCthd->signature == THD_CONTRACT_SIGNATURE\fP, the pointer must point to a valid \fBesThd\fP structure\&. 
.PP
4) \fCthd->thdL\&.q == NULL\fP, thread must not be in a queue\&. 
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "void esSchedRdyRmI (\fBesThd_T\fP *thd)"

.PP
Remove thread \fCthd\fP from the ready thread list and notify the scheduler\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthd\fP Pointer to the initialized thread ID structure, \fBesThd\fP\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INACTIVE\fP, see \fBKernel states\fP\&. 
.PP
2) \fCthd != NULL\fP 
.PP
3) \fCthd->signature == THD_CONTRACT_SIGNATURE\fP, the pointer must point to a valid \fBesThd\fP structure\&. 
.PP
4) \fCthd->thdL\&.q == &gRdyQueue\fP, thread must be in Ready Threads queue\&. 
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "void esSchedYieldI (void)"

.PP
Force the scheduler invocation which will evaluate all ready threads and switch to ready thread with the highest priority\&. 
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INACTIVE\fP, see \fBKernel states\fP\&. 
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "void esSchedYieldIsrI (void)"

.PP
Force the scheduler invocation which will evaluate all ready threads and switch to ready thread with the highest priority\&. 
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INACTIVE\fP, see \fBKernel states\fP\&. 
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "void esSchedLockEnterI (void)"

.PP
Lock the scheduler\&. 
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INIT\fP, see \fBKernel states\fP\&. 
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "void esSchedLockExitI (void)"

.PP
Unlock the scheduler\&. 
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INIT\fP, see \fBKernel states\fP\&. 
.PP
2) \fCgKernLockCnt > 0U\fP, current number of locks must be greater than zero, in other words: each call to kernel lock function must have its matching call to kernel unlock function\&. 
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "void esSchedLockEnter (void)"

.PP
Lock the scheduler\&. 
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INIT\fP, see \fBKernel states\fP\&. 
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SS "void esSchedLockExit (void)"

.PP
Unlock the scheduler\&. 
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INIT\fP, see \fBKernel states\fP\&. 
.PP
2) \fCgKernLockCnt > 0U\fP, current number of locks must be greater than zero, in other words: each call to kernel lock function must have its matching call to kernel unlock function\&. 
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SS "void esVTmrInitI (\fBesVTmr_T\fP *vTmr, \fBesTick_T\fPtick, void(*)(void *)fn, void *arg)"

.PP
Add and start a new virtual timer\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvTmr\fP Virtual Timer: is pointer to the timer ID structure, \fBesVTmr\fP\&. 
.br
\fItick\fP Tick: the timer delay expressed in system ticks 
.br
\fIfn\fP Function: is pointer to the callback function 
.br
\fIarg\fP Argument: is pointer to the arguments of callback function 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INACTIVE\fP, see \fBKernel states\fP\&. 
.PP
2) \fCvTmr != NULL\fP 
.PP
3) \fCvTmr->signature != VTMR_CONTRACT_SIGNATURE\fP, the timer structure can't be initialized more than once\&. 
.PP
4) \fCtick > 1U\fP 
.PP
5) \fCfn != NULL\fP 
.RE
.PP
\fBPostcondition:\fP
.RS 4
1) \fCvTmr->signature == VTMR_CONTRACT_SIGNATURE\fP, each \fBesVTmr\fP structure will have valid signature after initialization\&. 
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "void esVTmrInit (\fBesVTmr_T\fP *vTmr, \fBesTick_T\fPtick, void(*)(void *)fn, void *arg)"

.PP
Add and start a new virtual timer\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvTmr\fP Virtual Timer: is pointer to the timer ID structure, \fBesVTmr\fP\&. 
.br
\fItick\fP Tick: the timer delay expressed in system ticks 
.br
\fIfn\fP Function: is pointer to the callback function 
.br
\fIarg\fP Argument: is pointer to the arguments of callback function 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INACTIVE\fP, see \fBKernel states\fP\&. 
.PP
2) \fCvTmr != NULL\fP 
.PP
3) \fCvTmr->signature != VTMR_CONTRACT_SIGNATURE\fP, the timer structure can't be initialized more than once\&. 
.PP
4) \fCtick > 1U\fP 
.PP
5) \fCfn != NULL\fP 
.RE
.PP
\fBPostcondition:\fP
.RS 4
1) \fCvTmr->signature == VTMR_CONTRACT_SIGNATURE\fP, each \fBesVTmr\fP structure will have valid signature after initialization\&. 
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SS "void esVTmrTermI (\fBesVTmr_T\fP *vTmr)"

.PP
Cancel and remove a virtual timer\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvTmr\fP Timer: is pointer to the timer ID structure, \fBesVTmr\fP\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INACTIVE\fP, see \fBKernel states\fP\&. 
.PP
2) \fCvTmr != NULL\fP 
.PP
3) \fCvTmr->signature == VTMR_CONTRACT_SIGNATURE\fP, the pointer must point to a valid \fBesVTmr\fP structure\&. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
1) \fCvTmr->signature = ~VTMR_CONTRACT_SIGNATURE\fP, each \fBesVTmr\fP structure will have invalid signature after termination\&. 
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "void esVTmrTerm (\fBesVTmr_T\fP *vTmr)"

.PP
Cancel and remove a virtual timer\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvTmr\fP Timer: is pointer to the timer ID structure, \fBesVTmr\fP\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INACTIVE\fP, see \fBKernel states\fP\&. 
.PP
2) \fCvTmr != NULL\fP 
.PP
3) \fCvTmr->signature == VTMR_CONTRACT_SIGNATURE\fP, the pointer must point to a valid \fBesVTmr\fP structure\&. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
1) \fCvTmr->signature = ~VTMR_CONTRACT_SIGNATURE\fP, each \fBesVTmr\fP structure will have invalid signature after termination\&. 
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SS "void esVTmrDelay (\fBesTick_T\fPtick)"

.PP
Delay for specified amount of ticks\&. 
.PP
\fBParameters:\fP
.RS 4
\fItick\fP Tick: number of system ticks to delay\&.
.RE
.PP
This function will create a virtual timer with count down time specified in argument \fCtick\fP and put the calling thread into \fCsleep\fP state\&. When timeout expires the thread will be placed back into \fCready\fP state\&. 
.PP
\fBPrecondition:\fP
.RS 4
1) \fCtick > 1U\fP 
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SH "Variable Documentation"
.PP 
.SS "\fBesThdQ_T\fP gRdyQueue\fC [static]\fP"

.PP
Ready Thread queue\&. 
.SS "\fBsysTmr_T\fP gSysTmr\fC [static]\fP"
\fBInitial value:\fP
.PP
.nf
= {
    0u,
    0u,
    0u,



}
.fi
.PP
Main System Timer structure\&. 
.SS "\fBesVTmr_T\fP gVTmrArmed\fC [static]\fP"
\fBInitial value:\fP
.PP
.nf
= {
   {    &gVTmrArmed,
        &gVTmrArmed,
        &gVTmrArmed
   },


   UINT_FAST8_MAX,





   NULL,
   NULL,



}
.fi
.PP
List of virtual timers to armed expire\&. 
.SS "\fBesVTmr_T\fP gVTmrPend\fC [static]\fP"
\fBInitial value:\fP
.PP
.nf
= {
   {    &gVTmrPend,
        &gVTmrPend,
        &gVTmrPend
   },
   0u,
   NULL,
   NULL,



}
.fi
.PP
Virtual timers pending to be inserted into waiting list\&. 
.SS "\fBesThd_T\fP gKVTmr\fC [static]\fP"

.PP
Virtual timer thread ID\&. 
.SS "\fBesThd_T\fP gKIdle\fC [static]\fP"

.PP
Idle thread ID\&. 
.SS "uint_fast8_t gKernLockCnt\fC [static]\fP"

.PP
Kernel Lock Counter\&. 
.SS "const volatile \fBesKernCtrl_T\fP gKernCtrl"
\fBInitial value:\fP
.PP
.nf
= {
    NULL,                                                                       
    NULL,                                                                       
    ES_KERN_INACTIVE                                                            
}
.fi
.PP
Kernel control initialization\&. Kernel control block\&. 
.SH "Author"
.PP 
Generated automatically by Doxygen for eSolid - Real-Time Kernel from the source code\&.
