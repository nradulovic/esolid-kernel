.TH "Implementation" 3 "Sat Nov 30 2013" "Version 1.0BetaR02" "eSolid - Real-Time Kernel" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Implementation \- 
.PP
Kernel port independent code implementation\&.  

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBsysTmr\fP"
.br
.RI "\fIMain System Timer structure\&. \fP"
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBDEF_SCHED_STATE_INTSRV_MSK\fP   (0x01u << 0)"
.br
.RI "\fIKernel state variable bit position which defines if the kernel is in interrupt servicing state\&. \fP"
.ti -1c
.RI "#define \fBDEF_SCHED_STATE_LOCK_MSK\fP   (0x01u << 1)"
.br
.RI "\fIKernel state variable bit position which defines if the kernel is locked or not\&. \fP"
.ti -1c
.RI "#define \fBDEF_THD_CONTRACT_SIGNATURE\fP   ((portReg_T)0xfeedbeeful)"
.br
.RI "\fIThread structure signature\&. \fP"
.ti -1c
.RI "#define \fBDEF_THDQ_CONTRACT_SIGNATURE\fP   ((portReg_T)0xfeedbef0ul)"
.br
.RI "\fIThread Queue structure signature\&. \fP"
.ti -1c
.RI "#define \fBDEF_VTMR_CONTRACT_SIGNATURE\fP   ((portReg_T)0xfeedbef1ul)"
.br
.RI "\fITimer structure signature\&. \fP"
.ti -1c
.RI "#define \fBDLIST_IS_ENTRY_FIRST\fP(list, entry)   ((entry) == (entry)->list\&.next)"
.br
.RI "\fIDList macro: is the thread the first one in the list\&. \fP"
.ti -1c
.RI "#define \fBDLIST_IS_ENTRY_LAST\fP(list, entry)   \fBDLIST_IS_ENTRY_FIRST\fP(list, entry)"
.br
.RI "\fIDList macro: is the thread the last one in the list\&. \fP"
.ti -1c
.RI "#define \fBDLIST_IS_ENTRY_SINGLE\fP(list, entry)   \fBDLIST_IS_ENTRY_FIRST\fP(list, entry)"
.br
.RI "\fIDList macro: is the thread single in the list\&. \fP"
.ti -1c
.RI "#define \fBDLIST_ENTRY_NEXT\fP(list, entry)   (entry)->list\&.next"
.br
.RI "\fIDList macro: get the next entry\&. \fP"
.ti -1c
.RI "#define \fBDLIST_ENTRY_INIT\fP(list, entry)"
.br
.RI "\fIDList macro: initialize entry\&. \fP"
.ti -1c
.RI "#define \fBDLIST_ENTRY_ADD_AFTER\fP(list, current, entry)"
.br
.RI "\fIDList macro: add new \fCentry\fP after \fCcurrent\fP entry\&. \fP"
.ti -1c
.RI "#define \fBDLIST_ENTRY_RM\fP(list, entry)"
.br
.RI "\fIDList macro: remove the \fCentry\fP from a list\&. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBDECL_MODULE_INFO\fP ('Kernel', ES_KERN_ID,'Nenad Radulovic')"
.br
.RI "\fIModule identification info\&. \fP"
.ti -1c
.RI "void \fBesKernInit\fP (void)"
.br
.RI "\fIInitialize kernel internal data structures\&. \fP"
.ti -1c
.RI "PORT_C_NORETURN void \fBesKernStart\fP (void)"
.br
.RI "\fIStart the multi-threading\&. \fP"
.ti -1c
.RI "void \fBesKernSysTmr\fP (void)"
.br
.RI "\fIProcess the system timer event\&. \fP"
.ti -1c
.RI "void \fBesKernIsrEnterI\fP (void)"
.br
.RI "\fIEnter Interrupt Service Routine\&. \fP"
.ti -1c
.RI "void \fBesKernIsrExitI\fP (void)"
.br
.RI "\fIExit Interrupt Service Routine\&. \fP"
.ti -1c
.RI "void \fBesKernLockIntEnter\fP (\fBesLockCtx_T\fP *lockCtx)"
.br
.RI "\fIEnter a critical code lock\&. \fP"
.ti -1c
.RI "void \fBesKernLockIntExit\fP (\fBesLockCtx_T\fP lockCtx)"
.br
.RI "\fIExit a critical code lock\&. \fP"
.ti -1c
.RI "void \fBesKernLockEnterI\fP (void)"
.br
.RI "\fILock the scheduler\&. \fP"
.ti -1c
.RI "void \fBesKernLockExitI\fP (void)"
.br
.RI "\fIUnlock the scheduler\&. \fP"
.ti -1c
.RI "void \fBesKernLockEnter\fP (void)"
.br
.RI "\fILock the scheduler\&. \fP"
.ti -1c
.RI "void \fBesKernLockExit\fP (void)"
.br
.RI "\fIUnlock the scheduler\&. \fP"
.ti -1c
.RI "void \fBesThdInit\fP (\fBesThd_T\fP *thd, void(*fn)(void *), void *arg, \fBportStck_T\fP *stck, size_t stckSize, uint8_t prio)"
.br
.RI "\fIInitialize the specified thread\&. \fP"
.ti -1c
.RI "void \fBesThdTerm\fP (\fBesThd_T\fP *thd)"
.br
.RI "\fITerminate the specified thread\&. \fP"
.ti -1c
.RI "void \fBesThdSetPrioI\fP (\fBesThd_T\fP *thd, uint8_t prio)"
.br
.RI "\fISet the priority of a thread\&. \fP"
.ti -1c
.RI "void \fBesThdQInit\fP (\fBesThdQ_T\fP *thdQ)"
.br
.RI "\fIInitialize Thread Queue\&. \fP"
.ti -1c
.RI "void \fBesThdQTerm\fP (\fBesThdQ_T\fP *thdQ)"
.br
.RI "\fITerminate Thread Queue\&. \fP"
.ti -1c
.RI "void \fBesThdQAddI\fP (\fBesThdQ_T\fP *thdQ, \fBesThd_T\fP *thd)"
.br
.RI "\fIAdd a thread to the Thread Queue\&. \fP"
.ti -1c
.RI "void \fBesThdQRmI\fP (\fBesThdQ_T\fP *thdQ, \fBesThd_T\fP *thd)"
.br
.RI "\fIRemoves the thread from the Thread Queue\&. \fP"
.ti -1c
.RI "\fBesThd_T\fP * \fBesThdQFetchI\fP (const \fBesThdQ_T\fP *thdQ)"
.br
.RI "\fIFetch the first high priority thread from the Thread Queue\&. \fP"
.ti -1c
.RI "\fBesThd_T\fP * \fBesThdQFetchRotateI\fP (\fBesThdQ_T\fP *thdQ, uint_fast8_t prio)"
.br
.RI "\fIFetch the next thread and rotate thread linked list\&. \fP"
.ti -1c
.RI "\fBbool_T\fP \fBesThdQIsEmpty\fP (const \fBesThdQ_T\fP *thdQ)"
.br
.RI "\fIIs thread queue empty\&. \fP"
.ti -1c
.RI "void \fBesSchedRdyAddI\fP (\fBesThd_T\fP *thd)"
.br
.RI "\fIAdd thread \fCthd\fP to the ready thread list and notify the scheduler\&. \fP"
.ti -1c
.RI "void \fBesSchedRdyRmI\fP (\fBesThd_T\fP *thd)"
.br
.RI "\fIRemove thread \fCthd\fP from the ready thread list and notify the scheduler\&. \fP"
.ti -1c
.RI "void \fBesSchedYieldI\fP (void)"
.br
.RI "\fIForce the scheduler invocation which will evaluate all ready threads and switch to ready thread with the highest priority\&. \fP"
.ti -1c
.RI "void \fBesSchedYieldIsrI\fP (void)"
.br
.RI "\fIForce the scheduler invocation which will evaluate all ready threads and switch to ready thread with the highest priority\&. \fP"
.ti -1c
.RI "void \fBesVTmrInitI\fP (\fBesVTmr_T\fP *vTmr, \fBesTick_T\fP tick, void(*fn)(void *), void *arg)"
.br
.RI "\fIAdd and start a new virtual timer\&. \fP"
.ti -1c
.RI "void \fBesVTmrInit\fP (\fBesVTmr_T\fP *vTmr, \fBesTick_T\fP tick, void(*fn)(void *), void *arg)"
.br
.RI "\fIAdd and start a new virtual timer\&. \fP"
.ti -1c
.RI "void \fBesVTmrTermI\fP (\fBesVTmr_T\fP *vTmr)"
.br
.RI "\fICancel and remove a virtual timer\&. \fP"
.ti -1c
.RI "void \fBesVTmrTerm\fP (\fBesVTmr_T\fP *vTmr)"
.br
.RI "\fICancel and remove a virtual timer\&. \fP"
.ti -1c
.RI "void \fBesVTmrDelay\fP (\fBesTick_T\fP tick)"
.br
.RI "\fIDelay for specified amount of ticks\&. \fP"
.ti -1c
.RI "\fBesTick_T\fP \fBesSysTmrTickGet\fP (void)"
.br
.RI "\fIGet the current tick value\&. \fP"
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "static uint_fast8_t \fBKernLockCnt\fP"
.br
.RI "\fIKernel Lock Counter\&. \fP"
.ti -1c
.RI "const struct \fBkernCtrl_\fP \fBKernCtrl\fP"
.br
.RI "\fIKernel control initialization\&. \fP"
.in -1c
.SS "System timer"

.in +1c
.ti -1c
.RI "static struct \fBsysTmr\fP \fBSysTmr\fP"
.br
.RI "\fIMain System Timer structure\&. \fP"
.ti -1c
.RI "static struct \fBesVTmr\fP \fBVTmrArmed\fP"
.br
.RI "\fIList of virtual armed timers waiting to expire\&. \fP"
.ti -1c
.RI "static struct \fBesVTmr\fP \fBVTmrPend\fP"
.br
.RI "\fIVirtual timers pending to be inserted into waiting list\&. \fP"
.ti -1c
.RI "static struct \fBesThd\fP \fBKVTmr\fP"
.br
.RI "\fIVirtual timer thread ID\&. \fP"
.ti -1c
.RI "static \fBPORT_C_INLINE\fP void \fBsysTmrInit\fP (void)"
.br
.RI "\fIInitialize system timer hardware\&. \fP"
.ti -1c
.RI "static \fBPORT_C_INLINE\fP void \fBsysTmrActivate\fP (void)"
.br
.RI "\fITry to activate system timer\&. \fP"
.ti -1c
.RI "static \fBPORT_C_INLINE\fP void \fBsysTmrDeactivateI\fP (void)"
.br
.RI "\fITry to deactivate system timer\&. \fP"
.in -1c
.SS "Priority Bit Map"

.in +1c
.ti -1c
.RI "static \fBPORT_C_INLINE\fP void \fBpbmInit\fP (struct pbm_ *pbm)"
.br
.RI "\fIInitialize bitmap\&. \fP"
.ti -1c
.RI "static \fBPORT_C_INLINE\fP void \fBpbmSet\fP (struct pbm_ *pbm, uint_fast8_t prio)"
.br
.RI "\fISet the bit corresponding to the prio argument\&. \fP"
.ti -1c
.RI "static \fBPORT_C_INLINE\fP void \fBpbmClear\fP (struct pbm_ *pbm, uint_fast8_t prio)"
.br
.RI "\fIClear the bit corresponding to the prio argument\&. \fP"
.ti -1c
.RI "static \fBPORT_C_INLINE\fP uint_fast8_t \fBpbmGetHighest\fP (const struct pbm_ *pbm)"
.br
.RI "\fIGet the highest priority set\&. \fP"
.ti -1c
.RI "static \fBPORT_C_INLINE\fP \fBbool_T\fP \fBpbmIsEmpty\fP (const struct pbm_ *pbm)"
.br
.RI "\fIIs bit map empty? \fP"
.in -1c
.SS "Scheduler"

.in +1c
.ti -1c
.RI "static struct \fBesThdQ\fP \fBRdyQueue\fP"
.br
.RI "\fIReady Thread queue\&. \fP"
.ti -1c
.RI "static \fBPORT_C_INLINE\fP void \fBschedInit\fP (void)"
.br
.RI "\fIInitialize Ready Thread Queue structure \fBRdyQueue\fP and Kernel control structure \fBkernCtrl_\fP\&. \fP"
.ti -1c
.RI "static \fBPORT_C_INLINE\fP void \fBschedStart\fP (void)"
.br
.RI "\fISet the scheduler data structures for multi-threading\&. \fP"
.ti -1c
.RI "static \fBPORT_C_INLINE\fP void \fBschedSleep\fP (void)"
.br
.RI "\fISet the scheduler to sleep\&. \fP"
.ti -1c
.RI "static \fBPORT_C_INLINE\fP void \fBschedWakeUpI\fP (void)"
.br
.RI "\fIWake up the scheduler\&. \fP"
.ti -1c
.RI "static \fBPORT_C_INLINE\fP void \fBschedRdyAddInitI\fP (\fBesThd_T\fP *thd)"
.br
.RI "\fIInitialize scheduler ready structure during the thread add operation\&. \fP"
.ti -1c
.RI "static \fBPORT_C_INLINE\fP void \fBschedQmNextI\fP (void)"
.br
.RI "\fIFetch and try to schedule the next thread of the same priority as the current thread\&. \fP"
.ti -1c
.RI "static \fBPORT_C_INLINE\fP void \fBschedQmI\fP (void)"
.br
.RI "\fIDo the Quantum (Round-Robin) scheduling\&. \fP"
.in -1c
.SS "Virtual Timer and Virtual Timer kernel thread"

.in +1c
.ti -1c
.RI "static \fBPORT_C_INLINE\fP void \fBvTmrSleep\fP (\fBesTick_T\fP ticks)"
.br
.RI "\fISet up system timer for different tick period during sleeping\&. \fP"
.ti -1c
.RI "static \fBPORT_C_INLINE\fP void \fBvTmrEvaluateI\fP (void)"
.br
.RI "\fIEvaluate armed virtual timers\&. \fP"
.ti -1c
.RI "static void \fBvTmrAddArmedS\fP (\fBesVTmr_T\fP *vTmr)"
.br
.RI "\fIAdd a virtual timer into sorted list\&. \fP"
.ti -1c
.RI "static \fBPORT_C_INLINE\fP void \fBvTmrImportPendSleepI\fP (void)"
.br
.RI "\fIImport timers from pending list to armed list\&. \fP"
.ti -1c
.RI "static void \fBvTmrImportPend\fP (void)"
.br
.RI "\fIImport timers from pending list to armed list\&. \fP"
.ti -1c
.RI "static void \fBkVTmrInit\fP (void)"
.br
.RI "\fIInitialization of Virtual Timer kernel thread\&. \fP"
.ti -1c
.RI "static void \fBkVTmr\fP (void *arg)"
.br
.RI "\fIVirtual Timer thread code\&. \fP"
.in -1c
.SS "Idle kernel thread"

.in +1c
.ti -1c
.RI "static struct \fBesThd\fP \fBKIdle\fP"
.br
.RI "\fIIdle thread ID\&. \fP"
.ti -1c
.RI "static void \fBkIdleInit\fP (void)"
.br
.RI "\fIInitialization of Idle thread\&. \fP"
.ti -1c
.RI "static void \fBkIdle\fP (void *arg)"
.br
.RI "\fIIdle thread code\&. \fP"
.in -1c
.SS "Basic thread synchronization"

.in +1c
.ti -1c
.RI "void \fBthdPost\fP (\fBesThd_T\fP *thd)"
.br
.RI "\fIPost a signal to a thread which is waiting\&. \fP"
.ti -1c
.RI "void \fBthdWait\fP (void)"
.br
.RI "\fIWait for a signal\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
Kernel port independent code implementation\&. 


.SH "Macro Definition Documentation"
.PP 
.SS "#define DEF_SCHED_STATE_INTSRV_MSK   (0x01u << 0)"

.PP
Kernel state variable bit position which defines if the kernel is in interrupt servicing state\&. 
.SS "#define DEF_SCHED_STATE_LOCK_MSK   (0x01u << 1)"

.PP
Kernel state variable bit position which defines if the kernel is locked or not\&. 
.SS "#define DEF_THD_CONTRACT_SIGNATURE   ((portReg_T)0xfeedbeeful)"

.PP
Thread structure signature\&. The signature is used to confirm that a structure passed to a kernel function is indeed a esThd_T thread structure\&. 
.SS "#define DEF_THDQ_CONTRACT_SIGNATURE   ((portReg_T)0xfeedbef0ul)"

.PP
Thread Queue structure signature\&. The signature is used to confirm that a structure passed to a kernel function is indeed a esThdQ_T thread queue structure\&. 
.SS "#define DEF_VTMR_CONTRACT_SIGNATURE   ((portReg_T)0xfeedbef1ul)"

.PP
Timer structure signature\&. The signature is used to confirm that a structure passed to a timer function is indeed a esVTmr_T timer structure\&. 
.SS "#define DLIST_IS_ENTRY_FIRST(list, entry)   ((entry) == (entry)->list\&.next)"

.PP
DList macro: is the thread the first one in the list\&. 
.SS "#define DLIST_IS_ENTRY_LAST(list, entry)   \fBDLIST_IS_ENTRY_FIRST\fP(list, entry)"

.PP
DList macro: is the thread the last one in the list\&. 
.SS "#define DLIST_IS_ENTRY_SINGLE(list, entry)   \fBDLIST_IS_ENTRY_FIRST\fP(list, entry)"

.PP
DList macro: is the thread single in the list\&. 
.SS "#define DLIST_ENTRY_NEXT(list, entry)   (entry)->list\&.next"

.PP
DList macro: get the next entry\&. 
.SS "#define DLIST_ENTRY_INIT(list, entry)"
\fBValue:\fP
.PP
.nf
do {                                                                        \
        (entry)->list\&.next = (entry);                                           \
        (entry)->list\&.prev = (entry);                                           \
    } while (0u)
.fi
.PP
DList macro: initialize entry\&. 
.SS "#define DLIST_ENTRY_ADD_AFTER(list, current, entry)"
\fBValue:\fP
.PP
.nf
do {                                                                        \
        (entry)->list\&.next = (current);                                         \
        (entry)->list\&.prev = (entry)->list\&.next->list\&.prev;                     \
        (entry)->list\&.next->list\&.prev = (entry);                                \
        (entry)->list\&.prev->list\&.next = (entry);                                \
    } while (0u)
.fi
.PP
DList macro: add new \fCentry\fP after \fCcurrent\fP entry\&. 
.SS "#define DLIST_ENTRY_RM(list, entry)"
\fBValue:\fP
.PP
.nf
do {                                                                        \
        (entry)->list\&.next->list\&.prev = (entry)->list\&.prev;                     \
        (entry)->list\&.prev->list\&.next = (entry)->list\&.next;                     \
    } while (0u)
.fi
.PP
DList macro: remove the \fCentry\fP from a list\&. 
.SH "Function Documentation"
.PP 
.SS "static \fBPORT_C_INLINE\fP void pbmInit (struct pbm_ *pbm)\fC [static]\fP"

.PP
Initialize bitmap\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpbm\fP Pointer to the bit map structure 
.RE
.PP

.SS "static \fBPORT_C_INLINE\fP void pbmSet (struct pbm_ *pbm, uint_fast8_tprio)\fC [static]\fP"

.PP
Set the bit corresponding to the prio argument\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpbm\fP Pointer to the bit map structure 
.br
\fIprio\fP Priority which will be marked as used 
.RE
.PP

.SS "static \fBPORT_C_INLINE\fP void pbmClear (struct pbm_ *pbm, uint_fast8_tprio)\fC [static]\fP"

.PP
Clear the bit corresponding to the prio argument\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpbm\fP Pointer to the bit map structure 
.br
\fIprio\fP Priority which will be marked as unused 
.RE
.PP

.SS "static \fBPORT_C_INLINE\fP uint_fast8_t pbmGetHighest (const struct pbm_ *pbm)\fC [static]\fP"

.PP
Get the highest priority set\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpbm\fP Pointer to the bit map structure 
.RE
.PP
\fBReturns:\fP
.RS 4
The number of the highest priority marked as used 
.RE
.PP

.SS "static \fBPORT_C_INLINE\fP \fBbool_T\fP pbmIsEmpty (const struct pbm_ *pbm)\fC [static]\fP"

.PP
Is bit map empty? 
.PP
\fBParameters:\fP
.RS 4
\fIpbm\fP Pointer to the bit map structure 
.RE
.PP
\fBReturns:\fP
.RS 4
The status of the bit map 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fITRUE\fP - bit map is empty 
.br
\fIFALSE\fP - there is at least one bit set 
.RE
.PP

.SS "static \fBPORT_C_INLINE\fP void schedInit (void)\fC [static]\fP"

.PP
Initialize Ready Thread Queue structure \fBRdyQueue\fP and Kernel control structure \fBkernCtrl_\fP\&. 
.SS "static \fBPORT_C_INLINE\fP void schedStart (void)\fC [static]\fP"

.PP
Set the scheduler data structures for multi-threading\&. This function is called just before multi-threading will start\&. 
.SS "static \fBPORT_C_INLINE\fP void schedSleep (void)\fC [static]\fP"

.PP
Set the scheduler to sleep\&. 
.PP
\fBNote:\fP
.RS 4
This function is used only when \fBCFG_SCHED_POWER_SAVE\fP option is active\&. 
.RE
.PP

.SS "static \fBPORT_C_INLINE\fP void schedWakeUpI (void)\fC [static]\fP"

.PP
Wake up the scheduler\&. 
.PP
\fBNote:\fP
.RS 4
This function is used only when \fBCFG_SCHED_POWER_SAVE\fP option is active\&. 
.RE
.PP

.SS "static \fBPORT_C_INLINE\fP void schedRdyAddInitI (\fBesThd_T\fP *thd)\fC [static]\fP"

.PP
Initialize scheduler ready structure during the thread add operation\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthd\fP Pointer to the thread currently being initialized\&.
.RE
.PP
Function will initialize scheduler structures during the init phase of the kernel\&. 
.SS "static \fBPORT_C_INLINE\fP void schedQmNextI (void)\fC [static]\fP"

.PP
Fetch and try to schedule the next thread of the same priority as the current thread\&. 
.SS "static \fBPORT_C_INLINE\fP void schedQmI (void)\fC [static]\fP"

.PP
Do the Quantum (Round-Robin) scheduling\&. 
.SS "static \fBPORT_C_INLINE\fP void sysTmrInit (void)\fC [static]\fP"

.PP
Initialize system timer hardware\&. 
.SS "static \fBPORT_C_INLINE\fP void sysTmrActivate (void)\fC [static]\fP"

.PP
Try to activate system timer\&. 
.PP
\fBNote:\fP
.RS 4
This function is used only when \fBCFG_SYSTMR_ADAPTIVE_MODE\fP option is active\&. 
.RE
.PP

.SS "static \fBPORT_C_INLINE\fP void sysTmrDeactivateI (void)\fC [static]\fP"

.PP
Try to deactivate system timer\&. 
.PP
\fBNote:\fP
.RS 4
This function is used only when \fBCFG_SYSTMR_ADAPTIVE_MODE\fP option is active\&. 
.RE
.PP

.SS "static \fBPORT_C_INLINE\fP void vTmrSleep (\fBesTick_T\fPticks)\fC [static]\fP"

.PP
Set up system timer for different tick period during sleeping\&. 
.PP
\fBParameters:\fP
.RS 4
\fIticks\fP Number of ticks to sleep 
.RE
.PP
\fBNote:\fP
.RS 4
This function is used only when \fBCFG_SYSTMR_ADAPTIVE_MODE\fP option is active\&. 
.RE
.PP

.SS "static \fBPORT_C_INLINE\fP void vTmrEvaluateI (void)\fC [static]\fP"

.PP
Evaluate armed virtual timers\&. 
.SS "static void vTmrAddArmedS (\fBesVTmr_T\fP *vTmr)\fC [static]\fP"

.PP
Add a virtual timer into sorted list\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvTmr\fP Virtual timer: pointer to virtual timer to add 
.RE
.PP

.SS "static \fBPORT_C_INLINE\fP void vTmrImportPendSleepI (void)\fC [static]\fP"

.PP
Import timers from pending list to armed list\&. 
.PP
\fBNote:\fP
.RS 4
This function is used only when \fBCFG_SYSTMR_ADAPTIVE_MODE\fP option is active\&. 
.RE
.PP

.SS "static void vTmrImportPend (void)\fC [static]\fP"

.PP
Import timers from pending list to armed list\&. 
.SS "static void kVTmrInit (void)\fC [static]\fP"

.PP
Initialization of Virtual Timer kernel thread\&. 
.SS "static void kVTmr (void *arg)\fC [static]\fP"

.PP
Virtual Timer thread code\&. 
.PP
\fBParameters:\fP
.RS 4
\fIarg\fP Argument: thread does not use argument
.RE
.PP
This thread is responsible for virtual timer callback invocation and to import pending timers into armed linked list\&. 
.SS "static void kIdleInit (void)\fC [static]\fP"

.PP
Initialization of Idle thread\&. 
.SS "static void kIdle (void *arg)\fC [static]\fP"

.PP
Idle thread code\&. 
.PP
\fBParameters:\fP
.RS 4
\fIarg\fP Argument: thread does not use argument 
.RE
.PP

.SS "void thdPost (\fBesThd_T\fP *thd)"

.PP
Post a signal to a thread which is waiting\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthd\fP Pointer to thread which needs to be signaled 
.RE
.PP

.SS "void thdWait (void)"

.PP
Wait for a signal\&. 
.SS "DECL_MODULE_INFO ('Kernel', \fBES_KERN_ID\fP, 'Nenad Radulovic')"

.PP
Module identification info\&. 
.SS "void esKernInit (void)"

.PP
Initialize kernel internal data structures\&. 
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state == ES_KERN_INACTIVE\fP, see \fBKernel states\fP\&. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
1) \fCThe kernel state == ES_KERN_INIT\fP\&. 
.RE
.PP
\fBNote:\fP
.RS 4
1) This function may be invoked only once\&.
.RE
.PP
This function must be called first before any other kernel API\&. It initializes internal data structures that are used by other API functions\&. 
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application initialization code 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
never 
.PP
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SS "PORT_C_NORETURN void esKernStart (void)"

.PP
Start the multi-threading\&. 
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state == ES_KERN_INIT\fP, see \fBKernel states\fP\&. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
1) \fCThe kernel state == ES_KERN_RUN\fP 
.PP
2) The multi-threading execution will commence\&. 
.RE
.PP
\fBNote:\fP
.RS 4
1) Once this function is called the execution of threads will start and this function will never return\&.
.RE
.PP
This function will start multi-threading\&. Once the multi-threading has started the execution will never return to this function again (this function never returns)\&. 
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application initialization code 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
always 
.PP
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SS "void esKernSysTmr (void)"

.PP
Process the system timer event\&. 
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INIT\fP, see \fBKernel states\fP\&.
.RE
.PP
This function will be called only by port system timer interrupt\&. 
.PP
\fBObject class:\fP
.RS 4
\fBNot API\fP object, this object is not part of the application programming interface and it is intended for internal use only\&. 
.RE
.PP

.SS "void esKernIsrEnterI (void)"

.PP
Enter Interrupt Service Routine\&. 
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INIT\fP, see \fBKernel states\fP\&. 
.RE
.PP
\fBNote:\fP
.RS 4
1) You must call \fBesKernIsrExitI()\fP at the exit of ISR\&. 
.PP
2) You must invoke \fBesKernIsrEnterI()\fP and \fBesKernIsrExitI()\fP in pair\&. In other words, for every call to \fBesKernIsrEnterI()\fP at the beginning of the ISR you must have a call to \fBesKernIsrExitI()\fP at the end of the ISR\&.
.RE
.PP
Function will notify kernel that you are about to enter interrupt service routine (ISR)\&. This allows kernel to keep track of interrupt nesting and then only perform rescheduling at the last nested ISR\&. 
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Interrupt service routine 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
never 
.PP
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "void esKernIsrExitI (void)"

.PP
Exit Interrupt Service Routine\&. 
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INIT\fP, see \fBKernel states\fP\&. 
.RE
.PP
\fBNote:\fP
.RS 4
1) You must invoke \fBesKernIsrEnterI()\fP and \fBesKernIsrExitI()\fP in pair\&. In other words, for every call to \fBesKernIsrEnterI()\fP at the beginning of the ISR you must have a call to \fBesKernIsrExitI()\fP at the end of the ISR\&. 
.PP
2) Rescheduling is prevented when the scheduler is locked (see \fBesKernLockEnterI()\fP)
.RE
.PP
This function is used to notify kernel that you have completed servicing an interrupt\&. When the last nested ISR has completed, the function will call the scheduler to determine whether a new, high-priority task, is ready to run\&. 
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Interrupt service routine 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
possible 
.PP
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "void esKernLockIntEnter (\fBesLockCtx_T\fP *lockCtx)"

.PP
Enter a critical code lock\&. 
.PP
\fBParameters:\fP
.RS 4
\fIlockCtx\fP Pointer to context variable where to store the current lock context\&. 
.RE
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application initialization code
.IP "\(bu" 2
Application thread code 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
never 
.PP
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SS "void esKernLockIntExit (\fBesLockCtx_T\fPlockCtx)"

.PP
Exit a critical code lock\&. 
.PP
\fBParameters:\fP
.RS 4
\fIlockCtx\fP Context variable value
.RE
.PP
Restores the lock context to state before the \fBesKernLockIntEnter()\fP was called\&. 
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application initialization code
.IP "\(bu" 2
Application thread code 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
possible 
.PP
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SS "void esKernLockEnterI (void)"

.PP
Lock the scheduler\&. 
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INIT\fP, see \fBKernel states\fP\&. 
.RE
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application thread code 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
never 
.PP
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "void esKernLockExitI (void)"

.PP
Unlock the scheduler\&. 
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INIT\fP, see \fBKernel states\fP\&. 
.PP
2) \fCgKernLockCnt > 0u\fP, current number of locks must be greater than zero, in other words: each call to kernel lock function must have its matching call to kernel unlock function\&. 
.RE
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application thread code 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
possible 
.PP
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "void esKernLockEnter (void)"

.PP
Lock the scheduler\&. 
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INIT\fP, see \fBKernel states\fP\&. 
.RE
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application thread code 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
never 
.PP
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SS "void esKernLockExit (void)"

.PP
Unlock the scheduler\&. 
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INIT\fP, see \fBKernel states\fP\&. 
.PP
2) \fCgKernLockCnt > 0u\fP, current number of locks must be greater than zero, in other words: each call to kernel lock function must have its matching call to kernel unlock function\&. 
.RE
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application thread code 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
possible 
.PP
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SS "void esThdInit (\fBesThd_T\fP *thd, void(*)(void *)fn, void *arg, \fBportStck_T\fP *stck, size_tstckSize, uint8_tprio)"

.PP
Initialize the specified thread\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthd\fP Thread: is a pointer to the thread structure, \fBesThd\fP\&. The structure will be used as information container for the thread\&. It is assumed that storage for the \fC\fBesThd\fP\fP structure is allocated by the user code\&. 
.br
\fIfn\fP Function: is a pointer to thread function\&. Thread function must have the following signature: \fCvoid thread (void * arg)\fP\&. 
.br
\fIarg\fP Argument: is a void pointer to an optional data area\&. It's usage is application defined and it is intended to pass arguments to thread when it is started for the first time\&. 
.br
\fIstck\fP Stack: is a pointer to a allocated memory for thread stack\&. The pointer always points to the first element in the array, regardless of what type of stack the CPU is using\&. The thread's stack is used to store local variables, function parameters, return addresses\&. Each thread has its own stack and different sized stack\&. The stack type must be an array of \fBportStck\fP\&. 
.br
\fIstckSize\fP Stack Size: specifies the size of allocated stack memory\&. Size is expressed in bytes\&. Please see port documentation about minimal stack size\&. Usage of C unary operator \fCsizeof\fP is the recommended way of specifying stack size\&. Another way of specifying required stack size is through the usage of \fBES_STCK_SIZE\fP macro\&. 
.br
\fIprio\fP Priority: is the priority of the thread\&. The higher the number, the higher the priority (the importance) of the thread\&. Several threads can have the same priority\&. Note that lowest (0) and highest (CFG_SCHED_PRIO_LVL - 1) levels are reserved for kernel threads only\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state ES_KERN_INACTIVE\fP, see \fBKernel states\fP\&. 
.PP
2) \fCthd != NULL\fP 
.PP
3) \fCthd->signature != DEF_THD_CONTRACT_SIGNATURE\fP, the thread structure can't be initialized more than once\&. 
.PP
4) \fCfn != NULL\fP 
.PP
5) \fCstckSize >= PORT_DEF_STCK_MINSIZE\fP, see \fBPORT_DEF_STCK_MINSIZE\fP\&. 
.PP
6) \fC0 < prio < CFG_SCHED_PRIO_LVL - 1\fP, see \fBCFG_SCHED_PRIO_LVL\fP\&. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
1) \fCthd->signature == DEF_THD_CONTRACT_SIGNATURE\fP, each \fBesThd\fP structure will have valid signature after initialization\&.
.RE
.PP
Threads must be created in order for kernel to recognize them as threads\&. Initialize a thread by calling \fBesThdInit()\fP and provide arguments specifying to kernel how the thread will be managed\&. Threads are always created in the \fCready-to-run\fP state\&. Threads can be created either prior to the start of multi-threading (before calling \fBesKernStart()\fP), or by a running thread\&. 
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application initialization code
.IP "\(bu" 2
Application thread code 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
possible 
.PP
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SS "void esThdTerm (\fBesThd_T\fP *thd)"

.PP
Terminate the specified thread\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthd\fP Thread: is a pointer to the thread structure, \fBesThd\fP\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state ES_KERN_INACTIVE\fP, see \fBKernel states\fP\&. 
.PP
2) \fCthd != NULL\fP 
.PP
3) \fCthd->signature == DEF_THD_CONTRACT_SIGNATURE\fP, the pointer must point to a valid \fBesThd\fP structure\&. 
.PP
4) \fC(thd->thdL_\&.q == NULL) OR (thd->thdL_\&.q == gRdyQueue)\fP, thread must be either in Ready Threads Queue or not be in any queue (e\&.g\&. not waiting for a synchronization mechanism)\&. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
1) \fCthd->signature == ~DEF_THD_CONTRACT_SIGNATURE\fP, each \fBesThd\fP structure will have invalid signature after termination\&. 
.RE
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application initialization code
.IP "\(bu" 2
Application thread code 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
possible 
.PP
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SS "void esThdSetPrioI (\fBesThd_T\fP *thd, uint8_tprio)"

.PP
Set the priority of a thread\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthd\fP Thread: is pointer to the thread structure, \fBesThd\fP\&. 
.br
\fIprio\fP Priority: is new priority of the thread pointed by \fCthd\fP\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INACTIVE\fP, see \fBKernel states\fP\&. 
.PP
2) \fCthd != NULL\fP 
.PP
3) \fCthd->signature == DEF_THD_CONTRACT_SIGNATURE\fP, the pointer must point to a valid \fBesThd\fP structure\&. 
.PP
4) \fC0 < prio < CFG_SCHED_PRIO_LVL - 1\fP, see \fBCFG_SCHED_PRIO_LVL\fP\&. 
.RE
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application initialization code
.IP "\(bu" 2
Application thread code
.IP "\(bu" 2
Interrupt service routine 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
possible 
.PP
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "void esThdQInit (\fBesThdQ_T\fP *thdQ)"

.PP
Initialize Thread Queue\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthdQ\fP Thread Queue: is a pointer to thread queue structure, \fBesThdQ\fP\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCthdQ != NULL\fP 
.PP
2) \fCthdQ->signature != DEF_THDQ_CONTRACT_SIGNATURE\fP, the thread queue structure can't be initialized more than once\&. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
1) \fCthdQ->signature == DEF_THDQ_CONTRACT_SIGNATURE\fP, each \fBesThdQ\fP structure will have valid signature after initialization\&. 
.RE
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application initialization code
.IP "\(bu" 2
Application thread code
.IP "\(bu" 2
Interrupt service routine 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
never 
.PP
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SS "void esThdQTerm (\fBesThdQ_T\fP *thdQ)"

.PP
Terminate Thread Queue\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthdQ\fP Thread Queue: is a pointer to thread queue structure, \fBesThdQ\fP\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCthdQ != NULL\fP 
.PP
2) \fCthdQ->signature == DEF_THDQ_CONTRACT_SIGNATURE\fP, the thread queue structure must be already initialized\&. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
1) \fCthdQ->signature == ~DEF_THDQ_CONTRACT_SIGNATURE\fP, each \fBesThdQ\fP structure will have invalid signature after termination\&. 
.RE
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application initialization code
.IP "\(bu" 2
Application thread code
.IP "\(bu" 2
Interrupt service routine 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
never 
.PP
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SS "void esThdQAddI (\fBesThdQ_T\fP *thdQ, \fBesThd_T\fP *thd)"

.PP
Add a thread to the Thread Queue\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthdQ\fP Thread Queue: is a pointer to thread queue structure, \fBesThdQ\fP\&. 
.br
\fIthd\fP Thread: is a pointer to the thread ID structure, \fBesThd\fP\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCthdQ != NULL\fP 
.PP
2) \fCthdQ->signature == DEF_THDQ_CONTRACT_SIGNATURE\fP, the pointer must point to a valid \fBesThdQ\fP structure\&. 
.PP
3) \fCthd != NULL\fP 
.PP
4) \fCthd->signature == DEF_THD_CONTRACT_SIGNATURE\fP, the pointer must point to a valid \fBesThd\fP structure\&. 
.PP
5) \fCthd->thdL_\&.q == NULL\fP, thread must not be in any queue\&.
.RE
.PP
This function adds a thread at the specified Thread Queue\&. 
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application initialization code
.IP "\(bu" 2
Application thread code
.IP "\(bu" 2
Interrupt service routine 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
never 
.PP
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "void esThdQRmI (\fBesThdQ_T\fP *thdQ, \fBesThd_T\fP *thd)"

.PP
Removes the thread from the Thread Queue\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthdQ\fP Thread Queue: is a pointer to thread queue structure, \fBesThdQ\fP\&. 
.br
\fIthd\fP Thread: is a pointer to the thread ID structure, \fBesThd\fP\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCthd != NULL\fP 
.PP
2) \fCthd->signature == DEF_THD_CONTRACT_SIGNATURE\fP, the pointer must point to a valid \fBesThd\fP structure\&. 
.PP
3) \fCthdQ != NULL\fP 
.PP
4) \fCthdQ->signature == DEF_THDQ_CONTRACT_SIGNATURE\fP, the pointer must point to a valid \fBesThdQ\fP structure\&. 
.PP
5) \fCthd->thdL_\&.q == thdQ\fP, thread must be in the \fCthdQ\fP queue\&. 
.RE
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application initialization code
.IP "\(bu" 2
Application thread code
.IP "\(bu" 2
Interrupt service routine 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
never 
.PP
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "\fBesThd_T\fP* esThdQFetchI (const \fBesThdQ_T\fP *thdQ)"

.PP
Fetch the first high priority thread from the Thread Queue\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthdQ\fP Thread Queue: is a pointer to thread queue structure, \fBesThdQ\fP\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
A pointer to the thread ID structure with the highest priority\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCthdQ != NULL\fP 
.PP
2) \fCthdQ->signature == DEF_THDQ_CONTRACT_SIGNATURE\fP, the pointer must point to a valid \fBesThdQ\fP structure\&. 
.PP
3) \fCpbm_ != 0\fP, priority bit map must not be empty 
.RE
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application initialization code
.IP "\(bu" 2
Application thread code
.IP "\(bu" 2
Interrupt service routine 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
never 
.PP
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "\fBesThd_T\fP* esThdQFetchRotateI (\fBesThdQ_T\fP *thdQ, uint_fast8_tprio)"

.PP
Fetch the next thread and rotate thread linked list\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthdQ\fP Thread Queue: is a pointer to thread queue structure, \fBesThdQ\fP\&. This is the thread queue to fetch from\&. 
.br
\fIprio\fP Priority: is the priority level to fetch and rotate\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Pointer to the next thread in queue\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCthdQ != NULL\fP 
.PP
2) \fCthdQ->signature == DEF_THDQ_CONTRACT_SIGNATURE\fP, the pointer must point to a valid \fBesThdQ\fP structure\&. 
.PP
3) \fC0 <= prio <= CFG_SCHED_PRIO_LVL\fP, see \fBCFG_SCHED_PRIO_LVL\fP\&. 
.PP
4) \fCsentinel != NULL\fP, at least one thread must be in the selected priority level 
.RE
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application initialization code
.IP "\(bu" 2
Application thread code
.IP "\(bu" 2
Interrupt service routine 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
never 
.PP
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "\fBbool_T\fP esThdQIsEmpty (const \fBesThdQ_T\fP *thdQ)"

.PP
Is thread queue empty\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthdQ\fP Thread Queue: is a pointer to thread queue structure, \fBesThdQ\fP\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
The state of thread queue 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fITRUE\fP - thread queue is empty 
.br
\fIFALSE\fP - thread queue is not empty 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCthdQ != NULL\fP 
.PP
2) \fCthdQ->signature == DEF_THDQ_CONTRACT_SIGNATURE\fP, the pointer must point to a valid \fBesThdQ\fP structure\&. 
.RE
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application initialization code
.IP "\(bu" 2
Application thread code
.IP "\(bu" 2
Interrupt service routine 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
never 
.PP
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SS "void esSchedRdyAddI (\fBesThd_T\fP *thd)"

.PP
Add thread \fCthd\fP to the ready thread list and notify the scheduler\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthd\fP Pointer to the initialized thread ID structure, \fBesThd\fP\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INACTIVE\fP, see \fBKernel states\fP\&. 
.PP
2) \fCthd != NULL\fP 
.PP
3) \fCthd->signature == DEF_THD_CONTRACT_SIGNATURE\fP, the pointer must point to a valid \fBesThd\fP structure\&. 
.PP
4) \fCthd->thdL_\&.q == NULL\fP, thread must not be in a queue\&. 
.RE
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application initialization code
.IP "\(bu" 2
Application thread code
.IP "\(bu" 2
Interrupt service routine 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
never 
.PP
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "void esSchedRdyRmI (\fBesThd_T\fP *thd)"

.PP
Remove thread \fCthd\fP from the ready thread list and notify the scheduler\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthd\fP Pointer to the initialized thread ID structure, \fBesThd\fP\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INACTIVE\fP, see \fBKernel states\fP\&. 
.PP
2) \fCthd != NULL\fP 
.PP
3) \fCthd->signature == DEF_THD_CONTRACT_SIGNATURE\fP, the pointer must point to a valid \fBesThd\fP structure\&. 
.PP
4) \fCthd->thdL_\&.q == &gRdyQueue\fP, thread must be in Ready Threads queue\&. 
.RE
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application initialization code
.IP "\(bu" 2
Application thread code
.IP "\(bu" 2
Interrupt service routine 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
never 
.PP
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "void esSchedYieldI (void)"

.PP
Force the scheduler invocation which will evaluate all ready threads and switch to ready thread with the highest priority\&. 
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INACTIVE\fP, see \fBKernel states\fP\&. 
.RE
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application thread code 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
possible 
.PP
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "void esSchedYieldIsrI (void)"

.PP
Force the scheduler invocation which will evaluate all ready threads and switch to ready thread with the highest priority\&. 
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INACTIVE\fP, see \fBKernel states\fP\&. 
.RE
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Interrupt service routine 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
possible 
.PP
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "void esVTmrInitI (\fBesVTmr_T\fP *vTmr, \fBesTick_T\fPtick, void(*)(void *)fn, void *arg)"

.PP
Add and start a new virtual timer\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvTmr\fP Virtual Timer: is pointer to the timer ID structure, \fBesVTmr\fP\&. 
.br
\fItick\fP Tick: the timer delay expressed in system ticks 
.br
\fIfn\fP Function: is pointer to the callback function 
.br
\fIarg\fP Argument: is pointer to the arguments of callback function 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INACTIVE\fP, see \fBKernel states\fP\&. 
.PP
2) \fCvTmr != NULL\fP 
.PP
3) \fCvTmr->signature != DEF_VTMR_CONTRACT_SIGNATURE\fP, the timer structure can't be initialized more than once\&. 
.PP
4) \fCtick > 1U\fP 
.PP
5) \fCfn != NULL\fP 
.RE
.PP
\fBPostcondition:\fP
.RS 4
1) \fCvTmr->signature == DEF_VTMR_CONTRACT_SIGNATURE\fP, each \fBesVTmr\fP structure will have valid signature after initialization\&. 
.RE
.PP
\fBNote:\fP
.RS 4
The callback function is invoked from interrupt context\&. 
.RE
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application initialization code
.IP "\(bu" 2
Application thread code
.IP "\(bu" 2
Interrupt service routine 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
never 
.PP
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "void esVTmrInit (\fBesVTmr_T\fP *vTmr, \fBesTick_T\fPtick, void(*)(void *)fn, void *arg)"

.PP
Add and start a new virtual timer\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvTmr\fP Virtual Timer: is pointer to the timer ID structure, \fBesVTmr\fP\&. 
.br
\fItick\fP Tick: the timer delay expressed in system ticks 
.br
\fIfn\fP Function: is pointer to the callback function 
.br
\fIarg\fP Argument: is pointer to the arguments of callback function 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INACTIVE\fP, see \fBKernel states\fP\&. 
.PP
2) \fCvTmr != NULL\fP 
.PP
3) \fCvTmr->signature != DEF_VTMR_CONTRACT_SIGNATURE\fP, the timer structure can't be initialized more than once\&. 
.PP
4) \fCtick > 1U\fP 
.PP
5) \fCfn != NULL\fP 
.RE
.PP
\fBPostcondition:\fP
.RS 4
1) \fCvTmr->signature == DEF_VTMR_CONTRACT_SIGNATURE\fP, each \fBesVTmr\fP structure will have valid signature after initialization\&. 
.RE
.PP
\fBNote:\fP
.RS 4
The callback function is invoked from interrupt context\&. 
.RE
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application initialization code
.IP "\(bu" 2
Application thread code
.IP "\(bu" 2
Interrupt service routine 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
never 
.PP
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SS "void esVTmrTermI (\fBesVTmr_T\fP *vTmr)"

.PP
Cancel and remove a virtual timer\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvTmr\fP Timer: is pointer to the timer ID structure, \fBesVTmr\fP\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INACTIVE\fP, see \fBKernel states\fP\&. 
.PP
2) \fCvTmr != NULL\fP 
.PP
3) \fCvTmr->signature == DEF_VTMR_CONTRACT_SIGNATURE\fP, the pointer must point to a valid \fBesVTmr\fP structure\&. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
1) \fCvTmr->signature = ~DEF_VTMR_CONTRACT_SIGNATURE\fP, each \fBesVTmr\fP structure will have invalid signature after termination\&. 
.RE
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application initialization code
.IP "\(bu" 2
Application thread code
.IP "\(bu" 2
Interrupt service routine 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
never 
.PP
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "void esVTmrTerm (\fBesVTmr_T\fP *vTmr)"

.PP
Cancel and remove a virtual timer\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvTmr\fP Timer: is pointer to the timer ID structure, \fBesVTmr\fP\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INACTIVE\fP, see \fBKernel states\fP\&. 
.PP
2) \fCvTmr != NULL\fP 
.PP
3) \fCvTmr->signature == DEF_VTMR_CONTRACT_SIGNATURE\fP, the pointer must point to a valid \fBesVTmr\fP structure\&. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
1) \fCvTmr->signature = ~DEF_VTMR_CONTRACT_SIGNATURE\fP, each \fBesVTmr\fP structure will have invalid signature after termination\&. 
.RE
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application initialization code
.IP "\(bu" 2
Application thread code
.IP "\(bu" 2
Interrupt service routine 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
never 
.PP
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SS "void esVTmrDelay (\fBesTick_T\fPtick)"

.PP
Delay for specified amount of ticks\&. 
.PP
\fBParameters:\fP
.RS 4
\fItick\fP Tick: number of system ticks to delay\&.
.RE
.PP
This function will create a virtual timer with count down time specified in argument \fCtick\fP and put the calling thread into \fCsleep\fP state\&. When timeout expires the thread will be placed back into \fCready\fP state\&. 
.PP
\fBNote:\fP
.RS 4
The sleeping thread can not be safely awaken until the specified time does not expire\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCtick > 1u\fP 
.RE
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application initialization code
.IP "\(bu" 2
Application thread code
.IP "\(bu" 2
Interrupt service routine 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
always 
.PP
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SS "\fBesTick_T\fP esSysTmrTickGet (void)"

.PP
Get the current tick value\&. 
.PP
\fBReturns:\fP
.RS 4
Current tick value 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INACTIVE\fP, see \fBKernel states\fP\&. 
.RE
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application initialization code
.IP "\(bu" 2
Application thread code
.IP "\(bu" 2
Interrupt service routine 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
never 
.PP
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SH "Variable Documentation"
.PP 
.SS "struct \fBesThdQ\fP RdyQueue\fC [static]\fP"

.PP
Ready Thread queue\&. 
.SS "struct \fBsysTmr\fP SysTmr\fC [static]\fP"
\fBInitial value:\fP
.PP
.nf
= {
    0u,
    0u,
    0u,



}
.fi
.PP
Main System Timer structure\&. 
.SS "struct \fBesVTmr\fP VTmrArmed\fC [static]\fP"
\fBInitial value:\fP
.PP
.nf
= {
   {
        &VTmrArmed,
        &VTmrArmed,
        &VTmrArmed
   },


   UINT_FAST8_MAX,





   NULL,
   NULL,



}
.fi
.PP
List of virtual armed timers waiting to expire\&. 
.SS "struct \fBesVTmr\fP VTmrPend\fC [static]\fP"
\fBInitial value:\fP
.PP
.nf
= {
   {
        &VTmrPend,
        &VTmrPend,
        &VTmrPend
   },
   0u,
   NULL,
   NULL,



}
.fi
.PP
Virtual timers pending to be inserted into waiting list\&. 
.SS "struct \fBesThd\fP KVTmr\fC [static]\fP"

.PP
Virtual timer thread ID\&. 
.SS "struct \fBesThd\fP KIdle\fC [static]\fP"

.PP
Idle thread ID\&. 
.SS "uint_fast8_t KernLockCnt\fC [static]\fP"

.PP
Kernel Lock Counter\&. 
.SS "const struct \fBkernCtrl_\fP KernCtrl"
\fBInitial value:\fP
.PP
.nf
= {
    NULL,                                                                       
    NULL,                                                                       
    ES_KERN_INACTIVE                                                            
}
.fi
.PP
Kernel control initialization\&. Kernel control block\&. 
.SH "Author"
.PP 
Generated automatically by Doxygen for eSolid - Real-Time Kernel from the source code\&.
