.TH "Interface" 3 "Tue Oct 29 2013" "Version 1.0BetaR01" "eSolid - Real-Time Kernel" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Interface \- 
.PP
Application programming interface\&.  

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBesThd\fP"
.br
.RI "\fIThread structure\&. \fP"
.ti -1c
.RI "struct \fBesVTmr\fP"
.br
.RI "\fIVirtual Timer structure\&. \fP"
.ti -1c
.RI "struct \fBesThdQ\fP"
.br
.RI "\fIThread Queue structure\&. \fP"
.ti -1c
.RI "struct \fBesKernCtrl\fP"
.br
.RI "\fIKernel control block structure\&. \fP"
.in -1c
.SS "Kernel identification and version number"

.in +1c
.ti -1c
.RI "#define \fBES_KERN_VER\fP   0x10000ul"
.br
.RI "\fIIdentifies the underlying kernel version number\&. \fP"
.ti -1c
.RI "#define \fBES_KERN_ID\fP   'eSolid Kernel v1\&.0'"
.br
.RI "\fIKernel identification string\&. \fP"
.in -1c
.SS "Critical section management"
These macros are used to prevent interrupts on entry into the critical section, and restoring interrupts to their previous state on exit from critical section\&.
.PP
For more details see \fBCritical sections\fP\&. 
.in +1c
.ti -1c
.RI "#define \fBES_CRITICAL_T\fP   PORT_CRITICAL_T"
.br
.RI "\fICritical section context variable type\&. \fP"
.ti -1c
.RI "#define \fBES_CRITICAL_ENTER\fP(ctx)   \fBPORT_CRITICAL_ENTER\fP(ctx)"
.br
.RI "\fIEnter a critical section\&. \fP"
.ti -1c
.RI "#define \fBES_CRITICAL_EXIT\fP(ctx)   \fBPORT_CRITICAL_EXIT\fP(ctx)"
.br
.RI "\fIExit from critical section\&. \fP"
.ti -1c
.RI "#define \fBES_CRITICAL_ENTER_LOCK_EXIT\fP()"
.br
.RI "\fIEnter critical section and exit scheduler lock\&. \fP"
.ti -1c
.RI "#define \fBES_CRITICAL_EXIT_LOCK_ENTER\fP()"
.br
.RI "\fIExit critical section and enter scheduler lock\&. \fP"
.in -1c
.SS "Thread management"
Basic thread management services
.PP
For more details see \fBThread Management\fP\&. 
.in +1c
.ti -1c
.RI "typedef struct \fBesThd\fP \fBesThd_T\fP"
.br
.RI "\fIThread type\&. \fP"
.ti -1c
.RI "typedef \fBportStck_T\fP \fBesStck_T\fP"
.br
.RI "\fIStack type\&. \fP"
.ti -1c
.RI "void \fBesThdInit\fP (\fBesThd_T\fP *thd, void(*fn)(void *), void *arg, \fBportStck_T\fP *stck, size_t stckSize, uint8_t prio)"
.br
.RI "\fIInitialize the specified thread\&. \fP"
.ti -1c
.RI "void \fBesThdTerm\fP (\fBesThd_T\fP *thd)"
.br
.RI "\fITerminate the specified thread\&. \fP"
.ti -1c
.RI "static \fBPORT_C_INLINE\fP \fBesThd_T\fP * \fBesThdGetId\fP (void)"
.br
.RI "\fIGet the current thread ID\&. \fP"
.ti -1c
.RI "static \fBPORT_C_INLINE\fP uint8_t \fBesThdGetPrio\fP (\fBesThd_T\fP *thd)"
.br
.RI "\fIGet the priority of a thread\&. \fP"
.ti -1c
.RI "void \fBesThdSetPrioI\fP (\fBesThd_T\fP *thd, uint8_t prio)"
.br
.RI "\fISet the priority of a thread\&. \fP"
.ti -1c
.RI "void \fBesThdPostI\fP (\fBesThd_T\fP *thd)"
.br
.RI "\fIPost to thread semaphore\&. \fP"
.ti -1c
.RI "void \fBesThdPost\fP (\fBesThd_T\fP *thd)"
.br
.RI "\fIPost to thread semaphore\&. \fP"
.ti -1c
.RI "void \fBesThdWaitI\fP (void)"
.br
.RI "\fIWait for thread semaphore\&. \fP"
.ti -1c
.RI "void \fBesThdWait\fP (void)"
.br
.RI "\fIWait for thread semaphore\&. \fP"
.ti -1c
.RI "#define \fBES_STCK_SIZE\fP(elem)   \fBPORT_STCK_SIZE\fP(elem)"
.br
.RI "\fIConverts the required stack elements into the stack array index\&. \fP"
.ti -1c
.RI "#define \fBES_THD_PRIO_MAX\fP   (\fBCFG_SCHED_PRIO_LVL\fP - 2u)"
.br
.ti -1c
.RI "#define \fBES_THD_PRIO_MIN\fP   (1u)"
.br
.in -1c
.SS "Virtual Timer management"

.in +1c
.ti -1c
.RI "typedef uint_fast32_t \fBesTick_T\fP"
.br
.RI "\fITimer tick type\&. \fP"
.ti -1c
.RI "typedef struct \fBesVTmr\fP \fBesVTmr_T\fP"
.br
.RI "\fIVirtual Timer type\&. \fP"
.ti -1c
.RI "void \fBesVTmrInitI\fP (\fBesVTmr_T\fP *vTmr, \fBesTick_T\fP tick, void(*fn)(void *), void *arg)"
.br
.RI "\fIAdd and start a new virtual timer\&. \fP"
.ti -1c
.RI "void \fBesVTmrInit\fP (\fBesVTmr_T\fP *vTmr, \fBesTick_T\fP tick, void(*fn)(void *), void *arg)"
.br
.RI "\fIAdd and start a new virtual timer\&. \fP"
.ti -1c
.RI "void \fBesVTmrTermI\fP (\fBesVTmr_T\fP *vTmr)"
.br
.RI "\fICancel and remove a virtual timer\&. \fP"
.ti -1c
.RI "void \fBesVTmrTerm\fP (\fBesVTmr_T\fP *vTmr)"
.br
.RI "\fICancel and remove a virtual timer\&. \fP"
.ti -1c
.RI "void \fBesVTmrDelay\fP (\fBesTick_T\fP tick)"
.br
.RI "\fIDelay for specified amount of ticks\&. \fP"
.ti -1c
.RI "\fBesTick_T\fP \fBesSysTmrTickGet\fP (void)"
.br
.in -1c
.SS "Thread Queue management"

.in +1c
.ti -1c
.RI "typedef struct \fBesThdQ\fP \fBesThdQ_T\fP"
.br
.RI "\fIThread queue type\&. \fP"
.ti -1c
.RI "void \fBesThdQInit\fP (\fBesThdQ_T\fP *thdQ)"
.br
.RI "\fIInitialize Thread Queue\&. \fP"
.ti -1c
.RI "void \fBesThdQTerm\fP (\fBesThdQ_T\fP *thdQ)"
.br
.RI "\fITerminate Thread Queue\&. \fP"
.ti -1c
.RI "void \fBesThdQAddI\fP (\fBesThdQ_T\fP *thdQ, \fBesThd_T\fP *thd)"
.br
.RI "\fIAdd a thread to the Thread Queue\&. \fP"
.ti -1c
.RI "void \fBesThdQRmI\fP (\fBesThdQ_T\fP *thdQ, \fBesThd_T\fP *thd)"
.br
.RI "\fIRemoves the thread from the Thread Queue\&. \fP"
.ti -1c
.RI "\fBesThd_T\fP * \fBesThdQFetchI\fP (const \fBesThdQ_T\fP *thdQ)"
.br
.RI "\fIFetch the first high priority thread from the Thread Queue\&. \fP"
.ti -1c
.RI "\fBesThd_T\fP * \fBesThdQFetchRotateI\fP (\fBesThdQ_T\fP *thdQ, uint_fast8_t prio)"
.br
.RI "\fIFetch the next thread and rotate thread linked list\&. \fP"
.ti -1c
.RI "\fBbool_T\fP \fBesThdQIsEmpty\fP (const \fBesThdQ_T\fP *thdQ)"
.br
.RI "\fIIs thread queue empty\&. \fP"
.ti -1c
.RI "#define \fBPRIO_BM_GRP_INDX\fP   ((\fBCFG_SCHED_PRIO_LVL\fP + PORT_DEF_DATA_WIDTH - 1u) / PORT_DEF_DATA_WIDTH)"
.br
.RI "\fIPriority Bit Map Group Index\&. \fP"
.in -1c
.SS "Kernel control block"

.in +1c
.ti -1c
.RI "enum \fBesKernState\fP { \fBES_KERN_RUN\fP = 0x00u, \fBES_KERN_INTSRV_RUN\fP = 0x01u, \fBES_KERN_LOCK\fP = 0x02u, \fBES_KERN_INTSRV_LOCK\fP = 0x03u, \fBES_KERN_SLEEP\fP = 0x06u, \fBES_KERN_INIT\fP = 0x08u, \fBES_KERN_INACTIVE\fP = 0x10u }"
.br
.RI "\fIKernel state enumeration\&. \fP"
.ti -1c
.RI "typedef enum \fBesKernState\fP \fBesKernState_T\fP"
.br
.RI "\fIKernel state type\&. \fP"
.ti -1c
.RI "typedef struct \fBesKernCtrl\fP \fBesKernCtrl_T\fP"
.br
.RI "\fIKernel control block type\&. \fP"
.ti -1c
.RI "const volatile \fBesKernCtrl_T\fP \fBgKernCtrl\fP"
.br
.RI "\fIKernel control block\&. \fP"
.in -1c
.SS "General kernel functions"
There are several groups of functions:
.IP "\(bu" 2
kernel initialization and start
.IP "\(bu" 2
ISR prologue and epilogue 
.PP

.in +1c
.ti -1c
.RI "void \fBesKernInit\fP (void)"
.br
.RI "\fIInitialize kernel internal data structures\&. \fP"
.ti -1c
.RI "PORT_C_NORETURN void \fBesKernStart\fP (void)"
.br
.RI "\fIStart the multi-threading\&. \fP"
.ti -1c
.RI "void \fBesKernSysTmr\fP (void)"
.br
.RI "\fIProcess the system timer event\&. \fP"
.ti -1c
.RI "void \fBesKernIsrPrologueI\fP (void)"
.br
.RI "\fIEnter Interrupt Service Routine\&. \fP"
.ti -1c
.RI "void \fBesKernIsrEpilogueI\fP (void)"
.br
.RI "\fIExit Interrupt Service Routine\&. \fP"
.in -1c
.SS "Scheduler notification and invocation"

.in +1c
.ti -1c
.RI "void \fBesSchedRdyAddI\fP (\fBesThd_T\fP *thd)"
.br
.RI "\fIAdd thread \fCthd\fP to the ready thread list and notify the scheduler\&. \fP"
.ti -1c
.RI "void \fBesSchedRdyRmI\fP (\fBesThd_T\fP *thd)"
.br
.RI "\fIRemove thread \fCthd\fP from the ready thread list and notify the scheduler\&. \fP"
.ti -1c
.RI "void \fBesSchedYieldI\fP (void)"
.br
.RI "\fIForce the scheduler invocation which will evaluate all ready threads and switch to ready thread with the highest priority\&. \fP"
.ti -1c
.RI "void \fBesSchedYieldIsrI\fP (void)"
.br
.RI "\fIForce the scheduler invocation which will evaluate all ready threads and switch to ready thread with the highest priority\&. \fP"
.ti -1c
.RI "void \fBesSchedLockEnterI\fP (void)"
.br
.RI "\fILock the scheduler\&. \fP"
.ti -1c
.RI "void \fBesSchedLockExitI\fP (void)"
.br
.RI "\fIUnlock the scheduler\&. \fP"
.ti -1c
.RI "void \fBesSchedLockEnter\fP (void)"
.br
.RI "\fILock the scheduler\&. \fP"
.ti -1c
.RI "void \fBesSchedLockExit\fP (void)"
.br
.RI "\fIUnlock the scheduler\&. \fP"
.in -1c
.SS "Kernel hook functions"

.PP
\fBNote:\fP
.RS 4
1) The definition of this functions must be written by the user\&. 
.RE
.PP

.in +1c
.ti -1c
.RI "void \fBuserPreSysTmr\fP (void)"
.br
.RI "\fISystem timer hook function, called from system system timer ISR function before the kernel functions\&. \fP"
.ti -1c
.RI "void \fBuserPreKernInit\fP (void)"
.br
.RI "\fIKernel initialization hook function, called from \fBesKernInit()\fP function before kernel initialization\&. \fP"
.ti -1c
.RI "void \fBuserPostKernInit\fP (void)"
.br
.RI "\fIKernel initialization hook function, called from \fBesKernInit()\fP function after kernel initialization\&. \fP"
.ti -1c
.RI "void \fBuserPreKernStart\fP (void)"
.br
.RI "\fIKernel start hook function, called from \fBesKernStart()\fP function\&. \fP"
.ti -1c
.RI "void \fBuserPostThdInit\fP (\fBesThd_T\fP *thd)"
.br
.RI "\fIThread initialization end hook function, called from \fBesThdInit()\fP function\&. \fP"
.ti -1c
.RI "void \fBuserPreThdTerm\fP (void)"
.br
.RI "\fIThread terminate hook function, called from \fBesThdTerm()\fP or when a thread terminates itself\&. \fP"
.ti -1c
.RI "void \fBuserPreIdle\fP (void)"
.br
.RI "\fIPre Idle hook function, called from idle thread, just before entering idle period\&. \fP"
.ti -1c
.RI "void \fBuserPostIdle\fP (void)"
.br
.RI "\fIPost idle hook function, called from idle thread, just after exiting idle period\&. \fP"
.ti -1c
.RI "void \fBuserPreCtxSw\fP (\fBesThd_T\fP *oldThd, \fBesThd_T\fP *newThd)"
.br
.RI "\fIKernel context switch hook function, called from \fBesSchedYieldI()\fP and \fBesSchedYieldIsrI()\fP functions just before context switch\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
Application programming interface\&. 


.SH "Macro Definition Documentation"
.PP 
.SS "#define ES_KERN_VER   0x10000ul"

.PP
Identifies the underlying kernel version number\&. Kernel identification and version (main [31:16] \&.sub [15:0]) 
.SS "#define ES_KERN_ID   'eSolid Kernel v1\&.0'"

.PP
Kernel identification string\&. 
.SS "#define ES_CRITICAL_T   PORT_CRITICAL_T"

.PP
Critical section context variable type\&. 
.SS "#define ES_CRITICAL_ENTER(ctx)   \fBPORT_CRITICAL_ENTER\fP(ctx)"

.PP
Enter a critical section\&. 
.SS "#define ES_CRITICAL_EXIT(ctx)   \fBPORT_CRITICAL_EXIT\fP(ctx)"

.PP
Exit from critical section\&. 
.SS "#define ES_CRITICAL_ENTER_LOCK_EXIT()"
\fBValue:\fP
.PP
.nf
do {                                                                        \\
        PORT_CRITICAL_ENTER();                                                  \\
        esSchedLockExitI();                                                     \
    } while (0U)
.fi
.PP
Enter critical section and exit scheduler lock\&. 
.SS "#define ES_CRITICAL_EXIT_LOCK_ENTER()"
\fBValue:\fP
.PP
.nf
do {                                                                        \\
        esSchedLockEnterI();                                                    \\
        PORT_CRITICAL_EXIT();                                                   \
    } while (0U)
.fi
.PP
Exit critical section and enter scheduler lock\&. 
.SS "#define ES_STCK_SIZE(elem)   \fBPORT_STCK_SIZE\fP(elem)"

.PP
Converts the required stack elements into the stack array index\&. 
.PP
\fBParameters:\fP
.RS 4
\fIelem\fP Number of stack elements: the stack size is expressed in number of elements regardles of the size of port general purpose registers\&. 
.RE
.PP

.SS "#define PRIO_BM_GRP_INDX   ((\fBCFG_SCHED_PRIO_LVL\fP + PORT_DEF_DATA_WIDTH - 1u) / PORT_DEF_DATA_WIDTH)"

.PP
Priority Bit Map Group Index\&. 
.PP
\fBObject class:\fP
.RS 4
\fBNot API\fP object, this object is not part of the application programming interface and it is intended for internal use only\&. 
.RE
.PP

.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fBesThd\fP \fBesThd_T\fP"

.PP
Thread type\&. 
.SS "typedef \fBportStck_T\fP \fBesStck_T\fP"

.PP
Stack type\&. 
.SS "typedef uint_fast32_t \fBesTick_T\fP"

.PP
Timer tick type\&. 
.SS "typedef struct \fBesVTmr\fP \fBesVTmr_T\fP"

.PP
Virtual Timer type\&. 
.SS "typedef struct \fBesThdQ\fP \fBesThdQ_T\fP"

.PP
Thread queue type\&. 
.SS "typedef enum \fBesKernState\fP \fBesKernState_T\fP"

.PP
Kernel state type\&. 
.SS "typedef struct \fBesKernCtrl\fP \fBesKernCtrl_T\fP"

.PP
Kernel control block type\&. 
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBesKernState\fP"

.PP
Kernel state enumeration\&. For more details see: \fBKernel states\fP 
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIES_KERN_RUN \fP\fP
Kernel is active 
.TP
\fB\fIES_KERN_INTSRV_RUN \fP\fP
Servicing an interrupt return to ES_KERN_RUN state 
.TP
\fB\fIES_KERN_LOCK \fP\fP
Kernel is locked 
.TP
\fB\fIES_KERN_INTSRV_LOCK \fP\fP
Servicing an interrupt, return to ES_KERN_LOCK state 
.TP
\fB\fIES_KERN_SLEEP \fP\fP
Kernel is sleeping 
.TP
\fB\fIES_KERN_INIT \fP\fP
Kernel is in initialization state 
.TP
\fB\fIES_KERN_INACTIVE \fP\fP
Kernel data structures are not initialized 
.SH "Function Documentation"
.PP 
.SS "void esKernInit (void)"

.PP
Initialize kernel internal data structures\&. 
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state == ES_KERN_INACTIVE\fP, see \fBKernel states\fP\&. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
1) \fCThe kernel state == ES_KERN_INIT\fP\&. 
.RE
.PP
\fBNote:\fP
.RS 4
1) This function may be invoked only once\&.
.RE
.PP
This function must be called first before any other kernel API\&. It initializes internal data structures that are used by other API functions\&. 
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application initialization code 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
never 
.PP
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SS "PORT_C_NORETURN void esKernStart (void)"

.PP
Start the multi-threading\&. 
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state == ES_KERN_INIT\fP, see \fBKernel states\fP\&. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
1) \fCThe kernel state == ES_KERN_RUN\fP 
.PP
2) The multi-threading execution will commence\&. 
.RE
.PP
\fBNote:\fP
.RS 4
1) Once this function is called the execution of threads will start and this function will never return\&.
.RE
.PP
This function will start multi-threading\&. Once the multi-threading has started the execution will never return to this function again (this function never returns)\&. 
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application initialization code 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
always 
.PP
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SS "void esKernSysTmr (void)"

.PP
Process the system timer event\&. 
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INIT\fP, see \fBKernel states\fP\&.
.RE
.PP
This function will be called only by port system timer interrupt\&. 
.PP
\fBObject class:\fP
.RS 4
\fBNot API\fP object, this object is not part of the application programming interface and it is intended for internal use only\&. 
.RE
.PP

.SS "void esKernIsrPrologueI (void)"

.PP
Enter Interrupt Service Routine\&. 
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INIT\fP, see \fBKernel states\fP\&. 
.RE
.PP
\fBNote:\fP
.RS 4
1) You must call \fBesKernIsrEpilogueI()\fP at the exit of ISR\&. 
.PP
2) You must invoke \fBesKernIsrPrologueI()\fP and \fBesKernIsrEpilogueI()\fP in pair\&. In other words, for every call to \fBesKernIsrPrologueI()\fP at the beginning of the ISR you must have a call to \fBesKernIsrEpilogueI()\fP at the end of the ISR\&.
.RE
.PP
Function will notify kernel that you are about to enter interrupt service routine (ISR)\&. This allows kernel to keep track of interrupt nesting and then only perform rescheduling at the last nested ISR\&. 
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Interrupt service routine 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
never 
.PP
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "void esKernIsrEpilogueI (void)"

.PP
Exit Interrupt Service Routine\&. 
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INIT\fP, see \fBKernel states\fP\&. 
.RE
.PP
\fBNote:\fP
.RS 4
1) You must invoke \fBesKernIsrPrologueI()\fP and \fBesKernIsrEpilogueI()\fP in pair\&. In other words, for every call to \fBesKernIsrPrologueI()\fP at the beginning of the ISR you must have a call to \fBesKernIsrEpilogueI()\fP at the end of the ISR\&. 
.PP
2) Rescheduling is prevented when the scheduler is locked (see \fBesSchedLockEnterI()\fP)
.RE
.PP
This function is used to notify kernel that you have completed servicing an interrupt\&. When the last nested ISR has completed, the function will call the scheduler to determine whether a new, high-priority task, is ready to run\&. 
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Interrupt service routine 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
possible 
.PP
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "void esThdInit (\fBesThd_T\fP *thd, void(*)(void *)fn, void *arg, \fBportStck_T\fP *stck, size_tstckSize, uint8_tprio)"

.PP
Initialize the specified thread\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthd\fP Thread: is a pointer to the thread structure, \fBesThd\fP\&. The structure will be used as information container for the thread\&. It is assumed that storage for the \fC\fBesThd\fP\fP structure is allocated by the user code\&. 
.br
\fIfn\fP Function: is a pointer to thread function\&. Thread function must have the following signature: \fCvoid thread (void * arg)\fP\&. 
.br
\fIarg\fP Argument: is a void pointer to an optional data area\&. It's usage is application defined and it is intended to pass arguments to thread when it is started for the first time\&. 
.br
\fIstck\fP Stack: is a pointer to a allocated memory for thread stack\&. The pointer always points to the first element in the array, regardless of what type of stack the CPU is using\&. The thread's stack is used to store local variables, function parameters, return addresses\&. Each thread has its own stack and different sized stack\&. The stack type must be an array of \fBportStck\fP\&. 
.br
\fIstckSize\fP Stack Size: specifies the size of allocated stack memory\&. Size is expressed in bytes\&. Please see port documentation about minimal stack size\&. Usage of C unary operator \fCsizeof\fP is the recommended way of specifying stack size\&. 
.br
\fIprio\fP Priority: is the priority of the thread\&. The higher the number, the higher the priority (the importance) of the thread\&. Several threads can have the same priority\&. Note that lowest (0) and highest (CFG_SCHED_PRIO_LVL - 1) levels are reserved for kernel threads only\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state ES_KERN_INACTIVE\fP, see \fBKernel states\fP\&. 
.PP
2) \fCthd != NULL\fP 
.PP
3) \fCthd->signature != THD_CONTRACT_SIGNATURE\fP, the thread structure can't be initialized more than once\&. 
.PP
4) \fCfn != NULL\fP 
.PP
5) \fCstckSize >= PORT_DEF_STCK_MINSIZE\fP, see \fBPORT_DEF_STCK_MINSIZE\fP\&. 
.PP
6) \fC0 < prio < CFG_SCHED_PRIO_LVL - 1\fP, see \fBCFG_SCHED_PRIO_LVL\fP\&. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
1) \fCthd->signature == THD_CONTRACT_SIGNATURE\fP, each \fBesThd\fP structure will have valid signature after initialization\&.
.RE
.PP
Threads must be created in order for kernel to recognize them as threads\&. Initialize a thread by calling \fBesThdInit()\fP and provide arguments specifying to kernel how the thread will be managed\&. Threads are always created in the \fCready-to-run\fP state\&. Threads can be created either prior to the start of multi-threading (before calling \fBesKernStart()\fP), or by a running thread\&. 
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application initialization code
.IP "\(bu" 2
Application thread code 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
possible 
.PP
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SS "void esThdTerm (\fBesThd_T\fP *thd)"

.PP
Terminate the specified thread\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthd\fP Thread: is a pointer to the thread structure, \fBesThd\fP\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state ES_KERN_INACTIVE\fP, see \fBKernel states\fP\&. 
.PP
2) \fCthd != NULL\fP 
.PP
3) \fCthd->signature == THD_CONTRACT_SIGNATURE\fP, the pointer must point to a valid \fBesThd\fP structure\&. 
.PP
4) \fC(thd->thdL\&.q == NULL) OR (thd->thdL\&.q == gRdyQueue)\fP, thread must be either in Ready Threads Queue or not be in any queue (e\&.g\&. not waiting for a synchronization mechanism)\&. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
1) \fCthd->signature == ~THD_CONTRACT_SIGNATURE\fP, each \fBesThd\fP structure will have invalid signature after termination\&. 
.RE
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application initialization code
.IP "\(bu" 2
Application thread code 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
possible 
.PP
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SS "static \fBPORT_C_INLINE\fP \fBesThd_T\fP* esThdGetId (void)\fC [static]\fP"

.PP
Get the current thread ID\&. 
.PP
\fBReturns:\fP
.RS 4
Pointer to current thread ID structure \fBesThd\fP\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This is \fCinline\fP function\&. 
.RE
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application initialization code
.IP "\(bu" 2
Application thread code
.IP "\(bu" 2
Interrupt service routine 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
never 
.PP
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SS "static \fBPORT_C_INLINE\fP uint8_t esThdGetPrio (\fBesThd_T\fP *thd)\fC [static]\fP"

.PP
Get the priority of a thread\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthd\fP Thread: is pointer to the thread structure, \fBesThd\fP\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
The priority of the thread pointed by \fCthd\fP\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This is \fCinline\fP function\&. 
.RE
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application initialization code
.IP "\(bu" 2
Application thread code
.IP "\(bu" 2
Interrupt service routine 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
never 
.PP
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SS "void esThdSetPrioI (\fBesThd_T\fP *thd, uint8_tprio)"

.PP
Set the priority of a thread\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthd\fP Thread: is pointer to the thread structure, \fBesThd\fP\&. 
.br
\fIprio\fP Priority: is new priority of the thread pointed by \fCthd\fP\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INACTIVE\fP, see \fBKernel states\fP\&. 
.PP
2) \fCthd != NULL\fP 
.PP
3) \fCthd->signature == THD_CONTRACT_SIGNATURE\fP, the pointer must point to a valid \fBesThd\fP structure\&. 
.PP
4) \fC0 < prio < CFG_SCHED_PRIO_LVL - 1\fP, see \fBCFG_SCHED_PRIO_LVL\fP\&. 
.RE
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application initialization code
.IP "\(bu" 2
Application thread code
.IP "\(bu" 2
Interrupt service routine 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
possible 
.PP
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "void esThdPostI (\fBesThd_T\fP *thd)"

.PP
Post to thread semaphore\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthd\fP Pointer to the thread ID structure 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INACTIVE\fP, see \fBKernel states\fP\&. 
.PP
2) \fCthd != NULL\fP 
.PP
3) \fCthd->signature == THD_CONTRACT_SIGNATURE\fP, the pointer must point to a valid \fBesThd\fP structure\&. 
.RE
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application initialization code
.IP "\(bu" 2
Application thread code
.IP "\(bu" 2
Interrupt service routine 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
possible 
.PP
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "void esThdPost (\fBesThd_T\fP *thd)"

.PP
Post to thread semaphore\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthd\fP Pointer to the thread ID structure 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INACTIVE\fP, see \fBKernel states\fP\&. 
.PP
2) \fCthd != NULL\fP 
.PP
3) \fCthd->signature == THD_CONTRACT_SIGNATURE\fP, the pointer must point to a valid \fBesThd\fP structure\&. 
.RE
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application initialization code
.IP "\(bu" 2
Application thread code 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
possible 
.PP
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SS "void esThdWaitI (void)"

.PP
Wait for thread semaphore\&. 
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state == ES_KERN_RUN\fP, see \fBKernel states\fP\&. 
.RE
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application thread code 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
always 
.PP
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "void esThdWait (void)"

.PP
Wait for thread semaphore\&. 
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state == ES_KERN_RUN\fP, see \fBKernel states\fP\&. 
.RE
.PP
\fBThis service can be called from:\fP
.RS 4

.IP "\(bu" 2
Application thread code 
.PP
.RE
.PP
\fBRescheduling:\fP
.RS 4

.IP "\(bu" 2
always 
.PP
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SS "void esThdQInit (\fBesThdQ_T\fP *thdQ)"

.PP
Initialize Thread Queue\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthdQ\fP Thread Queue: is a pointer to thread queue structure, \fBesThdQ\fP\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCthdQ != NULL\fP 
.PP
2) \fCthdQ->signature != THDQ_CONTRACT_SIGNATURE\fP, the thread queue structure can't be initialized more than once\&. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
1) \fCthdQ->signature == THDQ_CONTRACT_SIGNATURE\fP, each \fBesThdQ\fP structure will have valid signature after initialization\&. 
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SS "void esThdQTerm (\fBesThdQ_T\fP *thdQ)"

.PP
Terminate Thread Queue\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthdQ\fP Thread Queue: is a pointer to thread queue structure, \fBesThdQ\fP\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCthdQ != NULL\fP 
.PP
2) \fCthdQ->signature == THDQ_CONTRACT_SIGNATURE\fP, the thread queue structure must be already initialized\&. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
1) \fCthdQ->signature == ~THDQ_CONTRACT_SIGNATURE\fP, each \fBesThdQ\fP structure will have invalid signature after termination\&. 
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SS "void esThdQAddI (\fBesThdQ_T\fP *thdQ, \fBesThd_T\fP *thd)"

.PP
Add a thread to the Thread Queue\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthdQ\fP Thread Queue: is a pointer to thread queue structure, \fBesThdQ\fP\&. 
.br
\fIthd\fP Thread: is a pointer to the thread ID structure, \fBesThd\fP\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCthdQ != NULL\fP 
.PP
2) \fCthdQ->signature == THDQ_CONTRACT_SIGNATURE\fP, the pointer must point to a valid \fBesThdQ\fP structure\&. 
.PP
3) \fCthd != NULL\fP 
.PP
4) \fCthd->signature == THD_CONTRACT_SIGNATURE\fP, the pointer must point to a valid \fBesThd\fP structure\&. 
.PP
5) \fCthd->thdL\&.q == NULL\fP, thread must not be in any queue\&.
.RE
.PP
This function adds a thread at the specified Thread Queue\&. 
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "void esThdQRmI (\fBesThdQ_T\fP *thdQ, \fBesThd_T\fP *thd)"

.PP
Removes the thread from the Thread Queue\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthdQ\fP Thread Queue: is a pointer to thread queue structure, \fBesThdQ\fP\&. 
.br
\fIthd\fP Thread: is a pointer to the thread ID structure, \fBesThd\fP\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCthd != NULL\fP 
.PP
2) \fCthd->signature == THD_CONTRACT_SIGNATURE\fP, the pointer must point to a valid \fBesThd\fP structure\&. 
.PP
3) \fCthdQ != NULL\fP 
.PP
4) \fCthdQ->signature == THDQ_CONTRACT_SIGNATURE\fP, the pointer must point to a valid \fBesThdQ\fP structure\&. 
.PP
5) \fCthd->thdL\&.q == thdQ\fP, thread must be in the \fCthdQ\fP queue\&. 
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "\fBesThd_T\fP* esThdQFetchI (const \fBesThdQ_T\fP *thdQ)"

.PP
Fetch the first high priority thread from the Thread Queue\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthdQ\fP Thread Queue: is a pointer to thread queue structure, \fBesThdQ\fP\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
A pointer to the thread ID structure with the highest priority\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCthdQ != NULL\fP 
.PP
2) \fCthdQ->signature == THDQ_CONTRACT_SIGNATURE\fP, the pointer must point to a valid \fBesThdQ\fP structure\&. 
.PP
3) \fCprioBM != 0\fP, priority bit map must not be empty 
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "\fBesThd_T\fP* esThdQFetchRotateI (\fBesThdQ_T\fP *thdQ, uint_fast8_tprio)"

.PP
Fetch the next thread and rotate thread linked list\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthdQ\fP Thread Queue: is a pointer to thread queue structure, \fBesThdQ\fP\&. This is the thread queue to fetch from\&. 
.br
\fIprio\fP Priority: is the priority level to fetch and rotate\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Pointer to the next thread in queue\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCthdQ != NULL\fP 
.PP
2) \fCthdQ->signature == THDQ_CONTRACT_SIGNATURE\fP, the pointer must point to a valid \fBesThdQ\fP structure\&. 
.PP
3) \fC0 <= prio <= CFG_SCHED_PRIO_LVL\fP, see \fBCFG_SCHED_PRIO_LVL\fP\&. 
.PP
4) \fCsentinel != NULL\fP, at least one thread must be in the selected priority level 
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "\fBbool_T\fP esThdQIsEmpty (const \fBesThdQ_T\fP *thdQ)"

.PP
Is thread queue empty\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthdQ\fP Thread Queue: is a pointer to thread queue structure, \fBesThdQ\fP\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
The state of thread queue 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fITRUE\fP - thread queue is empty 
.br
\fIFALSE\fP - thread queue is not empty 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCthdQ != NULL\fP 
.PP
2) \fCthdQ->signature == THDQ_CONTRACT_SIGNATURE\fP, the pointer must point to a valid \fBesThdQ\fP structure\&. 
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SS "void esSchedRdyAddI (\fBesThd_T\fP *thd)"

.PP
Add thread \fCthd\fP to the ready thread list and notify the scheduler\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthd\fP Pointer to the initialized thread ID structure, \fBesThd\fP\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INACTIVE\fP, see \fBKernel states\fP\&. 
.PP
2) \fCthd != NULL\fP 
.PP
3) \fCthd->signature == THD_CONTRACT_SIGNATURE\fP, the pointer must point to a valid \fBesThd\fP structure\&. 
.PP
4) \fCthd->thdL\&.q == NULL\fP, thread must not be in a queue\&. 
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "void esSchedRdyRmI (\fBesThd_T\fP *thd)"

.PP
Remove thread \fCthd\fP from the ready thread list and notify the scheduler\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthd\fP Pointer to the initialized thread ID structure, \fBesThd\fP\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INACTIVE\fP, see \fBKernel states\fP\&. 
.PP
2) \fCthd != NULL\fP 
.PP
3) \fCthd->signature == THD_CONTRACT_SIGNATURE\fP, the pointer must point to a valid \fBesThd\fP structure\&. 
.PP
4) \fCthd->thdL\&.q == &gRdyQueue\fP, thread must be in Ready Threads queue\&. 
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "void esSchedYieldI (void)"

.PP
Force the scheduler invocation which will evaluate all ready threads and switch to ready thread with the highest priority\&. 
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INACTIVE\fP, see \fBKernel states\fP\&. 
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "void esSchedYieldIsrI (void)"

.PP
Force the scheduler invocation which will evaluate all ready threads and switch to ready thread with the highest priority\&. 
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INACTIVE\fP, see \fBKernel states\fP\&. 
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "void esSchedLockEnterI (void)"

.PP
Lock the scheduler\&. 
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INIT\fP, see \fBKernel states\fP\&. 
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "void esSchedLockExitI (void)"

.PP
Unlock the scheduler\&. 
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INIT\fP, see \fBKernel states\fP\&. 
.PP
2) \fCgKernLockCnt > 0U\fP, current number of locks must be greater than zero, in other words: each call to kernel lock function must have its matching call to kernel unlock function\&. 
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "void esSchedLockEnter (void)"

.PP
Lock the scheduler\&. 
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INIT\fP, see \fBKernel states\fP\&. 
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SS "void esSchedLockExit (void)"

.PP
Unlock the scheduler\&. 
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INIT\fP, see \fBKernel states\fP\&. 
.PP
2) \fCgKernLockCnt > 0U\fP, current number of locks must be greater than zero, in other words: each call to kernel lock function must have its matching call to kernel unlock function\&. 
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SS "void esVTmrInitI (\fBesVTmr_T\fP *vTmr, \fBesTick_T\fPtick, void(*)(void *)fn, void *arg)"

.PP
Add and start a new virtual timer\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvTmr\fP Virtual Timer: is pointer to the timer ID structure, \fBesVTmr\fP\&. 
.br
\fItick\fP Tick: the timer delay expressed in system ticks 
.br
\fIfn\fP Function: is pointer to the callback function 
.br
\fIarg\fP Argument: is pointer to the arguments of callback function 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INACTIVE\fP, see \fBKernel states\fP\&. 
.PP
2) \fCvTmr != NULL\fP 
.PP
3) \fCvTmr->signature != VTMR_CONTRACT_SIGNATURE\fP, the timer structure can't be initialized more than once\&. 
.PP
4) \fCtick > 1U\fP 
.PP
5) \fCfn != NULL\fP 
.RE
.PP
\fBPostcondition:\fP
.RS 4
1) \fCvTmr->signature == VTMR_CONTRACT_SIGNATURE\fP, each \fBesVTmr\fP structure will have valid signature after initialization\&. 
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "void esVTmrInit (\fBesVTmr_T\fP *vTmr, \fBesTick_T\fPtick, void(*)(void *)fn, void *arg)"

.PP
Add and start a new virtual timer\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvTmr\fP Virtual Timer: is pointer to the timer ID structure, \fBesVTmr\fP\&. 
.br
\fItick\fP Tick: the timer delay expressed in system ticks 
.br
\fIfn\fP Function: is pointer to the callback function 
.br
\fIarg\fP Argument: is pointer to the arguments of callback function 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INACTIVE\fP, see \fBKernel states\fP\&. 
.PP
2) \fCvTmr != NULL\fP 
.PP
3) \fCvTmr->signature != VTMR_CONTRACT_SIGNATURE\fP, the timer structure can't be initialized more than once\&. 
.PP
4) \fCtick > 1U\fP 
.PP
5) \fCfn != NULL\fP 
.RE
.PP
\fBPostcondition:\fP
.RS 4
1) \fCvTmr->signature == VTMR_CONTRACT_SIGNATURE\fP, each \fBesVTmr\fP structure will have valid signature after initialization\&. 
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SS "void esVTmrTermI (\fBesVTmr_T\fP *vTmr)"

.PP
Cancel and remove a virtual timer\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvTmr\fP Timer: is pointer to the timer ID structure, \fBesVTmr\fP\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INACTIVE\fP, see \fBKernel states\fP\&. 
.PP
2) \fCvTmr != NULL\fP 
.PP
3) \fCvTmr->signature == VTMR_CONTRACT_SIGNATURE\fP, the pointer must point to a valid \fBesVTmr\fP structure\&. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
1) \fCvTmr->signature = ~VTMR_CONTRACT_SIGNATURE\fP, each \fBesVTmr\fP structure will have invalid signature after termination\&. 
.RE
.PP
\fBFunction class:\fP
.RS 4
\fBI class\fP, Interrupt-lock API function, this function can be called only from interrupts locked code sections\&. 
.RE
.PP

.SS "void esVTmrTerm (\fBesVTmr_T\fP *vTmr)"

.PP
Cancel and remove a virtual timer\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvTmr\fP Timer: is pointer to the timer ID structure, \fBesVTmr\fP\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCThe kernel state < ES_KERN_INACTIVE\fP, see \fBKernel states\fP\&. 
.PP
2) \fCvTmr != NULL\fP 
.PP
3) \fCvTmr->signature == VTMR_CONTRACT_SIGNATURE\fP, the pointer must point to a valid \fBesVTmr\fP structure\&. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
1) \fCvTmr->signature = ~VTMR_CONTRACT_SIGNATURE\fP, each \fBesVTmr\fP structure will have invalid signature after termination\&. 
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SS "void esVTmrDelay (\fBesTick_T\fPtick)"

.PP
Delay for specified amount of ticks\&. 
.PP
\fBParameters:\fP
.RS 4
\fItick\fP Tick: number of system ticks to delay\&.
.RE
.PP
This function will create a virtual timer with count down time specified in argument \fCtick\fP and put the calling thread into \fCsleep\fP state\&. When timeout expires the thread will be placed back into \fCready\fP state\&. 
.PP
\fBPrecondition:\fP
.RS 4
1) \fCtick > 1U\fP 
.RE
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.SS "void userPreSysTmr (void)"

.PP
System timer hook function, called from system system timer ISR function before the kernel functions\&. 
.PP
\fBNote:\fP
.RS 4
1) This function is called only if \fBCFG_HOOK_PRE_SYSTMR_EVENT\fP is active\&.
.RE
.PP
This function is called whenever a system event is generated\&. 
.SS "void userPreKernInit (void)"

.PP
Kernel initialization hook function, called from \fBesKernInit()\fP function before kernel initialization\&. 
.PP
\fBNote:\fP
.RS 4
1) This function is called only if \fBCFG_HOOK_PRE_KERN_INIT\fP is active\&.
.RE
.PP
This function is called before the kernel initialization\&. 
.SS "void userPostKernInit (void)"

.PP
Kernel initialization hook function, called from \fBesKernInit()\fP function after kernel initialization\&. 
.PP
\fBNote:\fP
.RS 4
1) This function is called only if \fBCFG_HOOK_POST_KERN_INIT\fP is active\&.
.RE
.PP
This function is called after the kernel initialization\&. 
.SS "void userPreKernStart (void)"

.PP
Kernel start hook function, called from \fBesKernStart()\fP function\&. 
.PP
\fBNote:\fP
.RS 4
1) This function is called only if \fBCFG_HOOK_PRE_KERN_START\fP is active\&.
.RE
.PP
This function is called before kernel start\&. 
.SS "void userPostThdInit (\fBesThd_T\fP *thd)"

.PP
Thread initialization end hook function, called from \fBesThdInit()\fP function\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthd\fP Thread: pointer to thread Id structure that has just been initialized\&. 
.RE
.PP
\fBNote:\fP
.RS 4
1) This function is called only if \fBCFG_HOOK_POST_THD_INIT\fP is active\&.
.RE
.PP
This function is called after the thread initialization\&. 
.SS "void userPreThdTerm (void)"

.PP
Thread terminate hook function, called from \fBesThdTerm()\fP or when a thread terminates itself\&. 
.PP
\fBNote:\fP
.RS 4
1) This function is called only if \fBCFG_HOOK_PRE_THD_TERM\fP is active\&. 
.RE
.PP

.SS "void userPreIdle (void)"

.PP
Pre Idle hook function, called from idle thread, just before entering idle period\&. 
.PP
\fBNote:\fP
.RS 4
1) This function is called only if \fBCFG_HOOK_PRE_IDLE\fP and \fBCFG_SCHED_POWER_SAVE\fP are active\&. 
.PP
2) This function is called with interrupts and scheduler locked\&. 
.RE
.PP

.SS "void userPostIdle (void)"

.PP
Post idle hook function, called from idle thread, just after exiting idle period\&. 
.PP
\fBNote:\fP
.RS 4
1) This function is called only if \fBCFG_HOOK_POST_IDLE\fP and \fBCFG_SCHED_POWER_SAVE\fP are active\&. 
.PP
2) This function is called with scheduler locked\&. 
.RE
.PP

.SS "void userPreCtxSw (\fBesThd_T\fP *oldThd, \fBesThd_T\fP *newThd)"

.PP
Kernel context switch hook function, called from \fBesSchedYieldI()\fP and \fBesSchedYieldIsrI()\fP functions just before context switch\&. 
.PP
\fBParameters:\fP
.RS 4
\fIoldThd\fP Pointer to the thread being switched out\&. 
.br
\fInewThd\fP Pointer to the thread being switched in\&. 
.RE
.PP
\fBNote:\fP
.RS 4
1) This function is called only if \fBCFG_HOOK_PRE_CTX_SW\fP is active\&.
.RE
.PP
This function is called at each context switch\&. 
.SH "Variable Documentation"
.PP 
.SS "const volatile \fBesKernCtrl_T\fP gKernCtrl"

.PP
Kernel control block\&. 
.PP
\fBNote:\fP
.RS 4
This variable has Read-Only access rights for application\&.
.RE
.PP
Kernel control block\&. 
.SH "Author"
.PP 
Generated automatically by Doxygen for eSolid - Real-Time Kernel from the source code\&.
