.TH "Interface" 3 "Tue Oct 29 2013" "Version 1.0BetaR01" "eSolid - Real-Time Kernel" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Interface \- 
.PP
Application programming interface\&.  

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBdbgModInfo\fP"
.br
.RI "\fIDebug module information structure\&. \fP"
.ti -1c
.RI "struct \fBdbgCobj\fP"
.br
.RI "\fIDebug C object information structure\&. \fP"
.ti -1c
.RI "struct \fBesDbgReport\fP"
.br
.RI "\fIDebug report structure\&. \fP"
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBesDbgMsg\fP { \fBES_DBG_OUT_OF_RANGE\fP, \fBES_DBG_OBJECT_NOT_VALID\fP, \fBES_DBG_POINTER_NULL\fP, \fBES_DBG_USAGE_FAILURE\fP, \fBES_DBG_NOT_ENOUGH_MEM\fP, \fBES_DBG_UNKNOWN_ERROR\fP = 0xFFU }"
.br
.RI "\fIDebug messages\&. \fP"
.in -1c
.SS "Object and error source information"

.in +1c
.ti -1c
.RI "#define \fBDECL_MODULE_INFO\fP(modName, modDesc, modAuth)"
.br
.RI "\fIDeclare a module information card\&. \fP"
.in -1c
.SS "Error checking"
For more datails see \fBDebug: Error checking\fP\&. 
.in +1c
.ti -1c
.RI "PORT_C_NORETURN void \fBdbgAssert\fP (const PORT_C_ROM struct \fBdbgCobj\fP *cObj, const PORT_C_ROM char *expr, enum \fBesDbgMsg\fP msg)"
.br
.RI "\fIAn assertion has failed\&. \fP"
.ti -1c
.RI "#define \fBES_DBG_ASSERT\fP(msg, expr)"
.br
.RI "\fIGeneric assert macro\&. \fP"
.ti -1c
.RI "#define \fBES_DBG_ASSERT_ALWAYS\fP(msg, text)"
.br
.RI "\fIAssert macro that will always execute (no conditional)\&. \fP"
.in -1c
.SS "Internal checking"
These macros are enabled/disabled using the option \fBCFG_DBG_INTERNAL_CHECK\fP\&. 
.in +1c
.ti -1c
.RI "#define \fBES_DBG_INTERNAL\fP(msg, expr)   \fBES_DBG_ASSERT\fP(msg, expr)"
.br
.RI "\fIAssert macro used for internal execution checking\&. \fP"
.in -1c
.SS "API contract validation"
These macros are enabled/disabled using the option \fBCFG_DBG_API_VALIDATION\fP\&. 
.in +1c
.ti -1c
.RI "#define \fBES_DBG_API_OBLIGATION\fP(expr)   expr"
.br
.RI "\fIExecute code to fulfill the contract\&. \fP"
.ti -1c
.RI "#define \fBES_DBG_API_REQUIRE\fP(msg, expr)   \fBES_DBG_ASSERT\fP(msg, expr)"
.br
.RI "\fIMake sure the caller has fulfilled all contract preconditions\&. \fP"
.ti -1c
.RI "#define \fBES_DBG_API_ENSURE\fP(msg, expr)   \fBES_DBG_ASSERT\fP(msg, expr)"
.br
.RI "\fIMake sure the callee has fulfilled all contract postconditions\&. \fP"
.in -1c
.SS "Debug hook functions"

.PP
\fBNote:\fP
.RS 4
1) The definition of this functions must be written by the user\&. 
.RE
.PP

.in +1c
.ti -1c
.RI "void \fBuserAssert\fP (const struct \fBesDbgReport\fP *dbgReport)"
.br
.RI "\fIAn assertion has failed\&. This function should inform the user about failed assertion\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
Application programming interface\&. 


.SH "Macro Definition Documentation"
.PP 
.SS "#define DECL_MODULE_INFO(modName, modDesc, modAuth)"
\fBValue:\fP
.PP
.nf
static const PORT_C_ROM struct dbgModInfo gModInfo_ = {                     \
        modName,                                                                \
        modDesc,                                                                \
        modAuth,                                                                \
        PORT_C_FILE                                                             \
    }
.fi
.PP
Declare a module information card\&. 
.PP
\fBParameters:\fP
.RS 4
\fImodName\fP Module name : string 
.br
\fImodDesc\fP Module description : string 
.br
\fImodAuth\fP Module author : string 
.RE
.PP

.SS "#define ES_DBG_ASSERT(msg, expr)"
\fBValue:\fP
.PP
.nf
do {                                                                        \
        if (!(expr)) {                                                          \
            const PORT_C_ROM struct dbgCobj thisObj = {                         \
                \&.mod  = &gModInfo_,                                             \
                \&.fn   = PORT_C_FUNC,                                            \
                \&.line = PORT_C_LINE                                             \
            };                                                                  \\
            dbgAssert(&thisObj, #expr, msg);                                    \
        }                                                                       \
    } while (0u)
.fi
.PP
Generic assert macro\&. 
.PP
\fBParameters:\fP
.RS 4
\fImsg\fP Message : enum esDbgMsg : enumerated debug message\&. 
.br
\fIexpr\fP Expression : C expression : condition expression which must be TRUE\&. 
.RE
.PP

.SS "#define ES_DBG_ASSERT_ALWAYS(msg, text)"
\fBValue:\fP
.PP
.nf
do {                                                                        \
        const PORT_C_ROM struct dbgCobj thisObj = {                             \
            \&.mod  = &gModInfo_,                                                 \
            \&.fn   = PORT_C_FUNC,                                                \
            \&.line = PORT_C_LINE                                                 \
        };                                                                      \\
        dbgAssert(PORT_C_FUNC, text, msg);                                      \
    } while (0u)
.fi
.PP
Assert macro that will always execute (no conditional)\&. 
.PP
\fBParameters:\fP
.RS 4
\fImsg\fP Message : enum esDbgMsg : enumerated debug message\&. 
.br
\fItext\fP Text : string : a text which will be printed when this assert macro is executed\&. 
.RE
.PP

.SS "#define ES_DBG_INTERNAL(msg, expr)   \fBES_DBG_ASSERT\fP(msg, expr)"

.PP
Assert macro used for internal execution checking\&. 
.PP
\fBParameters:\fP
.RS 4
\fImsg\fP Message : enum esDbgMsg : enumerated debug message\&. 
.br
\fIexpr\fP Expression : C expression : condition expression which must be satisfied 
.RE
.PP

.SS "#define ES_DBG_API_OBLIGATION(expr)   expr"

.PP
Execute code to fulfill the contract\&. 
.PP
\fBParameters:\fP
.RS 4
\fIexpr\fP Expression : C expression : expression to be executed only if contracts need to be validated\&. 
.RE
.PP

.SS "#define ES_DBG_API_REQUIRE(msg, expr)   \fBES_DBG_ASSERT\fP(msg, expr)"

.PP
Make sure the caller has fulfilled all contract preconditions\&. 
.PP
\fBParameters:\fP
.RS 4
\fImsg\fP Message : enum esDbgMsg : enumerated debug message\&. 
.br
\fIexpr\fP Expression : C expression : condition expression which must be satisfied 
.RE
.PP

.SS "#define ES_DBG_API_ENSURE(msg, expr)   \fBES_DBG_ASSERT\fP(msg, expr)"

.PP
Make sure the callee has fulfilled all contract postconditions\&. 
.PP
\fBParameters:\fP
.RS 4
\fImsg\fP Message : enum esDbgMsg : enumerated debug message\&. 
.br
\fIexpr\fP Expression : C expression : condition expression which must be satisfied 
.RE
.PP

.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBesDbgMsg\fP"

.PP
Debug messages\&. 
.PP
\fBObject class:\fP
.RS 4
Regular \fBAPI\fP object, this object is part of the application programming interface\&. 
.RE
.PP

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIES_DBG_OUT_OF_RANGE \fP\fP
Value is out of valid range\&. 
.TP
\fB\fIES_DBG_OBJECT_NOT_VALID \fP\fP
Object is not valid\&. 
.TP
\fB\fIES_DBG_POINTER_NULL \fP\fP
Pointer has NULL value\&. 
.TP
\fB\fIES_DBG_USAGE_FAILURE \fP\fP
Object usage failure\&. 
.TP
\fB\fIES_DBG_NOT_ENOUGH_MEM \fP\fP
Not enough memory available\&. 
.TP
\fB\fIES_DBG_UNKNOWN_ERROR \fP\fP
Unknown error\&. 
.SH "Function Documentation"
.PP 
.SS "PORT_C_NORETURN void dbgAssert (const PORT_C_ROM struct \fBdbgCobj\fP *cObj, const PORT_C_ROM char *expr, enum \fBesDbgMsg\fPmsg)"

.PP
An assertion has failed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIcObj\fP C Object describes where the error occured\&. 
.br
\fIexpr\fP Expression: is pointer to the string containing the expression that failed to evaluate to \fCTRUE\fP\&. 
.br
\fImsg\fP Message: is enum esDbgMsg containing some information about the error\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCNULL != cObj\fP 
.PP
2) \fCNULL != expr\fP 
.RE
.PP
\fBNote:\fP
.RS 4
1) This function is called only if \fBCFG_DBG_API_VALIDATION\fP is active\&.
.RE
.PP
Function will just print the information which was given by the macros\&. 
.PP
\fBObject class:\fP
.RS 4
\fBNot API\fP object, this object is not part of the application programming interface and it is intended for internal use only\&. 
.RE
.PP

.SS "void userAssert (const struct \fBesDbgReport\fP *dbgReport)"

.PP
An assertion has failed\&. This function should inform the user about failed assertion\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdbgReport\fP Debug report: is pointer to the debug report created by \fBdbgAssert()\fP function\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
1) \fCNULL != dbgReport\fP 
.RE
.PP
\fBNote:\fP
.RS 4
1) This function is called only if \fBCFG_DBG_ENABLE\fP is active\&. 
.PP
2) The function is called with interrupts disabled\&.
.RE
.PP
Function will just print the information which was given by the macros\&. 
.SH "Author"
.PP 
Generated automatically by Doxygen for eSolid - Real-Time Kernel from the source code\&.
